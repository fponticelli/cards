{
"version":3,
"file":"app.js",
"sourceRoot":"file://",
"sources":["/usr/lib/haxe/std/js/_std/EReg.hx","/usr/lib/haxe/std/js/_std/HxOverrides.hx","/usr/lib/haxe/std/Lambda.hx","/usr/lib/haxe/std/List.hx","/Users/francoponticelli/projects/cards/haxe/src/Main.hx","/usr/lib/haxe/std/js/_std/Reflect.hx","/usr/lib/haxe/std/js/_std/Std.hx","/usr/lib/haxe/std/StringBuf.hx","/usr/lib/haxe/std/StringTools.hx","/usr/lib/haxe/std/js/_std/Type.hx","/Users/francoponticelli/projects/cards/haxe/src/dom/Dom.hx","/usr/lib/haxe/std/haxe/CallStack.hx","/usr/lib/haxe/std/haxe/Log.hx","/usr/lib/haxe/std/js/_std/haxe/ds/IntMap.hx","/usr/lib/haxe/std/js/_std/haxe/ds/ObjectMap.hx","/usr/lib/haxe/std/js/_std/haxe/ds/StringMap.hx","/usr/lib/haxe/std/haxe/io/Eof.hx","/usr/lib/haxe/std/js/Boot.hx","/Users/francoponticelli/projects/extern/promhx/src/main/promhx/base/AsyncBase.hx","/Users/francoponticelli/projects/extern/promhx/src/main/promhx/Promise.hx","/Users/francoponticelli/projects/extern/promhx/src/main/promhx/base/EventLoop.hx","/Users/francoponticelli/projects/steamer/src/steamer/Consumer.hx","/Users/francoponticelli/projects/steamer/src/steamer/Producer.hx","/Users/francoponticelli/projects/steamer/src/steamer/MultiProducer.hx","/Users/francoponticelli/projects/steamer/src/steamer/Pulse.hx","/Users/francoponticelli/projects/steamer/src/steamer/SimpleConsumer.hx","/Users/francoponticelli/projects/steamer/src/steamer/Value.hx","/Users/francoponticelli/projects/steamer/src/steamer/dom/Dom.hx","/Users/francoponticelli/projects/steamer/src/steamer/producers/Interval.hx","/Users/francoponticelli/projects/cards/haxe/src/sui/components/Component.hx","/Users/francoponticelli/projects/cards/haxe/src/sui/components/Properties.hx","/Users/francoponticelli/projects/cards/haxe/src/sui/properties/Property.hx","/Users/francoponticelli/projects/cards/haxe/src/sui/properties/Attribute.hx","/Users/francoponticelli/projects/cards/haxe/src/sui/properties/PropertyName.hx","/Users/francoponticelli/projects/cards/haxe/src/sui/properties/Text.hx","/Users/francoponticelli/projects/steamer/src/thx/Error.hx","/Users/francoponticelli/projects/thx.core/src/thx/Assert.hx","/Users/francoponticelli/projects/steamer/src/thx/Timer.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Arrays.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Ints.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Iterables.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Iterators.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Objects.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Strings.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Types.hx","/Users/francoponticelli/projects/cards/haxe/src/thx/ref/BaseRef.hx","/Users/francoponticelli/projects/cards/haxe/src/thx/ref/ArrayRef.hx","/Users/francoponticelli/projects/cards/haxe/src/thx/ref/ObjectRef.hx","/Users/francoponticelli/projects/cards/haxe/src/thx/ref/Ref.hx","/Users/francoponticelli/projects/cards/haxe/src/thx/ref/UnknownRef.hx","/Users/francoponticelli/projects/cards/haxe/src/thx/ref/ValueRef.hx","/Users/francoponticelli/projects/cards/haxe/src/ui/Button.hx","/Users/francoponticelli/projects/cards/haxe/src/ui/Card.hx","/Users/francoponticelli/projects/cards/haxe/src/ui/Data.hx","/Users/francoponticelli/projects/cards/haxe/src/ui/Field.hx","/Users/francoponticelli/projects/cards/haxe/src/ui/Model.hx","/Users/francoponticelli/projects/cards/haxe/src/ui/ModelView.hx","/Users/francoponticelli/projects/cards/haxe/src/ui/Schema.hx","/Users/francoponticelli/projects/cards/haxe/src/ui/TextEditor.hx","/Users/francoponticelli/projects/cards/haxe/src/ui/Toolbar.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\n\tvar r : Dynamic;\n\n\tpublic function new( r : String, opt : String ) : Void {\n\t\topt = opt.split(\"u\").join(\"\"); // 'u' (utf8) depends on page encoding\n\t\tthis.r = untyped __new__(\"RegExp\",r,opt);\n\t}\n\n\tpublic function match( s : String ) : Bool {\n\t\tif( r.global ) r.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched( n : Int ) : String {\n\t\treturn if( r.m != null && n >= 0 && n < r.m.length ) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn r.s.substr(0,r.m.index);\n\t}\n\n\tpublic function matchedRight() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\tvar sz = r.m.index+r.m[0].length;\n\t\treturn r.s.substr(sz,r.s.length-sz);\n\t}\n\n\tpublic function matchedPos() : { pos : Int, len : Int } {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn { pos : r.m.index, len : r.m[0].length };\n\t}\n\n\tpublic function matchSub( s : String, pos : Int, len : Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match( len < 0 ? s.substr(pos) : s.substr(pos,len) );\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split( s : String ) : Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn untyped s.replace(r,d).split(d);\n\t}\n\n\tpublic function replace( s : String, by : String ) : String {\n\t\treturn untyped s.replace(r,by);\n\t}\n\n\tpublic function map( s : String, f : EReg -> String ) : String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\t#if mt\n\t\tvar x = (cast s).cca(index);\n\t\t#else\n\t\tvar x = (cast s).charCodeAt(index);\n\t\t#end\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn untyped undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif( pos != null && pos != 0 && len != null && len < 0 ) return \"\";\n\t\tif( len == null ) len = s.length;\n\t\tif( pos < 0 ){\n\t\t\tpos = s.length + pos;\n\t\t\tif( pos < 0 ) pos = 0;\n\t\t}else if( len < 0 ){\n\t\t\tlen = s.length + len - pos;\n\t\t}\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if !js_es5\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\n#if mt\n\t\tif( String.prototype.cca == null ) String.prototype.cca = String.prototype.charCodeAt;\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tThe `Lambda` class is a collection of methods to support functional\n\tprogramming. It is ideally used with 'using Lambda' and then acts as an\n\textension to Iterable types.\n\n\tOn static platforms, working with the Iterable structure might be slower\n\tthan performing the operations directly on known types, such as Array and\n\tList.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\nclass Lambda {\n\n\t/**\n\t\tCreates an Array from Iterable `it`.\n\n\t\tIf `it` is an Array, this function returns a copy of it.\n\t**/\n\tpublic static function array<A>( it : Iterable<A> ) : Array<A> {\n\t\tvar a = new Array<A>();\n\t\tfor(i in it)\n\t\t\ta.push(i);\n\t\treturn a;\n\t}\n\n\t/**\n\t\tCreates a List form Iterable `it`.\n\n\t\tIf `it` is a List, this function returns a copy of it.\n\t**/\n\tpublic static function list<A>( it : Iterable<A> ) : List<A> {\n\t\tvar l = new List<A>();\n\t\tfor(i in it)\n\t\t\tl.add(i);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tCreates a new List by applying function `f` to all elements of `it`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function map<A,B>( it : Iterable<A>, f : A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tfor( x in it )\n\t\t\tl.add(f(x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tSimilar to map, but also passes the index of each element to `f`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function mapi<A,B>( it : Iterable<A>, f : Int -> A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tvar i = 0;\n\t\tfor( x in it )\n\t\t\tl.add(f(i++,x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tTells if `it` contains `elt`.\n\n\t\tThis function returns true as soon as an element is found which is equal\n\t\tto `elt` according to the `==` operator.\n\n\t\tIf no such element is found, the result is false.\n\t**/\n\tpublic static function has<A>( it : Iterable<A>, elt : A ) : Bool {\n\t\tfor( x in it )\n\t\t\tif( x == elt )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `it` contains an element for which `f` is true.\n\n\t\tThis function returns true as soon as an element is found for which a\n\t\tcall to `f` returns true.\n\n\t\tIf no such element is found, the result is false.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function exists<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `f` is true for all elements of `it`.\n\n\t\tThis function returns false as soon as an element is found for which a\n\t\tcall to `f` returns false.\n\n\t\tIf no such element is found, the result is true.\n\n\t\tIn particular, this function always returns true if `it` is empty.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function foreach<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( !f(x) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tCalls `f` on all elements of `it`, in order.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function iter<A>( it : Iterable<A>, f : A -> Void ) {\n\t\tfor( x in it )\n\t\t\tf(x);\n\t}\n\n\t/**\n\t\tReturns a List containing those elements of `it` for which `f` returned\n\t\ttrue.\n\n\t\tIf `it` is empty, the result is the empty List even if `f` is null.\n\n\t\tOtherwise if `f` is null, the result is unspecified.\n\t**/\n\tpublic static function filter<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tvar l = new List<A>();\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tFunctional fold on Iterable `it`, using function `f` with start argument\n\t\t`first`.\n\n\t\tIf `it` has no elements, the result is `first`.\n\n\t\tOtherwise the first element of `it` is passed to `f` alongside `first`.\n\t\tThe result of that call is then passed to `f` with the next element of\n\t\t`it`, and so on until `it` has no more elements.\n\n\t\tIf `it` or `f` are null, the result is unspecified.\n\t**/\n\tpublic static function fold<A,B>( it : Iterable<A>, f : A -> B -> B, first : B ) : B {\n\t\tfor( x in it )\n\t\t\tfirst = f(x,first);\n\t\treturn first;\n\t}\n\n\t/**\n\t\tReturns the number of elements in `it` for which `pred` is true, or the\n\t\ttotal number of elements in `it` if `pred` is null.\n\n\t\tThis function traverses all elements.\n\t**/\n\tpublic static function count<A>( it : Iterable<A>, ?pred : A -> Bool ) {\n\t\tvar n = 0;\n\t\tif( pred == null )\n\t\t\tfor( _ in it )\n\t\t\t\tn++;\n\t\telse\n\t\t\tfor( x in it )\n\t\t\t\tif( pred(x) )\n\t\t\t\t\tn++;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tTells if Iterable `it` does not contain any element.\n\t**/\n\tpublic static function empty<T>( it : Iterable<T> ) : Bool {\n\t\treturn !it.iterator().hasNext();\n\t}\n\n\t/**\n\t\tReturns the index of the first element `v` within Iterable `it`.\n\n\t\tThis function uses operator `==` to check for equality.\n\n\t\tIf `v` does not exist in `it`, the result is -1.\n\t**/\n\tpublic static function indexOf<T>( it : Iterable<T>, v : T ) : Int {\n\t\tvar i = 0;\n\t\tfor( v2 in it ) {\n\t\t\tif( v == v2 )\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t\tReturns the first element of `it` for which `f` is true.\n\n\t\tThis function returns as soon as an element is found for which a call to\n\t\t`f` returns true.\n\n\t\tIf no such element is found, the result is null.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function find<T>( it : Iterable<T>, f : T -> Bool ) : Null<T> {\n\t\tfor( v in it ) {\n\t\t\tif(f(v)) return v;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tReturns a new List containing all elements of Iterable `a` followed by\n\t\tall elements of Iterable `b`.\n\n\t\tIf `a` or `b` are null, the result is unspecified.\n\t**/\n\tpublic static function concat<T>( a : Iterable<T>, b : Iterable<T> ) : List<T> {\n\t\tvar l = new List();\n\t\tfor( x in a )\n\t\t\tl.add(x);\n\t\tfor( x in b )\n\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA linked-list of elements. The list is composed of two-elements arrays\n\tthat are chained together. It is optimized so that adding or removing an\n\telement does not imply copying the whole array content every time.\n**/\nclass List<T> {\n\n\tprivate var h : Array<Dynamic>;\n\tprivate var q : Array<Dynamic>;\n\n\t/**\n\t\tThe length of `this` List.\n\t**/\n\tpublic var length(default,null) : Int;\n\n\t/**\n\t\tCreates a new empty list.\n\t**/\n\tpublic function new() {\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tAdds element `item` at the end of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function add( item : T ) {\n\t\tvar x:Array<Dynamic> = #if neko untyped __dollar__array(item,null) #else [item] #end;\n\t\tif( h == null )\n\t\t\th = x;\n\t\telse\n\t\t\tq[1] = x;\n\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tAdds element `item` at the beginning of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function push( item : T ) {\n\t\tvar x : Array<Dynamic> = #if neko\n\t\t\tuntyped __dollar__array(item,h)\n\t\t#else\n\t\t\t[item,h]\n\t\t#end;\n\t\th = x;\n\t\tif( q == null )\n\t\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function first() : Null<T> {\n\t\treturn if( h == null ) null else h[0];\n\t}\n\n\t/**\n\t\tReturns the last element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function last() : Null<T> {\n\t\treturn if( q == null ) null else q[0];\n\t}\n\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThe element is removed from `this` List.\n\t**/\n\tpublic function pop() : Null<T> {\n\t\tif( h == null )\n\t\t\treturn null;\n\t\tvar x = h[0];\n\t\th = h[1];\n\t\tif( h == null )\n\t\t\tq = null;\n\t\tlength--;\n\t\treturn x;\n\t}\n\n\t/**\n\t\tTells if `this` List is empty.\n\t**/\n\tpublic function isEmpty() : Bool {\n\t\treturn (h == null);\n\t}\n\n\t/**\n\t\tEmpties `this` List.\n\n\t\tThis function does not traverse the elements, but simply sets the\n\t\tinternal references to null and `this.length` to 0.\n\t**/\n\tpublic function clear() : Void {\n\t\th = null;\n\t\tq = null;\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tRemoves the first occurence of `v` in `this` List.\n\n\t\tIf `v` is found by checking standard equality, it is removed from `this`\n\t\tList and the function returns true.\n\n\t\tOtherwise, false is returned.\n\t**/\n\tpublic function remove( v : T ) : Bool {\n\t\tvar prev = null;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( l[0] == v ) {\n\t\t\t\tif( prev == null )\n\t\t\t\t\th = l[1];\n\t\t\t\telse\n\t\t\t\t\tprev[1] = l[1];\n\t\t\t\tif( q == l )\n\t\t\t\t\tq = prev;\n\t\t\t\tlength--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprev = l;\n\t\t\tl = l[1];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tReturns an iterator on the elements of the list.\n\t**/\n\tpublic function iterator() : Iterator<T> {\n\t\t#if (java || cs || python)\n\t\tvar h = h;\n\t\treturn cast {\n\t\t\thasNext : function() {\n\t\t\t\treturn (h != null);\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\t{\n\t\t\t\t\tif( h == null )\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tvar x = h[0];\n\t\t\t\t\th = h[1];\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#else\n\t\treturn cast {\n\t\t\th : h,\n\t\t\thasNext : function() {\n\t\t\t\treturn untyped (__this__.h != null);\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\tuntyped {\n\t\t\t\t\tif( __this__.h == null )\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tvar x = __this__.h[0];\n\t\t\t\t\t__this__.h = __this__.h[1];\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List.\n\n\t\tThe result is enclosed in { } with the individual elements being\n\t\tseparated by a comma.\n\t**/\n\tpublic function toString() {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\ts.add(\"{\");\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(\", \");\n\t\t\ts.add(Std.string(l[0]));\n\t\t\tl = l[1];\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List, with `sep` separating\n\t\teach element.\n\t**/\n\tpublic function join(sep : String) {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(sep);\n\t\t\ts.add(l[0]);\n\t\t\tl = l[1];\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a list filtered with `f`. The returned list will contain all\n\t\telements for which `f(x) == true`.\n\t**/\n\tpublic function filter( f : T -> Bool ) {\n\t\tvar l2 = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tif( f(v) )\n\t\t\t\tl2.add(v);\n\t\t}\n\t\treturn l2;\n\t}\n\n\t/**\n\t\tReturns a new list where all elements have been converted by the\n\t\tfunction `f`.\n\t**/\n\tpublic function map<X>(f : T -> X) : List<X> {\n\t\tvar b = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tb.add(f(v));\n\t\t}\n\t\treturn b;\n\t}\n\n}\n","import dom.Dom;\nimport sui.components.*;\nimport sui.properties.*;\nimport steamer.*;\nimport ui.*;\nimport ui.Card;\n\nclass Main {\n\tpublic static function main() {\n\t\tDom.ready().then(function(_) {\n\t\t\tvar container = Query.first('.container'),\n\t\t\t\tschema    = new Schema(),\n\t\t\t\tdata      = new Data({\n\t\t\t\t\tname : \"Franco\",\n\t\t\t\t\tcontacts : [{\n\t\t\t\t\t\ttype : \"email\",\n\t\t\t\t\t\tvalue : \"franco.ponticelli@gmail.com\"\n\t\t\t\t\t}, {\n\t\t\t\t\t\ttype : \"phone\",\n\t\t\t\t\t\tvalue : \"7206902488\"\n\t\t\t\t\t}]\n\t\t\t\t}),\n\t\t\t\tmodel     = new Model(data);\n\t\t\ttrace(\"Hello World\");\n\t\t\tdata.set('contacts[2]', { type : 'twitter', value : 'fponticelli' });\n\t\t\tdata.set('contacts[3].type', 'skype');\n\t\t\tdata.set('contacts[3].value', 'francoponticelli');\n\t\t\ttrace(data.toJSON());\n\n\t\t\t// Card\n\t\t\tCard.create(model, schema, container);\n\t\t});\n\t}\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\n\tpublic inline static function hasField( o : Dynamic, field : String ) : Bool {\n\t\treturn untyped __js__('Object').prototype.hasOwnProperty.call(o, field);\n\t}\n\n\tpublic static function field( o : Dynamic, field : String ) : Dynamic untyped {\n\t\treturn try o[field] catch( e : Dynamic ) null;\n\t}\n\n\tpublic inline static function setField( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\to[field] = value;\n\t}\n\n\tpublic static inline function getProperty( o : Dynamic, field : String ) : Dynamic untyped {\n\t\tvar tmp;\n\t\treturn if( o == null ) __define_feature__(\"Reflect.getProperty\",null) else if( o.__properties__ && (tmp=o.__properties__[\"get_\"+field]) ) o[tmp]() else o[field];\n\t}\n\n\tpublic static inline function setProperty( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\tvar tmp;\n\t\tif( o.__properties__ && (tmp=o.__properties__[\"set_\"+field]) ) o[tmp](value) else o[field] = __define_feature__(\"Reflect.setProperty\",value);\n\t}\n\n\tpublic inline static function callMethod( o : Dynamic, func : Dynamic, args : Array<Dynamic> ) : Dynamic untyped {\n\t\treturn func.apply(o,args);\n\t}\n\n\tpublic static function fields( o : Dynamic ) : Array<String> {\n\t\tvar a = [];\n\t\tif (o != null) untyped {\n\t\t\tvar hasOwnProperty = __js__('Object').prototype.hasOwnProperty;\n\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\tif( f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f) ) a.push(f);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static function isFunction( f : Dynamic ) : Bool untyped {\n\t\treturn __js__(\"typeof(f)\") == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>( a : T, b : T ) : Int {\n\t\treturn ( a == b ) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods( f1 : Dynamic, f2 : Dynamic ) : Bool {\n\t\tif( f1 == f2 )\n\t\t\treturn true;\n\t\tif( !isFunction(f1) || !isFunction(f2) )\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\tpublic static function isObject( v : Dynamic ) : Bool untyped {\n\t\tif( v == null )\n\t\t\treturn false;\n\t\tvar t = __js__(\"typeof(v)\");\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null)) || (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue( v : Dynamic ) : Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField( o : Dynamic, field : String ) : Bool untyped {\n\t\tif( !hasField(o,field) ) return false;\n\t\t__js__(\"delete\")(o[field]);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>( o : T ) : T {\n\t\tvar o2 : Dynamic = {};\n\t\tfor( f in Reflect.fields(o) )\n\t\t\tReflect.setField(o2,f,Reflect.field(o,f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function( f : Array<Dynamic> -> Void ) : Dynamic {})\n\tpublic static function makeVarArgs( f : Array<Dynamic> -> Dynamic ) : Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn cast(x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tIts cross-platform implementation uses String concatenation internally, but\n\tStringBuf may be optimized for different targets.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues. However, the internal buffer cannot be modified.\n**/\nclass StringBuf {\n\n\tvar b:String = \"\";\n\n\t/**\n\t\tThe length of `this` StringBuf in characters.\n\t**/\n\tpublic var length(get,never) : Int;\n\n\t/**\n\t\tCreates a new StringBuf instance.\n\n\t\tThis may involve initialization of the internal buffer.\n\t**/\n\tpublic function new() {}\n\n\tinline function get_length() : Int {\n\t\treturn b.length;\n\t}\n\n\t/**\n\t\tAppends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.\n\t**/\n\tpublic inline function add<T>( x : T ) : Void {\n\t\tb += x;\n\t}\n\n\t/**\n\t\tAppends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.\n\t**/\n\tpublic inline function addChar( c : Int ) : Void {\n\t\tb += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tAppends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.\n\t**/\n\tpublic inline function addSub( s : String, pos : Int, ?len : Int) : Void {\n\t\tb += (len == null ? s.substr(pos) : s.substr(pos, len));\n\t}\n\n\t/**\n\t\tReturns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation.\n\t**/\n\tpublic inline function toString() : String {\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t'using StringTools' and then acts as an extension to the String class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\n#if cs\n@:keep\n#end\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlEncode( s : String ) : String {\n\t\t#if flash9\n\t\t\treturn untyped __global__[\"encodeURIComponent\"](s);\n\t\t#elseif flash\n\t\t\treturn untyped _global[\"escape\"](s);\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped encodeURIComponent(s);\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLEncode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLEncoder.encode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.EscapeUriString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.quote(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlDecode( s : String ) : String {\n\t\t#if flash9\n\t\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif flash\n\t\t\treturn untyped _global[\"unescape\"](s);\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLDecode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLDecoder.decode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.unquote(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape( s : String, ?quotes : Bool ) : String {\n\t\ts = s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t\treturn quotes ? s.split('\"').join(\"&quot;\").split(\"'\").join(\"&#039;\") : s;\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: htmlUnescape(htmlEscape(s)) == s\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape( s : String ) : String {\n\t\treturn s.split(\"&gt;\").join(\">\").split(\"&lt;\").join(\"<\").split(\"&quot;\").join('\"').split(\"&#039;\").join(\"'\").split(\"&amp;\").join(\"&\");\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is null, the result is unspecified.\n\n\t\tIf `start` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function startsWith( s : String, start : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#else\n\t\treturn( s.length >= start.length && s.substr(0, start.length) == start );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is null, the result is unspecified.\n\n\t\tIf `end` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function endsWith( s : String, end : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn( slen >= elen && s.substr(slen - elen, elen) == end );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String \"\", or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace( s : String, pos : Int ) : Bool {\n\t\t#if python\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length) return false;\n\t\t#end\n\t\tvar c = s.charCodeAt( pos );\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function ltrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,r) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 )\n\t\t\treturn s.substr(r, l-r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function rtrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,l-r-1) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 ){\n\t\t\treturn s.substr(0, l-r);\n\t\t}else{\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for ltrim(rtrim(s)).\n\t**/\n\tpublic #if (cs || java) inline #end static function trim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn untyped s.trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = c + s;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = s + c;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReplace all occurences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String \"\", `by` is inserted after each character\n\t\tof `s`. If `by` is also the empty String \"\", `s` remains unchanged.\n\n\t\tThis is a convenience function for `s.split(sub).join(by)`.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace( s : String, sub : String, by : String ) : String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits length equals `digits`.\n\t**/\n\tpublic static function hex( n : Int, ?digits : Int ) {\n\t\t#if flash9\n\t\t\tvar n : UInt = n;\n\t\t\tvar s : String = untyped n.toString(16);\n\t\t\ts = s.toUpperCase();\n\t\t#else\n\t\t\tvar s = \"\";\n\t\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\t\tdo {\n\t\t\t\ts = hexChars.charAt(n&15) + s;\n\t\t\t\tn >>>= 4;\n\t\t\t} while( n > 0 );\n\t\t#end\n\t\t#if python\n\t\tif (digits != null && s.length < digits) {\n\t\t\tvar diff = digits - s.length;\n\t\t\tfor (_ in 0...diff) {\n\t\t\t\ts = \"0\" + s;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tif( digits != null )\n\t\t\twhile( s.length < digits )\n\t\t\t\ts = \"0\"+s;\n\t\t#end\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than String.charCodeAt() on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the \\0\n\t\tcharacter.\n\t**/\n\tpublic static inline function fastCodeAt( s : String, index : Int ) : Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash9\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s[\"cca\"](index);\n\t\t#elseif java\n\t\treturn ( index < s.length ) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn ( cast(index, UInt) < s.length ) ? cast(s[index], Int) : -1;\n\t\t#elseif js\n\t\treturn (untyped s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.lib.Builtin.ord(python.Syntax.arrayAccess(s, index));\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/*\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t*/\n\t@:noUsing public static inline function isEof( c : Int ) : Bool {\n\t\t#if (flash9 || cpp)\n\t\treturn c == 0;\n\t\t#elseif flash8\n\t\treturn c <= 0; // fast NaN\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif neko\n\t\treturn c == null;\n\t\t#elseif cs\n\t\treturn c == -1;\n\t\t#elseif java\n\t\treturn c == -1;\n\t\t#elseif python\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16 return untyped str._charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\",\"url_encode\",1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\",\"url_decode\",1);\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass( c : Class<Dynamic> );\n\tTEnum( e : Enum<Dynamic> );\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\n\tpublic static function getClass<T>( o : T ) : Class<T> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum( o : EnumValue ) : Enum<Dynamic> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn o.__enum__;\n\t}\n\n\tpublic static function getSuperClass( c : Class<Dynamic> ) : Class<Dynamic> untyped {\n\t\treturn c.__super__;\n\t}\n\n\n\tpublic static function getClassName( c : Class<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped c.__name__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function getEnumName( e : Enum<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped e.__ename__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function resolveClass( name : String ) : Class<Dynamic> untyped {\n\t\tvar cl : Class<Dynamic> = $hxClasses[name];\n\t\t// ensure that this is a class\n\t\tif( cl == null || !js.Boot.isClass(cl) )\n\t\t\treturn null;\n\t\treturn cl;\n\t}\n\n\tpublic static function resolveEnum( name : String ) : Enum<Dynamic> untyped {\n\t\tvar e : Dynamic = $hxClasses[name];\n\t\t// ensure that this is an enum\n\t\tif( e == null || !js.Boot.isEnum(e) )\n\t\t\treturn null;\n\t\treturn e;\n\t}\n\n\tpublic static function createInstance<T>( cl : Class<T>, args : Array<Dynamic> ) : T untyped {\n\t\tswitch( args.length ) {\n\t\tcase 0:\n\t\t\treturn __new__(cl);\n\t\tcase 1:\n\t\t\treturn __new__(cl,args[0]);\n\t\tcase 2:\n\t\t\treturn __new__(cl,args[0],args[1]);\n\t\tcase 3:\n\t\t\treturn __new__(cl,args[0],args[1],args[2]);\n\t\tcase 4:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3]);\n\t\tcase 5:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4]);\n\t\tcase 6:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5]);\n\t\tcase 7:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);\n\t\tcase 8:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);\n\t\tdefault:\n\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static function createEmptyInstance<T>( cl : Class<T> ) : T untyped {\n\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\treturn __js__(\"new empty()\");\n\t}\n\n\tpublic static function createEnum<T>( e : Enum<T>, constr : String, ?params : Array<Dynamic> ) : T {\n\t\tvar f = Reflect.field(e,constr);\n\t\tif( f == null ) throw \"No such constructor \"+constr;\n\t\tif( Reflect.isFunction(f) ) {\n\t\t\tif( params == null ) throw \"Constructor \"+constr+\" need parameters\";\n\t\t\treturn Reflect.callMethod(e,f,params);\n\t\t}\n\t\tif( params != null && params.length != 0 )\n\t\t\tthrow \"Constructor \"+constr+\" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>( e : Enum<T>, index : Int, ?params : Array<Dynamic> ) : T {\n\t\tvar c : String = (untyped e.__constructs__)[index];\n\t\tif( c == null ) throw index+\" is not a valid enum constructor index\";\n\t\treturn createEnum(e,c,params);\n\t}\n\n\tpublic static function getInstanceFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\n\tpublic static function getEnumConstructs( e : Enum<Dynamic> ) : Array<String> {\n\t\tvar a : Array<String> = untyped e.__constructs__;\n\t\treturn a.copy();\n\t}\n\n\tpublic static function typeof( v : Dynamic ) : ValueType untyped {\n\t\tswitch( __js__(\"typeof\")(v) ) {\n\t\tcase \"boolean\": return TBool;\n\t\tcase \"string\": return TClass(String);\n\t\tcase \"number\":\n\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\tif( Math.ceil(v) == v%2147483648.0 )\n\t\t\t\treturn TInt;\n\t\t\treturn TFloat;\n\t\tcase \"object\":\n\t\t\tif( v == null )\n\t\t\t\treturn TNull;\n\t\t\tvar e = v.__enum__;\n\t\t\tif( e != null )\n\t\t\t\treturn TEnum(e);\n\t\t\tvar c = js.Boot.getClass(v);\n\t\t\tif( c != null )\n\t\t\t\treturn TClass(c);\n\t\t\treturn TObject;\n\t\tcase \"function\":\n\t\t\tif( js.Boot.isClass(v) || js.Boot.isEnum(v) )\n\t\t\t\treturn TObject;\n\t\t\treturn TFunction;\n\t\tcase \"undefined\":\n\t\t\treturn TNull;\n\t\tdefault:\n\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T>( a : T, b : T ) : Bool untyped {\n\t\tif( a == b )\n\t\t\treturn true;\n\t\ttry {\n\t\t\tif( a[0] != b[0] )\n\t\t\t\treturn false;\n\t\t\tfor( i in 2...a.length )\n\t\t\t\tif( !enumEq(a[i],b[i]) )\n\t\t\t\t\treturn false;\n\t\t\tvar e = a.__enum__;\n\t\t\tif( e != b.__enum__ || e == null )\n\t\t\t\treturn false;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic inline static function enumConstructor( e : EnumValue ) : String {\n\t\treturn untyped e[0];\n\t}\n\n\tpublic inline static function enumParameters( e : EnumValue ) : Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\n\tpublic inline static function enumIndex( e : EnumValue ) : Int {\n\t\treturn untyped e[1];\n\t}\n\n\tpublic static function allEnums<T>( e : Enum<T> ) : Array<T> {\n\t\treturn untyped e.__empty_constructs__;\n\t}\n\n}\n\n","package dom;\n\nimport js.html.Element;\nimport steamer.Producer;\nimport thx.Nil;\nimport promhx.Promise;\n\nclass Html {\n\tpublic static function parseList(html : String) {\n\t\tvar el = js.Browser.document.createElement('div');\n\t\tel.innerHTML = html;\n\t\treturn el.childNodes;\n\t}\n\n\tpublic inline static function parseAll(html : String) {\n\t\treturn H.toArray(parseList(html));\n\t}\n\n\t// TODO unsafe cast\n\tpublic inline static function parse(html : String) : Element {\n\t\treturn cast parseList(html)[0];\n\t}\n}\n\nclass Dom {\n\tpublic static function ready() : Promise<Nil> {\n\t\tvar deferred = new promhx.Promise();\n\t\tjs.Browser.document.addEventListener(\"DOMContentLoaded\", function(_) {\n\t\t\tdeferred.resolve(nil);\n\t\t}, false);\n\t\treturn deferred;\n\t}\n}\n\nclass Query {\n\tstatic var doc : Element = untyped __js__('document');\n\tpublic static function first(selector : String, ?ctx : js.html.Element) {\n\t\treturn (ctx != null ? ctx : doc).querySelector(selector);\n\t}\n\n\tpublic static function list(selector : String, ?ctx : js.html.Element) {\n\t\treturn (ctx != null ? ctx : doc).querySelectorAll(selector);\n\t}\n\n\tpublic inline static function all(selector : String, ?ctx : js.html.Element) : Array<Element> {\n\t\treturn H.toArray(list(selector, ctx));\n\t}\n}\n\nprivate class H {\n\tpublic inline static function toArray(list : js.html.NodeList) : Array<Element>\n\t\treturn untyped __js__('Array.prototype.slice.call')(list, 0);\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule( m : String );\n\tFilePos( s : Null<StackItem>, file : String, line : Int );\n\tMethod( classname : String, method : String );\n\tLocalFunction( v : Int );\n}\n\n/**\n\tGet informations about the call stack.\n**/\nclass CallStack {\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\tvar a = makeStack(untyped __dollar__callstack());\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif flash9\n\t\t\tvar a = makeStack( new flash.errors.Error().getStackTrace() );\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\treturn makeStack(\"$s\");\n\t\t#elseif php\n\t\t\treturn makeStack(\"%s\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_call_stack(true);\n\t\t\treturn makeStack(s);\n\t\t#elseif js\n\t\t\t// https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\t\tvar oldValue = (untyped Error).prepareStackTrace;\n\t\t\t(untyped Error).prepareStackTrace = function (error, callsites :Array<Dynamic>) {\n\t\t\t\tvar stack = [];\n\t\t\t\tfor (site in callsites) {\n\t\t\t\t\tvar method = null;\n\t\t\t\t\tvar fullName :String = site.getFunctionName();\n\t\t\t\t\tif (fullName != null) {\n\t\t\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tvar className = fullName.substr(0, idx);\n\t\t\t\t\t\t\tvar methodName = fullName.substr(idx+1);\n\t\t\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(FilePos(method, site.getFileName(), site.getLineNumber()));\n\t\t\t\t}\n\t\t\t\treturn stack;\n\t\t\t}\n\t\t\tvar a = makeStack(untyped __new__(\"Error\").stack);\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\t(untyped Error).prepareStackTrace = oldValue;\n\t\t\treturn a;\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.lang.Thread.currentThread().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(1, true));\n\t\t#elseif python\n\t\t\tvar stack = [];\n\t\t\tvar infos = python.lib.Traceback.extract_stack();\n\t\t\tinfos.pop();\n\t\t\tinfos.reverse();\n\t\t\tfor (elem in infos)\n\t\t\t\tstack.push(FilePos(null, elem._1, elem._2));\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t**/\n\t#if cpp @:noStack #end /* Do not mess up the exception stack */\n\tpublic static function exceptionStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\treturn makeStack(untyped __dollar__excstack());\n\t\t#elseif as3\n\t\t\treturn new Array();\n\t\t#elseif flash9\n\t\t\tvar err : flash.errors.Error = untyped flash.Boot.lastError;\n\t\t\tif( err == null ) return new Array();\n\t\t\tvar a = makeStack( err.getStackTrace() );\n\t\t\tvar c = callStack();\n\t\t\tvar i = c.length - 1;\n\t\t\twhile( i > 0 ) {\n\t\t\t\tif( Std.string(a[a.length-1]) == Std.string(c[i]) )\n\t\t\t\t\ta.pop();\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\treturn makeStack(\"$e\");\n\t\t#elseif php\n\t\t\treturn makeStack(\"%e\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_exception_stack();\n\t\t\treturn makeStack(s);\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.internal.Exceptions.currentException().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// stack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(cs.internal.Exceptions.exception, true));\n\t\t#elseif python\n\t\t\tvar stack = [];\n\t\t\tvar exc = python.lib.Sys.exc_info();\n\t\t\tif (exc._3 != null)\n\t\t\t{\n\t\t\t\tvar infos = python.lib.Traceback.extract_tb(exc._3);\n\t\t\t\tinfos.reverse();\n\t\t\t\tfor (elem in infos)\n\t\t\t\t\tstack.push(FilePos(null, elem._1, elem._2));\n\t\t\t}\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tpublic static function toString( stack : Array<StackItem> ) {\n\t\tvar b = new StringBuf();\n\t\tfor( s in stack ) {\n\t\t\tb.add(\"\\nCalled from \");\n\t\t\titemToString(b,s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tprivate static function itemToString( b : StringBuf, s ) {\n\t\tswitch( s ) {\n\t\tcase CFunction:\n\t\t\tb.add(\"a C function\");\n\t\tcase Module(m):\n\t\t\tb.add(\"module \");\n\t\t\tb.add(m);\n\t\tcase FilePos(s,file,line):\n\t\t\tif( s != null ) {\n\t\t\t\titemToString(b,s);\n\t\t\t\tb.add(\" (\");\n\t\t\t}\n\t\t\tb.add(file);\n\t\t\tb.add(\" line \");\n\t\t\tb.add(line);\n\t\t\tif( s != null ) b.add(\")\");\n\t\tcase Method(cname,meth):\n\t\t\tb.add(cname);\n\t\t\tb.add(\".\");\n\t\t\tb.add(meth);\n\t\tcase LocalFunction(n):\n\t\t\tb.add(\"local function #\");\n\t\t\tb.add(n);\n\t\t}\n\t}\n\n\t#if cpp @:noStack #end /* Do not mess up the exception stack */\n\tprivate static function makeStack(s #if cs : cs.system.diagnostics.StackTrace #end) {\n\t\t#if neko\n\t\t\tvar a = new Array();\n\t\t\tvar l = untyped __dollar__asize(s);\n\t\t\tvar i = 0;\n\t\t\twhile( i < l ) {\n\t\t\t\tvar x = s[i++];\n\t\t\t\tif( x == null )\n\t\t\t\t\ta.unshift(CFunction);\n\t\t\t\telse if( untyped __dollar__typeof(x) == __dollar__tstring )\n\t\t\t\t\ta.unshift(Module(new String(x)));\n\t\t\t\telse\n\t\t\t\t\ta.unshift(FilePos(null,new String(untyped x[0]),untyped x[1]));\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash9\n\t\t\tvar a = new Array();\n\t\t\tvar r = ~/at ([^\\/]+?)\\$?(\\/[^\\(]+)?\\(\\)(\\[(.*?):([0-9]+)\\])?/;\n\t\t\tvar rlambda = ~/^MethodInfo-([0-9]+)$/g;\n\t\t\twhile( r.match(s) ) {\n\t\t\t\tvar cl = r.matched(1).split(\"::\").join(\".\");\n\t\t\t\tvar meth = r.matched(2);\n\t\t\t\tvar item;\n\t\t\t\tif( meth == null ) {\n\t\t\t\t\tif( rlambda.match(cl) )\n\t\t\t\t\t\titem = LocalFunction(Std.parseInt(rlambda.matched(1)));\n\t\t\t\t\telse\n\t\t\t\t\t\titem = Method(cl,\"new\");\n\t\t\t\t} else\n\t\t\t\t\titem = Method(cl,meth.substr(1));\n\t\t\t\tif( r.matched(3) != null )\n\t\t\t\t\titem = FilePos( item, r.matched(4), Std.parseInt(r.matched(5)) );\n\t\t\t\ta.push(item);\n\t\t\t\ts = r.matchedRight();\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\tvar a : Array<String> = untyped __eval__(s);\n\t\t\tvar m = new Array();\n\t\t\tfor( i in 0...a.length - if(s == \"$s\") 2 else 0 ) {\n\t\t\t\tvar d = a[i].split(\"::\");\n\t\t\t\tm.unshift(Method(d[0],d[1]));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif php\n\t\t\tif (!untyped __call__(\"isset\", __var__(\"GLOBALS\", s)))\n\t\t\t\treturn [];\n\t\t\tvar a : Array<String> = untyped __var__(\"GLOBALS\", s);\n\t\t\tvar m = [];\n\t\t\tfor( i in 0...a.length - ((s == \"%s\") ? 2 : 0)) {\n\t\t\t\tvar d = a[i].split(\"::\");\n\t\t\t\tm.unshift(Method(d[0],d[1]));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif cpp\n\t\t\tvar stack : Array<String> = s;\n\t\t\tvar m = new Array<StackItem>();\n\t\t\tfor(func in stack) {\n\t\t\t\tvar words = func.split(\"::\");\n\t\t\t\tif (words.length==0)\n\t\t\t\t\tm.unshift(CFunction)\n\t\t\t\telse if (words.length==2)\n\t\t\t\t\tm.unshift(Method(words[0],words[1]));\n\t\t\t\telse if (words.length==4)\n\t\t\t\t\tm.unshift(FilePos( Method(words[0],words[1]),words[2],Std.parseInt(words[3])));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif js\n\t\t\tif ((untyped __js__(\"typeof\"))(s) == \"string\") {\n\t\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\t\tvar stack : Array<String> = s.split(\"\\n\");\n\t\t\t\tvar m = [];\n\t\t\t\tfor( line in stack ) {\n\t\t\t\t\tm.push(Module(line)); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t\treturn m;\n\t\t\t} else {\n\t\t\t\treturn cast s;\n\t\t\t}\n\t\t#elseif cs\n\t\t\tvar stack = [];\n\t\t\tfor (i in 0...s.FrameCount)\n\t\t\t{\n\t\t\t\tvar frame = s.GetFrame(i);\n\t\t\t\tvar m = frame.GetMethod();\n\n\t\t\t\tvar method = StackItem.Method(m.ReflectedType.ToString(), m.Name);\n\n\t\t\t\tvar fileName = frame.GetFileName();\n\t\t\t\tvar lineNumber = frame.GetFileLineNumber();\n\n\t\t\t\tif (fileName != null || lineNumber >= 0)\n\t\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t\telse\n\t\t\t\t\tstack.push(method);\n\t\t\t}\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tLog primarily provides the trace() method, which is invoked upon a call to\n\ttrace() in haxe code.\n**/\nclass Log {\n\n\t/**\n\t\tOutputs `v` in a platform-dependent way.\n\n\t\tThe second parameter `infos` is injected by the compiler and contains\n\t\tinformation about the position where the trace() call was made.\n\n\t\tThis method can be rebound to a custom function:\n\t\t\tvar oldTrace = haxe.Log.trace; // store old function\n\t\t\thaxe.Log.trace = function(v,infos) { // handle trace }\n\t\t\t...\n\t\t\thaxe.Log.trace = oldTrace;\n\n\t\tIf it is bound to null, subsequent calls to trace() will cause an\n\t\texception.\n\t**/\n\tpublic static dynamic function trace( v : Dynamic, ?infos : PosInfos ) : Void {\n\t\t#if flash\n\t\t\t#if (fdb || native_trace)\n\t\t\t\tvar pstr = infos == null ? \"(null)\" : infos.fileName + \":\" + infos.lineNumber;\n\t\t\t\tvar str = flash.Boot.__string_rec(v, \"\");\n\t\t\t\tif( infos != null && infos.customParams != null ) for( v in infos.customParams ) str += \",\" + flash.Boot.__string_rec(v, \"\");\n\t\t\t\tuntyped #if flash9 __global__[\"trace\"] #else __trace__ #end(pstr+\": \"+str);\n\t\t\t#else\n\t\t\t\tuntyped flash.Boot.__trace(v,infos);\n\t\t\t#end\n\t\t#elseif neko\n\t\t\tuntyped {\n\t\t\t\t$print(infos.fileName + \":\" + infos.lineNumber + \": \", v);\n\t\t\t\tif( infos.customParams != null ) for( v in infos.customParams ) $print(\",\", v);\n\t\t\t\t$print(\"\\n\");\n\t\t\t}\n\t\t#elseif js\n\t\t\tuntyped js.Boot.__trace(v,infos);\n\t\t#elseif php\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __call__('_hx_trace', v + extra, infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __call__('_hx_trace', v, infos);\n\t\t#elseif cpp\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __trace(v + extra,infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __trace(v,infos);\n\t\t#elseif (cs || java)\n\t\t\tvar str:String = null;\n\t\t\tif (infos != null) {\n\t\t\t\tstr = infos.fileName + \":\" + infos.lineNumber + \": \" + v;\n\t\t\t\tif (infos.customParams != null)\n\t\t\t\t{\n\t\t\t\t\tstr += \",\" + infos.customParams.join(\",\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = v;\n\t\t\t}\n\t\t\t#if cs\n\t\t\tcs.system.Console.WriteLine(str);\n\t\t\t#elseif java\n\t\t\tuntyped __java__(\"java.lang.System.out.println(str)\");\n\t\t\t#end\n\t\t#elseif (python)\n\t\t\tvar str:String = null;\n\t\t\tif (infos != null) {\n\t\t\t\tstr = infos.fileName + \":\" + Std.string(infos.lineNumber) + \": \" + v;\n\t\t\t\tif (infos.customParams != null) {\n\t\t\t\t\tstr += \",\" + infos.customParams.join(\",\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = v;\n\t\t\t}\n\t\t\tpython.Lib.println(str);\n\t\t#end\n\t}\n\n\t#if (flash || js)\n\t/**\n\t\tClears the trace output.\n\t**/\n\tpublic static dynamic function clear() : Void {\n\t\t#if flash\n\t\tuntyped flash.Boot.__clear_trace();\n\t\t#elseif js\n\t\tuntyped js.Boot.__clear_trace();\n\t\t#end\n\t}\n\t#end\n\n\t#if flash\n\t/**\n\t\tSets the color of the trace output to `rgb`.\n\t**/\n\tpublic static dynamic function setColor( rgb : Int ) {\n\t\tuntyped flash.Boot.__set_trace_color(rgb);\n\t}\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\n@:coreApi class IntMap<T> implements Map.IMap<Int,T> {\n\n\tprivate var h : Dynamic;\n\n\tpublic function new() : Void {\n\t\th = {};\n\t}\n\n\tpublic function set( key : Int, value : T ) : Void {\n\t\tuntyped h[key] = value;\n\t}\n\n\tpublic function get( key : Int ) : Null<T> {\n\t\treturn untyped h[key];\n\t}\n\n\tpublic function exists( key : Int ) : Bool {\n\t\treturn untyped h.hasOwnProperty(key);\n\t}\n\n\tpublic function remove( key : Int ) : Bool {\n\t\tif( untyped !h.hasOwnProperty(key) ) return false;\n\t\tuntyped  __js__(\"delete\")(h[key]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<Int> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(key|0);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<T> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[i]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(i);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of h software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and h permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n@:coreApi\nclass ObjectMap<K:{ }, V> implements Map.IMap<K,V> {\n\n\tstatic var count = 0;\n\n\tstatic inline function assignId(obj: { } ):Int {\n\t\treturn untyped obj.__id__ = ++count;\n\t}\n\n\tstatic inline function getId(obj: { } ):Int {\n\t\treturn untyped obj.__id__;\n\t}\n\n\tvar h : { };\n\n\tpublic function new() : Void {\n\t\th = { };\n\t\tuntyped h.__keys__ = { };\n\t}\n\n\tpublic function set(key:K, value:V):Void untyped {\n\t\tvar id : Int = untyped key.__id__ || assignId(key);\n\t\th[id] = value;\n\t\th.__keys__[id] = key;\n\t}\n\n\tpublic inline function get(key:K):Null<V> {\n\t\treturn untyped h[getId(key)];\n\t}\n\n\tpublic inline function exists(key:K):Bool {\n\t\treturn untyped h.__keys__[getId(key)] != null;\n\t}\n\n\tpublic function remove( key : K ) : Bool {\n\t\tvar id = getId(key);\n\t\tif ( untyped h.__keys__[id] == null ) return false;\n\t\tuntyped  __js__(\"delete\")(h[id]);\n\t\tuntyped  __js__(\"delete\")(h.__keys__[id]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<K> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h.__keys__ ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(h.__keys__[key]);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<V> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[getId(i)]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(Std.string(i));\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\n@:coreApi class StringMap<T> implements Map.IMap<String,T> {\n\n\tprivate var h : Dynamic;\n\n\tpublic function new() : Void {\n\t\th = {};\n\t}\n\n\tpublic function set( key : String, value : T ) : Void {\n\t\tuntyped h[\"$\"+key] = value;\n\t}\n\n\tpublic function get( key : String ) : Null<T> {\n\t\treturn untyped h[\"$\"+key];\n\t}\n\n\tpublic function exists( key : String ) : Bool {\n\t\treturn untyped h.hasOwnProperty(\"$\"+key);\n\t}\n\n\tpublic function remove( key : String ) : Bool {\n\t\tkey = \"$\"+key;\n\t\tif( untyped !h.hasOwnProperty(key) ) return false;\n\t\tuntyped __js__(\"delete\")(h[key]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<String> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(key.substr(1));\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<T> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[\"$\"+i]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(i);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n/**\n\tThis exception is raised when reading while data is no longer available in the [Input].\n**/\nclass Eof {\n\tpublic function new() {\n\t}\n\t@:keep function toString() {\n\t\treturn \"Eof\";\n\t}\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic inline function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse\n\t\t\treturn untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t}\n\n\t@:ifFeature(\"may_print_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n}\n","/**\n  This is a primitive asynchronous class, used as a base class for Promise and\n  Signal.\n **/\n\n\npackage promhx.base;\n\n#if macro\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nimport haxe.macro.Context;\n#end\nimport promhx.base.EventLoop;\nimport promhx.Thenable;\n\ntypedef AsyncLink<T> = {\n    async : AsyncBase<Dynamic>,\n    linkf : T->Void\n}\n\n\nclass AsyncBase<T>{\n#if debug\n    // add ids to the async instances so they are easier to track\n    static var id_ctr  = 0;\n    var id          : Int;\n#end\n    var _val        : T;\n    var _resolved   : Bool;\n    var _fulfilled  : Bool;\n    var _pending    : Bool;\n    var _update     : Array<AsyncLink<T>>;\n    var _error      : Array<Dynamic->Void>;\n    var _errorMap   : Dynamic->T;\n\n    /**\n      Constructor argument can take optional function argument, which adds\n      a callback to the error handler chain.\n     **/\n    public function new(?errorf : Dynamic->Void) {\n#if debug id = id_ctr +=1; #end\n\n        _resolved   = false;\n        _pending = false;\n        _fulfilled  = false;\n        _update     = [];\n        _error      = [];\n\n        if (errorf != null) _error.push(errorf);\n    }\n\n    /**\n      Catch error, effectively halting the current update chain.\n      This will prevent downstream async objects from receiving \n      the error message.\n     **/\n    public function catchError(f : Dynamic->Void) : AsyncBase<T> {\n        _error.push(f);\n        return this;\n    }\n\n    /**\n      Map errors back to the expected type, and continue as normal.\n     **/\n    public function errorThen( f : Dynamic -> T){\n        _errorMap = f;\n        return this;\n    }\n\n    /**\n      Utility function to determine if a Promise value has been resolved.\n     **/\n    public inline function isResolved() : Bool\n        return _resolved;\n\n\n    /**\n      Utility function to determine if a Promise value has been rejected.\n     **/\n    public inline function isFulfilled(): Bool\n        return _fulfilled;\n\n    /**\n      Utility function to determine if a Promise value is pending operations\n      on the next loop.\n     **/\n    public inline function isPending() : Bool\n        return _pending;\n\n    /**\n      Resolves the given value for processing on any waiting functions.\n     **/\n    public function resolve(val : T) : Void  _resolve(val);\n\n    /**\n      Resolves the given value for processing on any waiting functions.\n     **/\n    function _resolve(val : T, ?cleanup : Void->Void) : Void {\n\n        // this async is pending an update on the next loop, move the\n        // resolve to the loop after that.\n        if (_pending)\n            return EventLoop.enqueue(_resolve.bind(val, cleanup));\n\n        // point of no return, this async has now been resolved at least once.\n        _resolved = true;\n\n        // we are now in the act of fulfilling the async... which\n        // involves waiting for the next enqueued loop\n        _pending = true;\n\n        // the loop handler, which may not even be used\n        EventLoop.enqueue(function(){\n            _val = val; // save the value\n            for (up in _update){\n                try up.linkf(val)\n                catch (e:Dynamic) up.async.handleError(e);\n            }\n            _fulfilled = true; // we're in a fulfilled state\n            _pending = false; // we're done fulfilling for this resolve\n            if (cleanup != null) cleanup(); // we can cleanup if necessary\n        });\n    }\n\n    /**\n      Handle errors\n     **/\n    function handleError(error : Dynamic) : Void {\n        var update_errors = function(e:Dynamic){\n            if (_error.length > 0) for (ef in _error) ef(e);\n            else if (_update.length > 0) for (up in _update) up.async.handleError(e);\n            else {\n#if (js && nodejs)\n                // Node sometimes doesn't produce helpful stack information on thrown errors.\n                trace('Call Stack: ' + haxe.CallStack.toString(haxe.CallStack.callStack()));\n#end\n                throw e;\n            }\n        }\n        EventLoop.enqueue(function(){\n            if (_errorMap != null){\n                try this.resolve(_errorMap(error))\n                catch (e : Dynamic) update_errors(e);\n            } else {\n                update_errors(error);\n            }\n        });\n    }\n\n    /**\n      This function returns a new AsyncBase.  When this instance resolves,\n      it will resolve the new AsyncBase with the function callback argument.\n     **/\n    public function then<A>(f : T->A) : AsyncBase<A> {\n        var ret = new AsyncBase<A>();\n        link(this, ret, f);\n        return ret;\n    }\n\n    /**\n      Remove an Async that is updated from this Async.  This action is\n      performed on the next event loop.\n     **/\n    public function unlink( to : AsyncBase<Dynamic>) {\n        EventLoop.enqueue(function(){\n            _update =  _update.filter(function(x) return x.async != to);\n        });\n    }\n\n    /**\n      Determine if an Async is updated from this Async.\n     **/\n    public function isLinked( to : AsyncBase<Dynamic>) : Bool {\n        var updated = false;\n        for (u in _update) if (u.async == to) return true;\n        return updated;\n    }\n\n\n    /**\n      This is the base \"link\" method for wiring up the \"current\" async to\n      the \"next\" one via the transform defined by the f argument.\n     **/\n    inline public static function link<A,B>\n        (current : AsyncBase<A>, next: AsyncBase<B>, f : A->B) : Void\n    {\n        // the function wrapper for the callback, which will resolve the return\n        // if current is not resolved, or will resolve next loop, push to\n        // update queues.\n        current._update.push({\n            async : next,\n            linkf : function(x){\n                next.resolve(f(x));\n            }\n        });\n        immediateLinkUpdate(current, next, f);\n    }\n\n    static function immediateLinkUpdate<A,B>\n        (current : AsyncBase<A>, next : AsyncBase<B>, f : A->B) : Void\n    {\n        if (current.isResolved() && !current.isPending()){\n            // we can go ahead and resolve this.\n            try next.resolve(f(current._val))\n            catch (e:Dynamic) next.handleError(e);\n        }\n\n    }\n\n    inline public static function linkAll<T>\n        (all : Iterable<AsyncBase<T>>, next: AsyncBase<Array<T>>) : Void\n    {\n        // a helper callback function.  This will be called for each Stream in\n        // the iterable argument.  The \"arr\" argument will be all of the Streams\n        // *except* the one currently resolving.  If there's only one Stream\n        // in the iterable, it will always resolve.\n        var cthen = function(arr:Array<AsyncBase<T>>, current:AsyncBase<T>,  v){\n            if (arr.length == 0 || AsyncBase.allFulfilled(arr)){\n                var vals = [for (a in all) a == current ? v : a._val];\n                next.resolve(vals);\n            }\n            return null;\n        };\n        for (a in all){\n            a._update.push({\n                async : next,\n                linkf: cthen.bind([for (a2 in all) if (a2 != a) a2], a, _)\n            });\n        }\n\n        if (AsyncBase.allFulfilled(all)) {\n            next.resolve([for (a in all) a._val]);\n        }\n    }\n\n    /**\n      Similar to the link function, except the [f] function must return an\n      AsyncBase instance.\n     **/\n    inline static public function pipeLink<A,B>\n        ( current : AsyncBase<A>, ret : AsyncBase<B>, f : A->AsyncBase<B> ) : Void\n    {\n        var linked = false;\n        var linkf = function(x){ // updates go to pipe function.\n                if (!linked){ // but only once\n                    linked = true; // the piped async doesn't actually respond to updates from current\n                    var pipe_ret = f(x); // it just needs to be created\n                    pipe_ret._update.push({  // and to be linked to ret\n                        async : ret, // errors go to ret\n                        linkf : ret.resolve // updates go directly to ret\n                    });\n                    immediateLinkUpdate(pipe_ret, ret, function(x) return x );\n                }\n            }\n\n        current._update.push({\n            async : ret, // errors go to ret\n            linkf : linkf\n        });\n\n        if (current.isResolved() && !current.isPending()){\n            try linkf(current._val)\n            catch (e:Dynamic) ret.handleError(e);\n        }\n    }\n\n    /**\n      Utility function to determine if all Promise values are set.\n     **/\n    public static function allResolved\n        (as : Iterable<AsyncBase<Dynamic>>) : Bool\n    {\n        for (a in as) {\n            if (!a.isResolved()) return false;\n        }\n        return true;\n    }\n\n    /**\n      Utility function to determine if all Promise values are resolved and\n      are currently fulfilled (not in the process of fulfilling).\n     **/\n    static function allFulfilled\n        (as : Iterable<AsyncBase<Dynamic>>) : Bool\n    {\n        for (a in as) {\n            if (!a.isFulfilled()) return false;\n        }\n        return true;\n    }\n\n}\n","package promhx;\n\n#if macro\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nimport haxe.macro.Context;\n#end\nimport promhx.base.EventLoop;\nimport promhx.base.AsyncBase;\nimport promhx.error.PromiseError;\n\n@:expose\nclass Promise<T> extends AsyncBase<T>{\n    var _rejected   : Bool;\n    public function new(?errorf : Dynamic->Dynamic){\n        super(errorf);\n        _rejected = false;\n    }\n\n    /**\n      Macro method that binds the promise arguments to a single function\n      callback that is triggered when all promises are resolved.\n      Note: You may call this function on as many promise arguments as you\n      like.\n     **/\n    macro public static function when<T>( args : Array<ExprOf<Promise<Dynamic>>>) : Expr {\n\n        // a default position\n        var pos = Context.currentPos();\n\n        //the macro arguments translated to an array expression.\n        var eargs = {expr:EArrayDecl(args), pos:pos};\n\n        // An array of the resolved promise values\n        var epargs = [for (a in args) { expr: EField(a, \"_val\"), pos: pos}];\n\n        // the returned function that actually does the runtime work.\n        return macro {\n            // a function that accepts a variable argument function\n            var varargf = function(f){\n                // we wait on all of the promises with the iterable-based \"whenAll\"\n                // this will resolve an array, so we use pipe to ignore it, and set\n                // up a new promise for return.\n                // this new promise resolves via a macro-defined function expression\n                // on \"f\" that provides arity and types for the resolved promise values.\n                var ret = new Promise();\n                var arr : Array<Promise<Dynamic>> = $eargs;\n                var p = Promise.whenAll(arr);\n                p._update.push({\n                    async : ret,\n                    linkf : function(x) ret.resolve(f($a{epargs}))\n                });\n                return ret;\n            };\n\n            // return an anonymous object with the function definition for \"then\"\n            { then : varargf };\n        }\n    }\n\n    /**\n      Utility function to determine if a Promise value has been rejected.\n     **/\n    public inline function isRejected(): Bool {\n        return _rejected;\n    }\n\n    /**\n      Rejects the promise, throwing an error.\n     **/\n    public function reject(e : Dynamic): Void {\n        this._rejected = true;\n        handleError(e);\n    }\n\n    /**\n      Transforms an iterable of promises into a single promise which resolves\n      to an array of values.\n     **/\n    public static function whenAll<T>(itb : Iterable<Promise<T>>) : Promise<Array<T>> {\n        var ret : Promise<Array<T>> = new Promise();\n        AsyncBase.linkAll(itb, ret);\n        return ret;\n    }\n\n    /**\n      Resolves the given value for processing on any waiting functions.\n     **/\n    override public function resolve(val : T): Void {\n        if (_resolved) {\n            var msg = \"Promise has already been resolved\";\n            throw(AlreadyResolved(msg));\n        }\n        _resolve(val);\n    }\n\n    /**\n      add a wait function directly to the Promise instance.\n     **/\n    override public function then<A>(f : T->A): Promise<A> {\n        var ret  = new Promise<A>();\n        AsyncBase.link(this, ret, f);\n        return ret;\n    }\n\n    override public function unlink( to : AsyncBase<Dynamic>) {\n        EventLoop.enqueue(function(){\n            if (!isFulfilled()) {\n                var msg = \"Downstream Promise is not fullfilled\";\n                handleError(DownstreamNotFullfilled(msg));\n            }\n            else{\n                _update =  _update.filter(function(x) return x.async != to);\n            }\n        });\n    }\n\n    public function pipe<A>(f : T->Promise<A>) : Promise<A> {\n        var ret = new Promise<A>();\n        AsyncBase.pipeLink(this, ret, f);\n        return ret;\n    }\n\n\n    /**\n      Converts any value to a resolved Promise\n     **/\n    public static function promise<T>(_val : T, ?errorf : Dynamic->Dynamic): Promise<T> {\n        var ret = new Promise<T>(errorf);\n        ret.resolve(_val);\n        return ret;\n    }\n}\n\n","package promhx.base;\n\nclass EventLoop {\n    static var queue : List<Void->Void> = new List();\n    // public static var nextLoop(default, set) : (Void->Void)-> Void;\n    public static var nextLoop : (Void->Void)-> Void;\n\n#if (js && !nodejs && !noEmbedJs && !noEmbedSetImmediate)\n    static function __init__() untyped {\n#if !nodejs\n        // we need to use global as an alternate since setImmediate expects this == window\n        var global = window;\n#end\n        haxe.macro.Compiler.includeFile(\"lib/setImmediate/setImmediate.js\");\n    }\n#end\n\n    public static inline function enqueue(eqf:Void->Void)  {\n        queue.add(eqf);\n        continueOnNextLoop();\n    }\n    static function set_nextLoop(f : (Void->Void)->Void) : (Void->Void)->Void{\n        if (nextLoop != null) throw \"nextLoop has already been set\";\n        else nextLoop = f;\n        return nextLoop;\n    }\n\n    /**\n      Retrieve the current length of the queue.\n     **/\n    public static function queueLength() {\n        return queue.length;\n    }\n\n    /**\n      Attempt to finish the remaining loops in the queue.  Returns true\n      if all loops are finished.  If [max_iterations] pass, then exit and\n      return false.\n     **/\n    public static function finish(max_iterations = 1000){\n        while (queue.length > 0 && max_iterations-- > 0){\n            queue.pop()();\n        }\n        return queue.length == 0;\n    }\n\n    /**\n      Clear the existing event loop queue.\n     **/\n    public static function clear(){\n        queue = new List();\n    }\n\n    static function continueOnNextLoop(){\n        var f = function(){\n            if (queue.length > 0) {\n                queue.pop()();\n                continueOnNextLoop();\n            }\n        }\n        if (nextLoop != null) nextLoop(f);\n        else {\n\n#if flash\n            haxe.Timer.delay(f,0);\n#elseif (js && (noEmbedJs || noEmbedSetImmediate) && !nodejs)\n            // fallback to setTimeout\n            untyped __js__(\"(typeof setImmediate === 'function' ? setImmediate : setTimeout)\")(f);\n#elseif js\n            // use polyfill or native node\n            untyped __js__(\"setImmediate\")(f);\n#else\n            f();\n#end\n        }\n    }\n}\n","package steamer;\n\nimport thx.Error;\nimport steamer.Pulse;\n\ntypedef Consumer<T> = {\n\tfunction onPulse(pulse : Pulse<T>) : Void;\n}\n\nclass Consumers {\n\tpublic static function toConsumer<T>(handler : T -> Void) {\n\t\treturn {\n\t\t\tonPulse : function(pulse) {\n\t\t\t\tswitch pulse {\n\t\t\t\t\tcase Emit(v): handler(v);\n\t\t\t\t\tcase _:\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n}","package steamer;\n\nimport steamer.producers.Interval;\nimport steamer.Pulse;\nimport thx.Error;\nimport thx.Timer;\nimport thx.Tuple;\n\nclass Producer<T> {\n\tvar handler : ProducerHandler<T>;\n\tvar endOnError : Bool;\n\tpublic function new(handler : ProducerHandler<T>, endOnError = true) {\n\t\tthis.handler = handler;\n\t\tthis.endOnError = endOnError;\n\t}\n\n\tpublic function feed(consumer : Consumer<T>) : Void {\n\t\tvar ended = false;\n\t\tfunction sendPulse(v : Pulse<T>) {\n\t\t\tswitch(v) {\n\t\t\t\tcase _ if(ended):\n\t\t\t\t\tthrow new Error(\"Feed already reached end but still receiving pulses: ${v}\");\n\t\t\t\tcase Fail(_) if(endOnError):\n\t\t\t\t\tTimer.setImmediate(consumer.onPulse.bind(v));\n\t\t\t\t\tTimer.setImmediate(consumer.onPulse.bind(End));\n\t\t\t\tcase End:\n\t\t\t\t\tended = true;\n\t\t\t\t\tTimer.setImmediate(consumer.onPulse.bind(End));\n\t\t\t\tcase _:\n\t\t\t\t\tTimer.setImmediate(consumer.onPulse.bind(v));\n\t\t\t}\n\t\t}\n\t\thandler(sendPulse);\n\t}\n\n\tpublic function map<TOut>(transform : T -> TOut) : Producer<TOut> {\n\t\treturn mapAsync(function(v, t) t(transform(v)));\n\t}\n\n\tpublic function mapAsync<TOut>(transform : T -> (TOut -> Void) -> Void) : Producer<TOut> {\n\t\treturn new Producer(function(forward : Pulse<TOut> -> Void) {\n\t\t\tthis.feed(Bus.passOn(\n\t\t\t\tfunction(value : T) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfunction t(v : TOut) forward(Emit(v));\n\t\t\t\t\t\ttransform(value, t);\n\t\t\t\t\t} catch(e : Error) {\n\t\t\t\t\t\tforward(Fail(e));\n\t\t\t\t\t} catch(e : Dynamic) {\n\t\t\t\t\t\tforward(Fail(new Error(Std.string(e))));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic function log(prefix : String, ?posInfo : haxe.PosInfos) {\n\t\tprefix = prefix == null ? '': '${prefix}: ';\n\t\treturn map(function(v) {\n\t\t\thaxe.Log.trace(v, posInfo);\n\t\t\treturn v;\n\t\t});\n\t}\n\n\tpublic function filter(f : T -> Bool) : Producer<T> {\n\t\treturn filterAsync(function(v, t) t(f(v)));\n\t}\n\n\tpublic function filterAsync(f : T -> (Bool -> Void) -> Void) : Producer<T> {\n\t\treturn new Producer(function(forward : Pulse<T> -> Void) {\n\t\t\tthis.feed(Bus.passOn(\n\t\t\t\tfunction(value : T) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfunction t(v : Bool) if(v) forward(Emit(value));\n\t\t\t\t\t\tf(value, t);\n\t\t\t\t\t} catch(e : Error) {\n\t\t\t\t\t\tforward(Fail(e));\n\t\t\t\t\t} catch(e : Dynamic) {\n\t\t\t\t\t\tforward(Fail(new Error(Std.string(e))));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic function merge(other : Producer<T>) : Producer<T> {\n\t\tvar ended  = false;\n\n\t\treturn new Producer(function(forward : Pulse<T> -> Void) {\n\t\t\tfunction emit(v) {\n\t\t\t\tforward(Emit(v));\n\t\t\t}\n\t\t\tfunction end() {\n\t\t\t\tif(ended)\n\t\t\t\t\tforward(End);\n\t\t\t\telse\n\t\t\t\t\tended = true;\n\t\t\t}\n\t\t\tfunction fail(error) {\n\t\t\t\tforward(Fail(error));\n\t\t\t}\n\n\t\t\tthis.feed(new Bus(emit, end, fail));\n\t\t\tother.feed(new Bus(emit, end, fail));\n\t\t}, endOnError);\n\t}\n\n\tpublic function concat(other : Producer<T>) : Producer<T> {\n\t\treturn new Producer(function(forward : Pulse<T> -> Void) {\n\t\t\tfunction emit(v) {\n\t\t\t\tforward(Emit(v));\n\t\t\t}\n\t\t\tfunction fail(error) {\n\t\t\t\tforward(Fail(error));\n\t\t\t}\n\n\t\t\tthis.feed(new Bus(\n\t\t\t\temit,\n\t\t\t\tfunction() other.feed(Bus.passOn(emit, forward)),\n\t\t\t\tfail\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic function zip<TOther>(other : Producer<TOther>) : Producer<Tuple<T, TOther>> {\n\t\treturn new Producer(function(forward : Pulse<Tuple<T, TOther>> -> Void) {\n\t\t\tvar ended = false,\n\t\t\t\tendA  = false,\n\t\t\t\tendB  = false,\n\t\t\t\tbuffA : Array<T> = [],\n\t\t\t\tbuffB : Array<TOther> = [];\n\n\t\t\tfunction produce() {\n\t\t\t\tif(((buffA.length == 0 && endA) || (buffB.length == 0 && endB)) && !ended) {\n\t\t\t\t\tbuffA = null;\n\t\t\t\t\tbuffB = null;\n\t\t\t\t\tended = true;\n\t\t\t\t\treturn forward(End);\n\t\t\t\t}\n\t\t\t\tif(buffA.length == 0 || buffB.length == 0) return;\n\t\t\t\tforward(Emit({\n\t\t\t\t\tleft  : buffA.shift(),\n\t\t\t\t\tright : buffB.shift()\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tthis.feed(new Bus(\n\t\t\t\tfunction(value : T) {\n\t\t\t\t\tif(ended) return;\n\t\t\t\t\tbuffA.push(value);\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\tendA = true;\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction(error) {\n\t\t\t\t\tforward(Fail(error));\n\t\t\t\t}\n\t\t\t));\n\n\t\t\tother.feed(new Bus(\n\t\t\t\tfunction(value : TOther) {\n\t\t\t\t\tif(ended) return;\n\t\t\t\t\tbuffB.push(value);\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\tendB = true;\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction(error) {\n\t\t\t\t\tforward(Fail(error));\n\t\t\t\t}\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic function blend<TOther, TOut>(other : Producer<TOther>, f : T -> TOther -> TOut) : Producer<TOut> {\n\t\treturn this.zip(other).map(function(tuple) {\n\t\t\treturn f(tuple.left, tuple.right);\n\t\t});\n\t}\n\n\tpublic function pair<TOther>(other : Producer<TOther>) : Producer<Tuple<T, TOther>> {\n\t\treturn new Producer(function(forward : Pulse<Tuple<T, TOther>> -> Void) {\n\t\t\tvar endA  = false,\n\t\t\t\tendB  = false,\n\t\t\t\tbuffA : T = null,\n\t\t\t\tbuffB : TOther = null;\n\n\t\t\tfunction produce() {\n\t\t\t\tif(endA && endB) {\n\t\t\t\t\tbuffA = null;\n\t\t\t\t\tbuffB = null;\n\t\t\t\t\treturn forward(End);\n\t\t\t\t}\n\t\t\t\tif(buffA == null || buffB == null) return;\n\t\t\t\tforward(Emit({\n\t\t\t\t\tleft  : buffA,\n\t\t\t\t\tright : buffB\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tthis.feed(new Bus(\n\t\t\t\tfunction(value : T) {\n\t\t\t\t\tbuffA = value;\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\tendA = true;\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction(error) {\n\t\t\t\t\tforward(Fail(error));\n\t\t\t\t}\n\t\t\t));\n\n\t\t\tother.feed(new Bus(\n\t\t\t\tfunction(value : TOther) {\n\t\t\t\t\tbuffB = value;\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\tendB = true;\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction(error) {\n\t\t\t\t\tforward(Fail(error));\n\t\t\t\t}\n\t\t\t));\n\n\t\t}, endOnError);\n\t}\n\n\tpublic function distinct() : Producer<T> {\n\t\tvar last : T = null;\n\t\treturn new Producer(function(forward) {\n\t\t\tthis.feed(Bus.passOn(\n\t\t\t\tfunction(v) {\n\t\t\t\t\tif(v == last) return;\n\t\t\t\t\tlast = v;\n\t\t\t\t\tforward(Emit(v));\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic  function debounce(delay : Int) : Producer<T> {\n\t\tvar id : TimerID = null;\n\t\treturn new Producer(function(forward) {\n\t\t\tthis.feed(Bus.passOn(\n\t\t\t\tfunction(v : T) {\n\t\t\t\t\tTimer.clearTimer(id);\n\t\t\t\t\tid = Timer.setTimeout(forward.bind(Emit(v)), delay);\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic function sampleBy<TSampler>(sampler : Producer<TSampler>) : Producer<Tuple<T, TSampler>> {\n\t\tvar latest : T = null;\n\t\treturn new Producer(function(forward) {\n\t\t\tthis.feed(Bus.passOn(\n\t\t\t\tfunction(v) latest = v,\n\t\t\t\tforward\n\t\t\t));\n\t\t\tsampler.feed(Bus.passOn(\n\t\t\t\tfunction(v) {\n\t\t\t\t\t// skip if this hasn't produced anything yet or has been cleared\n\t\t\t\t\tif(null == latest) return;\n\t\t\t\t\tforward(Emit({ left : latest, right : v }));\n\t\t\t\t\tlatest = null;\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\t// public function window(length : Int, fillBeforeEmit = false) : Producer<T> // or unique\n\t// public function reduce(acc : TOut, TOut -> T) : Producer<TOut>\n\t// public function debounce(delay : Int) : Producer<T>\n\t// exact pair\n\t// public function zip<TOther>(other : Producer<TOther>) : Producer<Tuple<T, TOther>> // or sync\n\n\tpublic static function left<TLeft, TRight>(producer : Producer<Tuple<TLeft, TRight>>) : Producer<TLeft>\n\t\treturn producer.map(function(v) return v.left);\n\n\tpublic static function right<TLeft, TRight>(producer : Producer<Tuple<TLeft, TRight>>) : Producer<TRight>\n\t\treturn producer.map(function(v) return v.right);\n\n\tpublic static function negate(producer : Producer<Bool>)\n\t\treturn producer.map(function(v) return !v);\n\n\tpublic static function flatMap<T>(producer : Producer<Array<T>>) : Producer<T> {\n\t\treturn new Producer(function(forward : Pulse<T> -> Void) {\n\t\t\tproducer.feed(Bus.passOn(\n\t\t\t\tfunction(arr : Array<T>) arr.map(function(value) forward(Emit(value))),\n\t\t\t\tforward\n\t\t\t));\n\t\t}, producer.endOnError);\n\t}\n\n\tpublic static function ofArray<T>(values : Array<T>) : Producer<T> {\n\t\treturn new Producer(function(forward) {\n\t\t\tvalues.map(function(v) forward(Emit(v)));\n\t\t\tforward(End);\n\t\t});\n\t}\n\n\tpublic static function ofTimedArray<T>(values : Array<T>, delay : Int) : Producer<T> {\n\t\treturn left(ofArray(values).zip(new Interval(delay, values.length)));\n\t}\n\n\tpublic static function delayed<T>(producer : Producer<T>, delay : Int) : Producer<T> {\n\t\treturn new Producer(function(forward) {\n\t\t\tproducer.feed(new Bus(\n\t\t\t\tfunction(v)\n\t\t\t\t\tTimer.setTimeout(function() forward(Emit(v)), delay),\n\t\t\t\tfunction()\n\t\t\t\t\tTimer.setTimeout(function() forward(End), delay),\n\t\t\t\tfunction(error)\n\t\t\t\t\tTimer.setTimeout(function() forward(Fail(error)), delay)\n\t\t\t));\n\t\t}, producer.endOnError);\n\t}\n}\n\nclass Bus<T> {\n\tpublic static function feed<T>(forward : Pulse<T> -> Void) {\n\t\treturn new Bus(\n\t\t\tfunction(v) forward(Emit(v)),\n\t\t\tfunction() forward(End),\n\t\t\tfunction(error) forward(Fail(error))\n\t\t);\n\t}\n\n\tpublic static function passOn<TIn, TOut>(emit : TIn -> Void, forward : Pulse<TOut> -> Void) {\n\t\treturn new Bus(\n\t\t\temit,\n\t\t\tfunction() forward(End),\n\t\t\tfunction(error) forward(Fail(error))\n\t\t);\n\t}\n\n\tvar emit : T -> Void;\n\tvar end : Void -> Void;\n\tvar fail : Error -> Void;\n\tpublic function new(emit : T -> Void, end : Void -> Void, fail : Error -> Void) {\n\t\tthis.emit = emit;\n\t\tthis.end = end;\n\t\tthis.fail = fail;\n\t}\n\n\tpublic function onPulse(pulse : Pulse<T>) {\n\t\tswitch (pulse) {\n\t\t\tcase Emit(value):\n\t\t\t\temit(value);\n\t\t\tcase End:\n\t\t\t\tend();\n\t\t\tcase Fail(error):\n\t\t\t\tfail(error);\n\t\t}\n\t}\n}\n\ntypedef ProducerHandler<T> = (Pulse<T> -> Void) -> Void;","package steamer;\n\nimport steamer.Consumer;\nimport steamer.Producer;\n\nclass MultiProducer<T> extends Producer<T> {\n\tvar producers : Array<Producer<T>>;\n\tvar consumers : Array<Consumer<T>>;\n\tpublic function new(endOnError = true) {\n\t\tproducers = [];\n\t\tconsumers = [];\n\t\tsuper(function(pulse) {}, endOnError);\n\t}\n\n\tpublic function add(producer : Producer<T>) {\n\t\tproducers.push(producer);\n\t\tfor(consumer in consumers)\n\t\t\tproducer.feed(consumer);\n\t}\n\n\tpublic function remove(producer : Producer<T>) {\n\t\tproducers.remove(producer);\n\t}\n\n\toverride function feed(consumer : Consumer<T>) {\n\t\tfor(producer in producers)\n\t\t\tproducer.feed(consumer);\n\t\tconsumers.push(consumer);\n\t}\n}","package steamer;\n\nimport thx.Error;\nimport thx.Nil;\n\nenum Pulse<T> {\n\tEmit(value : T);\n\tEnd;\n\tFail(error : Error);\n}\n\nclass Pulses {\n\tpublic static var nil(default, null) : Pulse<Nil> = Emit(thx.Nil.nil);\n\n\tpublic static function times<T>(n : Int, pulse : Pulse<T>) {\n\t\treturn [for(i in 0...n) pulse].concat([End]);\n\t}\n}","package steamer;\n\nimport thx.Error;\nimport steamer.Pulse;\n\nclass SimpleConsumer<T> {\n\tpublic var onEmit(default, null) : T -> Void;\n\tpublic var onEnd(default, null) : Void -> Void;\n\tpublic var onFail(default, null) : Error -> Void;\n\tpublic function new(?onEmit : T -> Void, ?onEnd : Void -> Void, ?onFail : Error -> Void) {\n\t\tthis.onEmit  = null == onEmit  ? function(_) {} : onEmit;\n\t\tthis.onEnd   = null == onEnd   ? function() {} : onEnd;\n\t\tthis.onFail = null == onFail ? function(error : Error) throw error : onFail;\n\t}\n\n\tpublic function onPulse(pulse : Pulse<T>) {\n\t\tswitch pulse {\n\t\t\tcase Emit(value): onEmit(value);\n\t\t\tcase End: onEnd;\n\t\t\tcase Fail(error): onFail(error);\n\t\t}\n\t}\n}","package steamer;\n\nimport steamer.Consumer;\nimport steamer.Producer;\n\nclass Value<T> extends Producer<T> {\n\tpublic static function string(value = \"\", ?defaultValue)\n\t\treturn new Value(value, defaultValue);\n\n\tpublic static function number(value = 0.0, ?defaultValue)\n\t\treturn new Value(value, defaultValue);\n\n\tpublic static function bool(value = false, ?defaultValue)\n\t\treturn new Value(value, defaultValue);\n\n\t@:isVar public var value(get, set) : T;\n\n\tpublic var defaultValue(default, null) : T;\n\tvar forwards : Array<Pulse<T> -> Void>;\n\n\tpublic function new(initialValue : T, ?defaultValue : T) {\n\t\tforwards = [];\n\t\tsuper(function(forward) {\n\t\t\tthis.forwards.push(forward);\n\t\t}, false);\n\t\tthis.defaultValue = null == defaultValue ? initialValue : defaultValue;\n\t\tthis.value = initialValue;\n\t}\n\n\tfunction forward(pulse : Pulse<T>) {\n\t\tfor(f in forwards)\n\t\t\tf(pulse);\n\t\tswitch pulse {\n\t\t\tcase End: forwards = [];\n\t\t\tcase _:\n\t\t}\n\t}\n\n\tfunction get_value() : T\n\t\treturn value;\n\n\tfunction set_value(v : T) : T {\n\t\tif(v == value)\n\t\t\treturn v;\n\t\tvalue = v;\n\t\tforward(Emit(v));\n\t\treturn v;\n\t}\n\n\toverride function feed(consumer : Consumer<T>) {\n\t\tsuper.feed(consumer);\n\t\tconsumer.onPulse(Emit(value));\n\t}\n\n\tpublic function terminate() {\n\t\tforward(End);\n\t}\n\n\tpublic function onPulse(pulse : Pulse<T>) {\n\t\tswitch pulse {\n\t\t\tcase Emit(v): value = v;\n\t\t\tcase Fail(e): forward(Fail(e));\n\t\t\tcase End:     forward(End);\n\t\t}\n\t}\n\n\tpublic function reset() {\n\t\tthis.value = defaultValue;\n\t}\n\n\tpublic function isDefault() {\n\t\treturn this.value = defaultValue;\n\t}\n}","package steamer.dom;\n\nimport js.html.Element;\nimport js.html.Event;\nimport steamer.Consumer;\nimport steamer.Producer;\nimport steamer.SimpleConsumer;\nimport thx.Error;\nimport thx.Assert;\n\nclass Dom {\n\tpublic static function produceEvent(el : Element, name : String) : { producer : Producer<Event>, cancel : Void -> Void } {\n\t\tvar cancel = null,\n\t\t\tproducer =  new Producer(function(forward) {\n\t\t\t\tvar f = function(e) {\n\t\t\t\t\tforward(Emit(e));\n\t\t\t\t};\n\t\t\t\tel.addEventListener(name, f, false);\n\t\t\t\tcancel = function() {\n\t\t\t\t\tel.removeEventListener(name, f, false);\n\t\t\t\t\tforward(End);\n\t\t\t\t};\n\t\t\t});\n\t\treturn { producer : producer, cancel : cancel };\n\t}\n\n\tpublic static function consumeText(el : Element) : Consumer<String> {\n\t\tvar originalText = el.innerText;\n\t\tfunction consume(text : String)\n\t\t\tel.innerText = text;\n\t\treturn new SimpleConsumer(\n\t\t\tconsume,\n\t\t\tconsume.bind(originalText)\n\t\t);\n\t}\n\n\tpublic static function consumeHtml(el : Element) : Consumer<String> {\n\t\tvar originalHtml = el.innerHTML;\n\t\tfunction consume(html : String)\n\t\t\tel.innerHTML = html;\n\t\treturn new SimpleConsumer(\n\t\t\tconsume,\n\t\t\tconsume.bind(originalHtml)\n\t\t);\n\t}\n\n\tpublic static function consumeAttribute<T>(el : Element, name : String) : Consumer<T> {\n\t\tvar originalValue : T = cast el.getAttribute(name);\n\t\tfunction consume(value : T)\n\t\t\tel.setAttribute(name, cast value);\n\t\treturn new SimpleConsumer(\n\t\t\tconsume,\n\t\t\tnull == originalValue ?\n\t\t\t\tfunction() el.removeAttribute(name) :\n\t\t\t\tconsume.bind(originalValue)\n\t\t);\n\t}\n\n\tpublic static function consumeToggleAttribute<T>(el : Element, name : String) : Consumer<Bool> {\n\t\tvar originalValue = el.hasAttribute(name);\n\t\tfunction consume(v : Bool)\n\t\t\tif(v)\n\t\t\t\tel.setAttribute(name, name);\n\t\t\telse\n\t\t\t\tel.removeAttribute(name);\n\t\treturn new SimpleConsumer(\n\t\t\tconsume,\n\t\t\tconsume.bind(originalValue)\n\t\t);\n\t}\n\n\tpublic static function consumeToggleClass<T>(el : Element, name : String) : Consumer<Bool> {\n\t\tvar originalValue = el.hasAttribute(name);\n\t\tfunction consume(v : Bool)\n\t\t\tif(v)\n\t\t\t\tel.classList.add(name);\n\t\t\telse\n\t\t\t\tel.classList.remove(name);\n\t\treturn new SimpleConsumer(\n\t\t\tconsume,\n\t\t\tconsume.bind(originalValue)\n\t\t);\n\t}\n\n\tpublic static function consumeToggleVisibility<T>(el : Element) : Consumer<Bool> {\n\t\tvar originalDisplay = el.style.display;\n\t\tAssert.isNull(originalDisplay, 'original element.style.display for visibility is NULL');\n\t\tif(originalDisplay == 'none')\n\t\t\toriginalDisplay = '';\n\t\tfunction consume(value : Bool)\n\t\t\tif(value)\n\t\t\t\t\tel.style.display = originalDisplay;\n\t\t\t\telse\n\t\t\t\t\tel.style.display = 'none';\n\t\t\t\t\n\t\treturn new SimpleConsumer(\n\t\t\tconsume,\n\t\t\tconsume.bind(true)\n\t\t);\n\t}\n}","package steamer.producers;\n\nimport steamer.Pulse;\nimport steamer.Consumer;\nimport steamer.Producer;\n\nimport thx.Nil;\nimport thx.Timer;\n\nclass Interval extends Producer<Nil> {\n\tpublic function new(delay : Int, times : Int = 0) {\n\t\tsuper(function(pulse) {\n\t\t\tvar callback = null;\n\t\t\tif(times <= 0){\n\t\t\t\tcallback = function() {\n\t\t\t\t\tTimer.setInterval(function() pulse(Pulses.nil), delay);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcallback = function() {\n\t\t\t\t\tpulse(Pulses.nil);\n\t\t\t\t\tif(0 == --times)\n\t\t\t\t\t\tpulse(End);\n\t\t\t\t\telse\n\t\t\t\t\t\tTimer.setTimeout(callback, delay);\n\t\t\t\t};\n\t\t\t}\n\t\t\tcallback();\n\t\t});\n\t}\n}","package sui.components;\n\nimport dom.Dom;\nimport js.html.Element;\n\nclass Component {\n\tpublic var children(get, null) : Iterable<Component>;\n\tpublic var isAttached(default, null) : Bool = false;\n\tpublic var parent(default, null) : Component;\n\tpublic var properties(default, null) : Properties;\n\tpublic var el(default, null) : Element;\n\tvar list : Array<Component>;\n\n\tpublic function new(options : ComponentOptions) {\n\t\tlist = [];\n\t\tproperties = new Properties(this);\n\t\tif(null == options.template) {\n\t\t\tif(null == options.el)\n\t\t\t\tthrow '$this needs a template';\n\t\t\telse {\n\t\t\t\tel = options.el;\n\t\t\t\tif(null != el.parentElement) {\n\t\t\t\t\tisAttached = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tel = Html.parse(options.template);\n\t\t}\n\t\tif(null != options.classes)\n\t\t\tel.classList.add(options.classes);\n\t\tif(null != options.parent)\n\t\t\toptions.parent.add(this);\n\t\tif(null != options.container)\n\t\t\tappendTo(options.container);\n\t}\n\n\tpublic function appendTo(container : Element) {\n\t\tcontainer.appendChild(el);\n\t\tisAttached = true;\n\t}\n\n\tpublic function detach() {\n\t\tif(!isAttached)\n\t\t\tthrow 'Component is not attached';\n\t\tel.parentElement.removeChild(el);\n\t\tisAttached = false;\n\t}\n\n\tpublic function destroy() {\n\t\tif(null != parent)\n\t\t\tparent.remove(this);\n\t\tif(isAttached)\n\t\t\tdetach();\n\t\tproperties.removeAll();\n\t}\n\n\tpublic function add(child : Component) {\n\t\tif(null != child.parent)\n\t\t\tchild.parent.remove(child);\n\t\tlist.push(child);\n\t\tchild.parent = this;\n\t}\n\n\tpublic function remove(child : Component) {\n\t\tif(!list.remove(child))\n\t\t\tthrow '$child is not a child of $this';\n\t\tchild.parent = null;\n\t}\n\n\tfunction get_children()\n\t\treturn list;\n\n\tpublic function toString()\n\t\treturn Type.getClassName(Type.getClass(this)).split('.').pop();\n}","package sui.components;\n\nimport sui.properties.Property;\nimport sui.properties.PropertyName;\n\nclass Properties {\n\tvar properties : Map<String, Property>;\n\tvar target : Component;\n\tpublic function new(target : Component) {\n\t\tthis.target = target;\n\t\tproperties = new Map();\n\t}\n\n\tpublic function removeAll() {\n\t\tfor(name in properties.keys())\n\t\t\tremove(name);\n\t}\n\n\tfunction add(property : Property) {\n\t\tif(properties.exists(property.name))\n\t\t\tthrow '$target already has a property $property';\n\t\tproperties.set(property.name, property);\n\t}\n\n\tpublic function get(name : PropertyName) {\n\t\treturn properties.get(name);\n\t}\n\n\tpublic function exists(name : PropertyName) {\n\t\treturn properties.exists(name);\n\t}\n\n\tfunction remove(name : PropertyName) {\n\t\tif(!properties.exists(name))\n\t\t\tthrow 'property \"${name}\" does not exist in $target';\n\t\tproperties.get(name).dispose();\n\t\tproperties.remove(name);\n\t}\n}","package sui.properties;\n\nimport sui.components.Component;\n\n@:access(sui.components.Properties)\nclass Property {\n\tpublic var component(default, null) : Component;\n\tpublic var name(default, null) : String;\n\tvar _dispose : Void -> Void;\n\tpublic function new(component : Component, name : String) {\n\t\tthis.component = component;\n\t\tthis.name  = name;\n\t\tthis._dispose  = init();\n\t\tcomponent.properties.add(this);\n\t}\n\n\tfunction init() : Void -> Void {\n\t\treturn throw \"abstact function init, must override\";\n\t}\n\n\tpublic function dispose() {\n\t\t_dispose();\n\t\tthis.component.properties.remove(name);\n\t\tthis.component = null;\n\t}\n\n\tpublic function toString()\n\t\treturn Type.getClassName(Type.getClass(this)).split('.').pop();\n}","package sui.properties;\n\nusing steamer.dom.Dom;\nimport steamer.Value;\nimport sui.components.Component;\nimport thx.Assert;\n\nclass Attribute extends Property {\n\tpublic static function asAttribute<T>(component : Component, name : String) : Attribute {\n\t\tvar property = component.properties.get(name);\n\t\tAssert.is(property, Attribute);\n\t\treturn cast property;\n\t}\n\n\tpublic function new(component : Component, name : String, ?attributeName : String, defaultValue : String) {\n\t\tthis.attributeName = null == attributeName ? name : attributeName;\n\t\tthis.defaultValue = defaultValue;\n\t\tsuper(component, name);\n\t}\n\n\tpublic var defaultValue(default, null) : String;\n\tpublic var attributeName(default, null) : String;\n\tpublic var attribute(default, null) : Value<String>;\n\n\toverride function init() : Void -> Void {\n\t\tattribute = new Value(defaultValue);\n\t\tattribute.feed(component.el.consumeAttribute(attributeName));\n\t\treturn function() {\n\t\t\tattribute.terminate();\n\t\t\tattribute = null;\n\t\t};\n\t}\n}","package sui.properties;\n\nabstract PropertyName(String) {\n\t@:from public inline static function fromProperty(property : Property)\n\t\treturn new PropertyName(property.name);\n\n\t@:from public inline static function fromString(name : String)\n\t\treturn new PropertyName(name);\n\n\tpublic inline function new(name : String)\n\t\tthis = name;\n\n\t@:to public inline function toString()\n\t\treturn this;\n}","package sui.properties;\n\nimport js.html.Element;\nimport steamer.Pulse.End;\nimport steamer.Value;\nimport sui.components.Component;\nimport steamer.SimpleConsumer;\nimport thx.Assert;\n\nclass Text extends Property {\n\tpublic static function asText(component : Component) : Text {\n\t\tvar property = component.properties.get('text');\n\t\tAssert.is(property, Text);\n\t\treturn cast property;\n\t}\n\n\tpublic var defaultText(default, null) : String;\n\tpublic var text(default, null) : Value<String>;\n\n\tpublic function new(component : Component, defaultText : String) {\n\t\tthis.defaultText = defaultText;\n\t\tsuper(component, 'text');\n\t}\n\n\toverride function init() : Void -> Void {\n\t\tvar el       = component.el,\n\t\t\toriginal = el.innerText;\n\t\ttext = new Value(defaultText);\n\t\ttext.feed(new SimpleConsumer(\n\t\t\tfunction(value) el.innerText = value,\n\t\t\tfunction() el.innerText = original\n\t\t));\n\t\treturn function() {\n\t\t\ttext.terminate();\n\t\t\ttext = null;\n\t\t};\n\t}\n}","package thx;\n\nimport haxe.PosInfos;\nimport haxe.CallStack;\n\nclass Error {\n\tpublic var message(default, null) : String;\n\tpublic var stack(default, null) : Array<StackItem>;\n\tpublic var pos(default, null) : PosInfos;\n\tpublic function new(message : String, ?stack : Array<StackItem>, ?pos : PosInfos) {\n\t\tthis.message = message;\n\t\tif(null == stack) {\n\t\t\tstack = CallStack.exceptionStack();\n\t\t\tif(stack.length == 0)\n\t\t\t\tstack = CallStack.callStack();\n\t\t}\n\t\tthis.stack = stack;\n\t\tthis.pos = pos;\n\t}\n\n\tpublic function toString() {\n\t\treturn message + \"from: \" + pos.className + \".\" + pos.methodName + \"() at \" + pos.lineNumber + \"\\n\\n\" + CallStack.toString(stack);\n\t}\n}","package thx;\n\nimport thx.core.Assertion;\nimport haxe.io.Bytes;\nimport haxe.PosInfos;\nimport thx.Error;\n\n/**\n* This class contains only static members used to perform assertations inside a test method.\n* It's use is straight forward:\n* <pre>\n* public function testObvious() {\n*   Assert.equals(1, 0); // fails\n*   Assert.isFalse(1 == 1, \"guess what?\"); // fails and returns the passed message\n*   Assert.isTrue(true); // successfull\n* }\n* </pre>\n*/\nclass Assert {\n\t/**\n\t* A stack of results for the current testing workflow. It is used internally\n\t* by other classes of the utest library.\n\t*/\n\tpublic static var results : { add : Assertion -> Void };\n\t/**\n\t* Asserts successfully when the condition is true.\n\t* @param cond: The condition to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function isTrue(cond : Bool, ?msg : String, ?pos : PosInfos) {\n\t\tif (results == null) throw \"Assert.results is not currently bound to any assert context\";\n\t\tif (null == msg)\n\t\t\tmsg = \"expected true\";\n\t\tif(cond)\n\t\t\tresults.add(Success(pos));\n\t\telse\n\t\t\tresults.add(Failure(msg, pos));\n\t}\n\t/**\n\t* Asserts successfully when the condition is false.\n\t* @param cond: The condition to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function isFalse(value : Bool, ?msg : String, ?pos : PosInfos) {\n\t\tif (null == msg)\n\t\t\tmsg = \"expected false\";\n\t\tisTrue(value == false, msg, pos);\n\t}\n\t/**\n\t* Asserts successfully when the value is null.\n\t* @param value: The value to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function isNull(value : Dynamic, ?msg : String, ?pos : PosInfos) {\n\t\tif (msg == null)\n\t\t\tmsg = \"expected null but was \" + q(value);\n\t\tisTrue(value == null, msg, pos);\n\t}\n\t/**\n\t* Asserts successfully when the value is not null.\n\t* @param value: The value to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function notNull(value : Dynamic, ?msg : String, ?pos : PosInfos) {\n\t\tif (null == msg)\n\t\t\tmsg = \"expected not null\";\n\t\tisTrue(value != null, msg, pos);\n\t}\n\t/**\n\t* Asserts successfully when the 'value' parameter is of the of the passed type 'type'.\n\t* @param value: The value to test\n\t* @param type: The type to test against\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function is(value : Dynamic, type : Dynamic, ?msg : String , ?pos : PosInfos) {\n\t\tif (msg == null) msg = \"expected type \" + typeToString(type) + \" but was \" + typeToString(value);\n\t\tisTrue(Std.is(value, type), msg, pos);\n\t}\n\n\t/**\n\t* Asserts successfully when the value parameter is not the same as the expected one.\n\t* <pre>\n\t* Assert.notEquals(10, age);\n\t* </pre>\n\t* @param expected: The expected value to check against\n\t* @param value: The value to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function notEquals(expected : Dynamic, value : Dynamic, ?msg : String , ?pos : PosInfos) {\n\t\tif(msg == null) msg = \"expected \" + q(expected) + \" and testa value \" + q(value) + \" should be different\";\n\t\tisFalse(expected == value, msg, pos);\n\t}\n\n\t/**\n\t* Asserts successfully when the value parameter is equal to the expected one.\n\t* <pre>\n\t* Assert.equals(10, age);\n\t* </pre>\n\t* @param expected: The expected value to check against\n\t* @param value: The value to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function equals(expected : Dynamic, value : Dynamic, ?msg : String , ?pos : PosInfos) {\n\t\tif(msg == null) msg = \"expected \" + q(expected) + \" but was \" + q(value);\n\t\tisTrue(expected == value, msg, pos);\n\t}\n\n\t/**\n\t* Asserts successfully when the value parameter does match against the passed EReg instance.\n\t* <pre>\n\t* Assert.match(~/x/i, \"haXe\");\n\t* </pre>\n\t* @param pattern: The pattern to match against\n\t* @param value: The value to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function match(pattern : EReg, value : Dynamic, ?msg : String , ?pos : PosInfos) {\n\t\tif(msg == null) msg = \"the value \" + q(value) + \"does not match the provided pattern\";\n\t\tisTrue(pattern.match(value), msg, pos);\n\t}\n\n\t/**\n\t* Same as Assert.equals but considering an approximation error.\n\t* <pre>\n\t* Assert.floatEquals(Math.PI, value);\n\t* </pre>\n\t* @param expected: The expected value to check against\n\t* @param value: The value to test\n\t* @param approx: The approximation tollerance. Default is 1e-5\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t* @todo test the approximation argument\n\t*/\n\tpublic static function floatEquals(expected : Float, value : Float, ?approx : Float, ?msg : String , ?pos : PosInfos) : Void {\n\t\tif (msg == null) msg = \"expected \" + q(expected) + \" but was \" + q(value);\n\t\treturn isTrue(_floatEquals(expected, value, approx), msg, pos);\n\t}\n\n\tstatic function _floatEquals(expected : Float, value : Float, ?approx : Float)\n\t{\n\t\tif (Math.isNaN(expected))\n\t\t\treturn Math.isNaN(value);\n\t\telse if (Math.isNaN(value))\n\t\t\treturn false;\n\t\telse if (!Math.isFinite(expected) && !Math.isFinite(value))\n\t\t\treturn (expected > 0) == (value > 0);\n\t\tif (null == approx)\n\t\t\tapprox = 1e-5;\n\t\treturn Math.abs(value-expected) < approx;\n\t}\n\n\tstatic function getTypeName(v : Dynamic) {\n\t\tswitch(Type.typeof(v))\n\t\t{\n\t\t\tcase TNull    : return \"[null]\";\n\t\t\tcase TInt     : return \"Int\";\n\t\t\tcase TFloat   : return \"Float\";\n\t\t\tcase TBool    : return \"Bool\";\n\t\t\tcase TFunction: return \"function\";\n\t\t\tcase TClass(c): return Type.getClassName(c);\n\t\t\tcase TEnum(e) : return Type.getEnumName(e);\n\t\t\tcase TObject  : return \"Object\";\n\t\t\tcase TUnknown : return \"Unknown\";\n\t\t}\n\t}\n\n\tstatic function isIterable(v : Dynamic, isAnonym : Bool) {\n\t\tvar fields = isAnonym ? Reflect.fields(v) : Type.getInstanceFields(Type.getClass(v));\n\t\tif(!Lambda.has(fields, \"iterator\")) return false;\n\t\treturn Reflect.isFunction(Reflect.field(v, \"iterator\"));\n\t}\n\n\tstatic function isIterator(v : Dynamic, isAnonym : Bool) {\n\t\tvar fields = isAnonym ? Reflect.fields(v) : Type.getInstanceFields(Type.getClass(v));\n\t\tif(!Lambda.has(fields, \"next\") || !Lambda.has(fields, \"hasNext\")) return false;\n\t\treturn Reflect.isFunction(Reflect.field(v, \"next\")) && Reflect.isFunction(Reflect.field(v, \"hasNext\"));\n\t}\n\n\tstatic function sameAs(expected : Dynamic, value : Dynamic, status : LikeStatus) {\n\t\tvar texpected = getTypeName(expected);\n\t\tvar tvalue = getTypeName(value);\n\n\t\tif(texpected != tvalue) {\n\t\t\tstatus.error = \"expected type \" + texpected + \" but it is \" + tvalue + (status.path == '' ? '' : ' for field ' + status.path);\n\t\t\treturn false;\n\t\t}\n\t\tswitch(Type.typeof(expected))\n\t\t{\n\t\t\tcase TFloat:\n\t\t\t\tif (!_floatEquals(expected, value))\n\t\t\t\t{\n\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\tcase TNull, TInt, TBool:\n\t\t\t\tif(expected != value) {\n\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\tcase TFunction:\n\t\t\t\tif (!Reflect.compareMethods(expected, value))\n\t\t\t\t{\n\t\t\t\t\tstatus.error = \"expected same function reference\" + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\tcase TClass(c):\n\t\t\t\tvar cexpected = Type.getClassName(c);\n\t\t\t\tvar cvalue = Type.getClassName(Type.getClass(value));\n\t\t\t\tif (cexpected != cvalue)\n\t\t\t\t{\n\t\t\t\t\tstatus.error = \"expected instance of \" + q(cexpected) + \" but it is \" + q(cvalue) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// string\n\t\t\t\tif (Std.is(expected, String) && expected != value)\n\t\t\t\t{\n\t\t\t\t\tstatus.error = \"expected '\" + expected + \"' but it is '\" + value + \"'\";\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// arrays\n\t\t\t\tif(Std.is(expected, Array)) {\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tif(expected.length != value.length) {\n\t\t\t\t\t\t\tstatus.error = \"expected \"+expected.length+\" elements but they were \"+value.length + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = status.path;\n\t\t\t\t\t\tfor(i in 0...expected.length) {\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'array['+i+']' : path + '['+i+']';\n\t\t\t\t\t\t\tif (!sameAs(expected[i], value[i], status))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// date\n\t\t\t\tif(Std.is(expected, Date)) {\n\t\t\t\t\tif(expected.getTime() != value.getTime()) {\n\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// bytes\n\t\t\t\tif(Std.is(expected, Bytes)) {\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tvar ebytes : Bytes = expected;\n\t\t\t\t\t\tvar vbytes : Bytes = value;\n\t\t\t\t\t\tif (ebytes.length != vbytes.length) return false;\n\t\t\t\t\t\tfor (i in 0...ebytes.length)\n\t\t\t\t\t\t\tif (ebytes.get(i) != vbytes.get(i))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatus.error = \"expected byte \" + ebytes.get(i) + \" but wss \" + ebytes.get(i) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// hash, inthash\n\t\t\t\tif(Std.is(expected, haxe.ds.StringMap) || Std.is(expected, haxe.ds.IntMap)) {\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tvar keys  = Lambda.array({ iterator : function() return expected.keys() });\n\t\t\t\t\t\tvar vkeys = Lambda.array({ iterator : function() return value.keys() });\n\t\t\t\t\t\tif(keys.length != vkeys.length) {\n\t\t\t\t\t\t\tstatus.error = \"expected \"+keys.length+\" keys but they were \"+vkeys.length + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = status.path;\n\t\t\t\t\t\tfor(key in keys) {\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'hash['+key+']' : path + '['+key+']';\n\t\t\t\t\t\t\tif (!sameAs(expected.get(key), value.get(key), status))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// iterator\n\t\t\t\tif(isIterator(expected, false)) {\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tvar evalues = Lambda.array({ iterator : function() return expected });\n\t\t\t\t\t\tvar vvalues = Lambda.array({ iterator : function() return value });\n\t\t\t\t\t\tif(evalues.length != vvalues.length) {\n\t\t\t\t\t\t\tstatus.error = \"expected \"+evalues.length+\" values in Iterator but they were \"+vvalues.length + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = status.path;\n\t\t\t\t\t\tfor(i in 0...evalues.length) {\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'iterator['+i+']' : path + '['+i+']';\n\t\t\t\t\t\t\tif (!sameAs(evalues[i], vvalues[i], status))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// iterable\n\t\t\t\tif(isIterable(expected, false)) {\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tvar evalues = Lambda.array(expected);\n\t\t\t\t\t\tvar vvalues = Lambda.array(value);\n\t\t\t\t\t\tif(evalues.length != vvalues.length) {\n\t\t\t\t\t\t\tstatus.error = \"expected \"+evalues.length+\" values in Iterable but they were \"+vvalues.length + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = status.path;\n\t\t\t\t\t\tfor(i in 0...evalues.length) {\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'iterable['+i+']' : path + '['+i+']';\n\t\t\t\t\t\t\tif(!sameAs(evalues[i], vvalues[i], status))\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// custom class\n\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\tvar fields = Type.getInstanceFields(Type.getClass(expected));\n\t\t\t\t\tvar path = status.path;\n\t\t\t\t\tfor(field in fields) {\n\t\t\t\t\t\tstatus.path = path == '' ? field : path+'.'+field;\n\t\t\t\t\t\tvar e = Reflect.field(expected, field);\n\t\t\t\t\t\tif(Reflect.isFunction(e)) continue;\n\t\t\t\t\t\tvar v = Reflect.field(value, field);\n\t\t\t\t\t\tif(!sameAs(e, v, status))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\tcase TEnum(e) :\n\t\t\t\tvar eexpected = Type.getEnumName(e);\n\t\t\t\tvar evalue = Type.getEnumName(Type.getEnum(value));\n\t\t\t\tif (eexpected != evalue)\n\t\t\t\t{\n\t\t\t\t\tstatus.error = \"expected enumeration of \" + q(eexpected) + \" but it is \" + q(evalue) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (status.recursive || status.path == '')\n\t\t\t\t{\n\t\t\t\t\tif (Type.enumIndex(expected) != Type.enumIndex(value))\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus.error = 'expected ' + q(Type.enumConstructor(expected)) + ' but is ' + q(Type.enumConstructor(value)) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tvar eparams = Type.enumParameters(expected);\n\t\t\t\t\tvar vparams = Type.enumParameters(value);\n\t\t\t\t\tvar path = status.path;\n\t\t\t\t\tfor (i in 0...eparams.length)\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus.path = path == '' ? 'enum[' + i + ']' : path + '[' + i + ']';\n\t\t\t\t\t\tif (!sameAs(eparams[i], vparams[i], status))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field ' + status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\tcase TObject  :\n\t\t\t\t// anonymous object\n\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\tvar tfields = Reflect.fields(value);\n\t\t\t\t\tvar fields = Reflect.fields(expected);\n\t\t\t\t\tvar path = status.path;\n\t\t\t\t\tfor(field in fields) {\n\t\t\t\t\t\ttfields.remove(field);\n\t\t\t\t\t\tstatus.path = path == '' ? field : path+'.'+field;\n\t\t\t\t\t\tif(!Reflect.hasField(value, field)) {\n\t\t\t\t\t\t\tstatus.error = \"expected field \" + status.path + \" does not exist in \" + q(value);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar e = Reflect.field(expected, field);\n\t\t\t\t\t\tif(Reflect.isFunction(e))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar v = Reflect.field(value, field);\n\t\t\t\t\t\tif(!sameAs(e, v, status))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif(tfields.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus.error = \"the tested object has extra field(s) (\" + tfields.join(\", \") + \") not included in the expected ones\";\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// iterator\n\t\t\t\tif(isIterator(expected, true)) {\n\t\t\t\t\tif(!(isIterator(value, true))) {\n\t\t\t\t\t\tstatus.error = \"expected Iterable but it is not \" + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tvar evalues = Lambda.array({ iterator : function() return expected });\n\t\t\t\t\t\tvar vvalues = Lambda.array({ iterator : function() return value });\n\t\t\t\t\t\tif(evalues.length != vvalues.length) {\n\t\t\t\t\t\t\tstatus.error = \"expected \"+evalues.length+\" values in Iterator but they were \"+vvalues.length + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = status.path;\n\t\t\t\t\t\tfor(i in 0...evalues.length) {\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'iterator['+i+']' : path + '['+i+']';\n\t\t\t\t\t\t\tif (!sameAs(evalues[i], vvalues[i], status))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// iterable\n\t\t\t\tif(isIterable(expected, true)) {\n\t\t\t\t\tif(!(isIterable(value, true))) {\n\t\t\t\t\t\tstatus.error = \"expected Iterator but it is not \" + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tvar evalues = Lambda.array(expected);\n\t\t\t\t\t\tvar vvalues = Lambda.array(value);\n\t\t\t\t\t\tif(evalues.length != vvalues.length) {\n\t\t\t\t\t\t\tstatus.error = \"expected \"+evalues.length+\" values in Iterable but they were \"+vvalues.length + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = status.path;\n\t\t\t\t\t\tfor(i in 0...evalues.length) {\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'iterable['+i+']' : path + '['+i+']';\n\t\t\t\t\t\t\tif(!sameAs(evalues[i], vvalues[i], status))\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\tcase TUnknown :\n\t\t\t\treturn throw \"Unable to compare two unknown types\";\n\t\t}\n\t\treturn throw \"Unable to compare values: \" + q(expected) + \" and \" + q(value);\n\t}\n\n\tstatic function q(v : Dynamic)\n\t{\n\t\tif (Std.is(v, String))\n\t\t\treturn '\"' + StringTools.replace(v, '\"', '\\\\\"') + '\"';\n\t\telse\n\t\t\treturn Std.string(v);\n\t}\n\n\t/**\n\t* Check that value is an object with the same fields and values found in expected.\n\t* The default behavior is to check nested objects in fields recursively.\n\t* <pre>\n\t* Assert.same({ name : \"utest\"}, ob);\n\t* </pre>\n\t* @param expected: The expected value to check against\n\t* @param value: The value to test\n\t* @param recursive: States whether or not the test will apply also to sub-objects.\n\t* Defaults to true\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function same(expected : Dynamic, value : Dynamic, ?recursive : Bool, ?msg : String, ?pos : PosInfos) {\n\t\tvar status = { recursive : null == recursive ? true : recursive, path : '', error : null };\n\t\tif(sameAs(expected, value, status)) {\n\t\t\tAssert.isTrue(true, msg, pos);\n\t\t} else {\n\t\t\tAssert.fail(msg == null ? status.error : msg, pos);\n\t\t}\n\t}\n\n\t/**\n\t* It is used to test an application that under certain circumstances must\n\t* react throwing an error. This assert guarantees that the error is of the\n\t* correct type (or Dynamic if non is specified).\n\t* <pre>\n\t* Assert.raises(function() { throw \"Error!\"; }, String);\n\t* </pre>\n\t* @param method: A method that generates the exception.\n\t* @param type: The type of the expected error. Defaults to Dynamic (catch all).\n\t* @param msgNotThrown: An optional error message used when the function fails to raise the expected\n\t*  \t\t exception. If not passed a default one will be used\n\t* @param msgWrongType: An optional error message used when the function raises the exception but it is\n\t*  \t\t of a different type than the one expected. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t* @todo test the optional type parameter\n\t*/\n\tpublic static function raises(method:Void -> Void, ?type:Class<Dynamic>, ?msgNotThrown : String , ?msgWrongType : String, ?pos : PosInfos) {\n\t\tif(type == null)\n\t\t\ttype = String;\n\t\ttry {\n\t\t\tmethod();\n\t\t\tvar name = Type.getClassName(type);\n\t\t\tif (name == null) name = \"\"+type;\n\t\t\tif (null == msgNotThrown)\n\t\t\t\tmsgNotThrown = \"exception of type \" + name + \" not raised\";\n\t\t\tfail(msgNotThrown, pos);\n\t\t} catch (ex : Dynamic) {\n\t\t\tvar name = Type.getClassName(type);\n\t\t\tif (name == null) name = \"\"+type;\n\t\t\tif (null == msgWrongType)\n\t\t\t\tmsgWrongType = \"expected throw of type \" + name + \" but was \"  + ex;\n\t\t\tisTrue(Std.is(ex, type), msgWrongType, pos);\n\t\t}\n\t}\n\t/**\n\t* Checks that the test value matches at least one of the possibilities.\n\t* @param possibility: An array of mossible matches\n\t* @param value: The value to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function allows<T>(possibilities : Array<T>, value : T, ?msg : String , ?pos : PosInfos) {\n\t\tif(Lambda.has(possibilities, value)) {\n\t\t\tisTrue(true, msg, pos);\n\t\t} else {\n\t\t\tfail(msg == null ? \"value \" + q(value) + \" not found in the expected possibilities \" + possibilities : msg, pos);\n\t\t}\n\t}\n\t/**\n\t* Checks that the test array contains the match parameter.\n\t* @param match: The element that must be included in the tested array\n\t* @param values: The values to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function contains<T>(match : T, values : Array<T>, ?msg : String , ?pos : PosInfos) {\n\t\tif(Lambda.has(values, match)) {\n\t\t\tisTrue(true, msg, pos);\n\t\t} else {\n\t\t\tfail(msg == null ? \"values \" + q(values) + \" do not contain \"+match: msg, pos);\n\t\t}\n\t}\n\n\t/**\n\t* Checks that the test array does not contain the match parameter.\n\t* @param match: The element that must NOT be included in the tested array\n\t* @param values: The values to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function notContains<T>(match : T, values : Array<T>, ?msg : String , ?pos : PosInfos) {\n\t\tif(!Lambda.has(values, match)) {\n\t\t\tisTrue(true, msg, pos);\n\t\t} else {\n\t\t\tfail(msg == null ? \"values \" + q(values) + \" do contain \"+match: msg, pos);\n\t\t}\n\t}\n\n\t/**\n\t * Checks that the expected values is contained in value.\n\t * @param match: the string value that must be contained in value\n\t * @param value: the value to test\n\t * @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t */\n\tpublic static function stringContains(match : String, value : String, ?msg : String , ?pos : PosInfos) {\n\t\tif (value != null && value.indexOf(match) >= 0) {\n\t\t\tisTrue(true, msg, pos);\n\t\t} else {\n\t\t\tfail(msg == null ? \"value \" + q(value) + \" does not contain \" + q(match) : msg, pos);\n\t\t}\n\t}\n\n\tpublic static function stringSequence(sequence : Array<String>, value : String, ?msg : String , ?pos : PosInfos) {\n\t\tif (null == value)\n\t\t{\n\t\t\tfail(msg == null ? \"null argument value\" : msg, pos);\n\t\t\treturn;\n\t\t}\n\t\tvar p = 0;\n\t\tfor (s in sequence)\n\t\t{\n\t\t\tvar p2 = value.indexOf(s, p);\n\t\t\tif (p2 < 0)\n\t\t\t{\n\t\t\t\tif (msg == null)\n\t\t\t\t{\n\t\t\t\t\tmsg = \"expected '\" + s + \"' after \";\n\t\t\t\t\tif (p > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar cut = value.substr(0, p);\n\t\t\t\t\t\tif (cut.length > 30)\n\t\t\t\t\t\t\tcut = '...' + cut.substr( -27);\n\t\t\t\t\t\tmsg += \" '\" + cut + \"'\" ;\n\t\t\t\t\t} else\n\t\t\t\t\t\tmsg += \" begin\";\n\t\t\t\t}\n\t\t\t\tfail(msg, pos);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tp = p2 + s.length;\n\t\t}\n\t\tisTrue(true, msg, pos);\n\t}\n\n\t/**\n\t* Forces a failure.\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function fail(msg = \"failure expected\", ?pos : PosInfos) {\n\t\tisTrue(false, msg, pos);\n\t}\n\t/**\n\t* Creates a warning message.\n\t* @param msg: A mandatory message that justifies the warning.\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function warn(msg) {\n\t\tresults.add(Warning(msg));\n\t}\n\n\t/**\n\t* Creates an asynchronous context for test execution. Assertions should be included\n\t* in the passed function.\n\t* <pre>\n\t* public function assertAsync() {\n\t*   var async = Assert.createAsync(function() Assert.isTrue(true));\n\t*   haxe.Timer.delay(async, 50);\n\t* }\n\t* @param f: A function that contains other Assert tests\n\t* @param timeout: Optional timeout value in milliseconds.\n\t*/\n\tpublic static dynamic function createAsync(?f : Void -> Void, ?timeout : Int) {\n\t\treturn function(){};\n\t}\n\t/**\n\t* Creates an asynchronous context for test execution of an event like method.\n\t* Assertions should be included in the passed function.\n\t* It works the same way as Assert.assertAsync() but accepts a function with one\n\t* argument (usually some event data) instead of a function with no arguments\n\t* @param f: A function that contains other Assert tests\n\t* @param timeout: Optional timeout value in milliseconds.\n\t*/\n\tpublic static dynamic function createEvent<EventArg>(f : EventArg -> Void, ?timeout : Int) {\n\t\treturn function(e){};\n\t}\n\n\tstatic function typeToString(t : Dynamic)\n\t{\n\t\ttry {\n\t\t\tvar _t = Type.getClass(t);\n\t\t\tif (_t != null)\n\t\t\t\tt = _t;\n\t\t} catch(e : Dynamic) { }\n\t\ttry return Type.getClassName(t) catch (e : Dynamic) { }\n\t\ttry {\n\t\t\tvar _t = Type.getEnum(t);\n\t\t\tif (_t != null)\n\t\t\t\tt = _t;\n\t\t} catch(e : Dynamic) { }\n\t\ttry return Type.getEnumName(t) catch(e : Dynamic) {}\n\t\ttry return Std.string(Type.typeof(t)) catch (e : Dynamic) { }\n\t\ttry return Std.string(t) catch (e : Dynamic) { }\n\t\treturn '<unable to retrieve type name>';\n\t}\n\n\tstatic function __init__() {\n\t\tfunction posToString(pos : haxe.PosInfos) {\n\t\t\treturn pos;\n\t\t}\n\t\tresults = {\n\t\t\tadd : function(assertion : Assertion) {\n\t\t\t\tswitch assertion {\n\t\t\t\t\tcase Failure(msg, pos):\n\t\t\t\t\t\tthrow new Error(msg, null, pos);\n\t\t\t\t\tcase Error(e, stack), PreConditionError(e, stack), PostConditionError(e, stack):\n\t\t\t\t\t\tthrow new Error(Std.string(e), stack);\n\t\t\t\t\tcase Warning(msg):\n\t\t\t\t\t\ttrace(msg);\n\t\t\t\t\tcase Success(pos):\n\t\t\t\t\t\t// do nothing\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n}\n\nprivate typedef LikeStatus = {\n\trecursive : Bool,\n\tpath : String,\n\terror : String\n};","package thx;\n\nclass Timer {\n\tpublic static function setInterval(callback : Void -> Void, delay : Int) : TimerID\n\t\treturn untyped __js__('setInterval')(callback, delay);\n\n\tpublic static function setTimeout(callback : Void -> Void, delay : Int) : TimerID\n\t\treturn untyped __js__('setTimeout')(callback, delay);\n\n\tpublic static function setImmediate(callback : Void -> Void) : TimerID\n\t\treturn untyped __js__('setTimeout')(callback, 0);\n\n\tpublic static function clearTimer(id : TimerID) : Void\n\t\treturn untyped __js__('clearTimeout')(id);\n}\n\nextern\nclass TimerID {}","/**\n * ...\n * @author Franco Ponticelli\n */\n\npackage thx.core;\n\nclass Arrays\n{\n\tpublic static function cross<T>(a : Array<T>, b : Array<T>)\n\t{\n\t\tvar r = [];\n\t\tfor (va in a)\n\t\t\tfor (vb in b)\n\t\t\t\tr.push([va, vb]);\n\t\treturn r;\n\t}\n\n\tpublic static function crossMulti<T>(a : Array<Array<T>>)\n\t{\n\t\tvar acopy  = a.copy(),\n\t\t\tresult = acopy.shift().map(function(v) return [v]);\n\t\twhile (acopy.length > 0)\n\t\t{\n\t\t\tvar arr = acopy.shift(),\n\t\t\t\ttresult = result;\n\t\t\tresult = [];\n\t\t\tfor (v in arr)\n\t\t\t{\n\t\t\t\tfor (ar in tresult)\n\t\t\t\t{\n\t\t\t\t\tvar t = ar.copy();\n\t\t\t\t\tt.push(v);\n\t\t\t\t\tresult.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static function pushIf<T>(arr : Array<T>, cond : Bool, value : T)\n\t{\n\t\tif (cond)\n\t\t\tarr.push(value);\n\t\treturn arr;\n\t}\n\n\t#if js inline #end\n\tpublic static function mapi<TIn, TOut>(arr : Array<TIn>, handler : TIn -> Int -> TOut) : Array<TOut>\n\t{\n\t\t#if js\n\t\t\treturn (cast arr : { map : (TIn -> Int -> TOut) -> Array<TOut> }).map(handler);\n\t\t#else\n\t\t\tvar r = [];\n\t\t\tfor(i in 0...arr.length)\n\t\t\t\tr.push(handler(arr[i], i));\n\t\t\treturn r;\n\t\t#end\n\t}\n\n\tinline public static function flatMap<TIn, TOut>(arr : Array<TIn>, callback : TIn -> Array<TOut>) : Array<TOut>\n\t\treturn flatten(arr.map(callback));\n\n\t#if js inline #end\n\tpublic static function flatten<T>(arr : Array<Array<T>>) {\n\t\t#if js\n\t\t\treturn untyped __js__('Array.prototype.concat.apply')([], arr);\n\t\t#else\n\t\t\treturn reduce(arr, function(acc : Array<T>, item) return acc.concat(item), []);\n\t\t#end\n\t}\n\n\tinline public static function reduce<TItem, TAcc>(arr : Array<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc {\n\t\t#if js\n\t\t\treturn untyped arr.reduce(callback, initial);\n\t\t#else\n\t\t\treturn Iterables.reduce(arr, callback, initial);\n\t\t#end\n\t}\n\n\tinline public static function reducei<TItem, TAcc>(arr : Array<TItem>, callback : TAcc -> TItem -> Int -> TAcc, initial : TAcc) : TAcc {\n\t\t#if js\n\t\t\treturn untyped arr.reduce(callback, initial);\n\t\t#else\n\t\t\treturn Iterable.reducei(arr, callback, initial);\n\t\t#end\n\t}\n\n\tpublic static function order<T>(arr : Array<T>, sort : T -> T -> Int)\n\t{\n\t\tvar n = arr.copy();\n\t\tn.sort(sort);\n\t\treturn n;\n\t}\n\n\tinline public static function isEmpty<T>(arr : Array<T>) : Bool\n\t\treturn arr.length == 0;\n}","package thx.core;\n\n/**\n * ...\n * @author Franco Ponticelli\n */\n\nclass Ints\n{\n\tpublic static inline function clamp(v : Int, min : Int, max : Int) : Int\n\t{\n\t\treturn v < min ? min : (v > max ? max : v);\n\t}\n\n\tstatic var pattern_parse = ~/^[+-]?(\\d+|0x[0-9A-F]+)$/i;\n\tpublic static function canParse(s : String)\n\t{\n\t\treturn pattern_parse.match(s);\n\t}\n\n\tpublic inline static function min(a : Int, b : Int)\n\t{\n\t\treturn a < b ? a : b;\n\t}\n\n\tpublic inline static function max(a : Int, b : Int)\n\t{\n\t\treturn a > b ? a : b;\n\t}\n\n\t// TODO add proper octal/hex/exp support\n\tpublic static function parse(s : String)\n\t{\n\t\tif (s.substr(0, 1) == \"+\")\n\t\t\ts = s.substr(1);\n\t\treturn Std.parseInt(s);\n\t}\n\n\tpublic inline static function compare(a : Int, b : Int)\n\t\treturn a - b;\n}","package thx.core;\n\nclass Iterables\n{\n\tpublic inline static function map<T, S>(it : Iterable<T>, f : T -> S) : Array<S>\n\t{\n\t\treturn Iterators.map(it.iterator(), f);\n\t}\n\n  public inline static function toArray<T>(it : Iterable<T>) : Array<T>\n  {\n    return Iterators.toArray(it.iterator());\n  }\n\n  public inline static function order<T>(it : Iterable<T>, sort : T -> T -> Int) : Array<T>\n  {\n    return Iterators.order(it.iterator(), sort);\n  }\n\n  public inline static function reduce<TItem, TAcc>(it : Iterable<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc {\n    return Iterators.reduce(it.iterator(), callback, initial);\n  }\n\n  public inline static function reducei<TItem, TAcc>(it : Iterable<TItem>, callback : TAcc -> TItem -> Int -> TAcc, initial : TAcc) : TAcc {\n    return Iterators.reducei(it.iterator(), callback, initial);\n  }\n\n  public inline static function isEmpty<T>(it : Iterable<T>) : Bool\n    return Iterators.isEmpty(it.iterator());\n}","package thx.core;\n\nclass Iterators\n{\n\tpublic static function map<T, S>(it : Iterator<T>, f : T -> S) : Array<S>\n\t{\n\t\tvar acc = [];\n\t\tfor(v in it)\n\t\t\tacc.push(f(v));\n\t\treturn acc;\n\t}\n\n  public static function mapi<T, S>(it : Iterator<T>, f : T -> Int -> S) : Array<S>\n  {\n    var acc = [],\n        i = 0;\n    for(v in it)\n      acc.push(f(v, i++));\n    return acc;\n  }\n\n  public static function toArray<T>(it : Iterator<T>) : Array<T>\n  {\n    var items = [];\n    for(item in it)\n      items.push(item);\n    return items;\n  }\n\n  public static function order<T>(it : Iterator<T>, sort : T -> T -> Int)\n  {\n    var n = Iterators.toArray(it);\n    n.sort(sort);\n    return n;\n  }\n\n  public static function reduce<TItem, TAcc>(it : Iterator<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc {\n    map(it, function(v) : Void {\n      initial = callback(initial, v);\n    });\n    return initial;\n  }\n\n  public static function reducei<TItem, TAcc>(it : Iterator<TItem>, callback : TAcc -> TItem -> Int -> TAcc, initial : TAcc) : TAcc {\n    mapi(it, function(v, i) {\n      initial = callback(initial, v, i);\n    });\n    return initial;\n  }\n\n  inline public static function isEmpty<T>(it : Iterator<T>) : Bool\n    return !it.hasNext();\n}","package thx.core;\n\nclass Objects {\n\tinline public static function isEmpty(o : {}) {\n\t\treturn Reflect.fields(o).length == 0;\n\t}\n}\n","package thx.core;\n\nusing StringTools;\n\nclass Strings\n{\n\tstatic var _reSplitWC = ~/(\\r\\n|\\n\\r|\\n|\\r)/g;\n\tstatic var _reReduceWS = ~/\\s+/;\n#if !php\n\tstatic var _reStripTags = ~/(<[a-z]+[^>\\/]*\\/?>|<\\/[a-z]+>)/i;\n#end\n// TODO, test me\n\tpublic static function upTo(value : String, searchFor : String)\n\t{\n\t\tvar pos = value.indexOf(searchFor);\n\t\tif (pos < 0)\n\t\t\treturn value;\n\t\telse\n\t\t\treturn value.substr(0, pos);\n\t}\n\n\t// TODO, test me\n\tpublic static function startFrom(value : String, searchFor : String)\n\t{\n\t\tvar pos = value.indexOf(searchFor);\n\t\tif (pos < 0)\n\t\t\treturn value;\n\t\telse\n\t\t\treturn value.substr(pos + searchFor.length);\n\t}\n\n\t// TODO, test me\n\tpublic static function rtrim(value : String, charlist : String) : String\n\t{\n#if php\n\t\treturn untyped __call__(\"rtrim\", value, charlist);\n#else\n\t\tvar len = value.length;\n\t\twhile (len > 0)\n\t\t{\n\t\t\tvar c = value.substr(len - 1, 1);\n\t\t\tif (charlist.indexOf(c) < 0)\n\t\t\t\tbreak;\n\t\t\tlen--;\n\t\t}\n\t\treturn value.substr(0, len);\n#end\n\t}\n\n\t// TODO, test me\n\tpublic static function ltrim(value : String, charlist : String) : String\n\t{\n#if php\n\t\treturn untyped __call__(\"ltrim\", value, charlist);\n#else\n\t\tvar start = 0;\n\t\twhile (start < value.length)\n\t\t{\n\t\t\tvar c = value.substr(start, 1);\n\t\t\tif (charlist.indexOf(c) < 0)\n\t\t\t\tbreak;\n\t\t\tstart++;\n\t\t}\n\t\treturn value.substr(start);\n#end\n\t}\n\n\tpublic static inline function trim(value : String, charlist : String) : String\n\t{\n#if php\n\t\treturn untyped __call__(\"trim\", value, charlist);\n#else\n\t\treturn rtrim(ltrim(value, charlist), charlist);\n#end\n\t}\n\n\tstatic var _reCollapse = ~/\\s+/g;\n\tpublic static function collapse(value : String)\n\t{\n\t\treturn _reCollapse.replace(StringTools.trim(value), \" \");\n\t}\n\n\tpublic static inline function ucfirst(value : String) : String\n\t{\n\t\treturn (value == null ? null : value.charAt(0).toUpperCase() + value.substr(1));\n\t}\n\n\tpublic static inline function lcfirst(value : String) : String\n\t{\n\t\treturn (value == null ? null : value.charAt(0).toLowerCase() + value.substr(1));\n\t}\n\n\tpublic static function empty(value : String)\n\t{\n\t\treturn value == null || value == '';\n\t}\n\n\tpublic static inline function isAlphaNum(value : String) : Bool\n\t{\n#if php\n\t\treturn untyped __call__(\"ctype_alnum\", value);\n#else\n\t\treturn (value == null ? false : __alphaNumPattern.match(value));\n#end\n\t}\n\n\tpublic static inline function digitsOnly(value : String) : Bool\n\t{\n#if php\n\t\treturn untyped __call__(\"ctype_digit\", value);\n#else\n\t\treturn (value == null ? false : __digitsPattern.match(value));\n#end\n\t}\n\n\tpublic static function ucwords(value : String) : String\n\t{\n\t\treturn __ucwordsPattern.map(ucfirst(value), __upperMatch);\n\t}\n\n\t/**\n\t * Like ucwords but uses only white spaces as boundaries\n\t * @param\tvalue\n\t * @return\n\t */\n\tpublic static function ucwordsws(value : String) : String\n\t{\n#if php\n\t\treturn untyped __call__(\"ucwords\", value);\n#else\n\t\treturn __ucwordswsPattern.map(ucfirst(value), __upperMatch);\n#end\n\t}\n\n\tstatic function __upperMatch(re : EReg)\n\t{\n\t\treturn re.matched(0).toUpperCase();\n\t}\n\tstatic var __ucwordsPattern = new EReg('[^a-zA-Z]([a-z])', 'g');\n#if !php\n\tstatic var __ucwordswsPattern = new EReg('\\\\s[a-z]', 'g');\n\tstatic var __alphaNumPattern = new EReg('^[a-z0-9]+$', 'i');\n\tstatic var __digitsPattern = new EReg('^[0-9]+$', '');\n#end\n\n\t/**\n\t*  Replaces undescores with space, finds UC characters, turns them into LC and prepends them with a space.\n\t*  More than one UC in sequence is left untouched.\n\t**/\n\tpublic static function humanize(s : String)\n\t{\n\t\treturn underscore(s).replace('_', ' ');\n\t}\n\n\t// TO TEST\n\tpublic static function capitalize(s : String)\n\t{\n\t\treturn s.substr(0, 1).toUpperCase() + s.substr(1);\n\t}\n\n\t// TO TEST\n\tpublic static function succ(s : String)\n\t{\n\t\treturn s.substr(0, -1) + String.fromCharCode(s.substr(-1).charCodeAt(0)+1);\n\t}\n\n\t// TO TEST\n\tpublic static function underscore(s : String)\n\t{\n\t\ts = (~/::/g).replace(s, '/');\n\t\ts =\t(~/([A-Z]+)([A-Z][a-z])/g).replace(s, '$1_$2');\n\t\ts = (~/([a-z\\d])([A-Z])/g).replace(s, '$1_$2');\n\t\ts = (~/-/g).replace(s, '_');\n\t\treturn s.toLowerCase();\n\t}\n\n\tpublic static function dasherize(s : String)\n\t{\n\t\treturn s.replace('_', '-');\n\t}\n\n\tpublic static function repeat(s : String, times : Int)\n\t{\n\t\tvar b = [];\n\t\tfor(i in 0...times)\n\t\t\tb.push(s);\n\t\treturn b.join('');\n\t}\n\n\tpublic static function wrapColumns(s : String, columns = 78, indent = \"\", newline = \"\\n\")\n\t{\n\t\tvar parts = _reSplitWC.split(s);\n\t\tvar result = [];\n\t\tfor(part in parts)\n\t\t{\n\t\t\tresult.push(_wrapColumns(StringTools.trim(_reReduceWS.replace(part, \" \")), columns, indent, newline));\n\t\t}\n\t\treturn result.join(newline);\n\t}\n\n\tstatic function _wrapColumns(s : String, columns : Int, indent : String, newline : String)\n\t{\n\t\tvar parts = [];\n\t\tvar pos = 0;\n\t\tvar len = s.length;\n\t\tvar ilen = indent.length;\n\t\tcolumns -= ilen;\n\t\twhile(true)\n\t\t{\n\t\t\tif(pos + columns >= len - ilen)\n\t\t\t{\n\t\t\t\tparts.push(s.substr(pos));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar i = 0;\n\t\t\twhile(!StringTools.isSpace(s, pos + columns - i) && i < columns)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(i == columns)\n\t\t\t{\n\t\t\t\t// search ahead\n\t\t\t\ti = 0;\n\t\t\t\twhile(!StringTools.isSpace(s, pos + columns + i) && pos + columns + i < len)\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tparts.push(s.substr(pos, columns + i));\n\t\t\t\tpos += columns + i + 1;\n\t\t\t} else {\n\t\t\t\tparts.push(s.substr(pos, columns - i));\n\t\t\t\tpos += columns - i + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn indent + parts.join(newline + indent);\n\t}\n\n\tpublic static function stripTags(s : String) : String\n\t{\n#if php\n\t\treturn untyped __call__(\"strip_tags\", s);\n#else\n\t\treturn _reStripTags.replace(s, \"\");\n#end\n\t}\n\n\tpublic static function ellipsis(s : String, maxlen = 20, symbol = \"...\")\n\t{\n\t\tif (s.length > maxlen)\n\t\t\treturn s.substr(0, symbol.length > maxlen - symbol.length ? symbol.length : maxlen - symbol.length) + symbol;\n\t\telse\n\t\t\treturn s;\n\t}\n\n\tpublic static function compare(a : String, b : String) return a < b ? -1 : a > b ? 1 : 0;\n}","/**\n * ...\n * @author Franco Ponticelli\n */\n\npackage thx.core;\n\nclass Types\n{\n\tpublic static inline function isAnonymousObject(v : Dynamic) : Bool\n\t{\n\t\treturn Reflect.isObject(v) && null == Type.getClass(v);\n\t}\n}\n\nclass ClassTypes\n{\n\tpublic inline static function toString(cls : Class<Dynamic>)\n\t\treturn Type.getClassName(cls);\n\n\tstatic public #if !php inline #end function as<T1, T2>(value : T1, type : Class<T2>) : Null<T2>\n\t{\n\t\treturn (Std.is(value, type) ? cast value : null);\n\t}\n}\n\nclass ValueTypes\n{\n\tpublic static function toString(type : Type.ValueType)\n\t{\n\t\treturn switch(type)\n\t\t{\n\t\t\tcase TInt:      \"Int\";\n\t\t\tcase TFloat:    \"Float\";\n\t\t\tcase TBool:     \"Bool\";\n\t\t\tcase TObject:   \"Dynamic\"; // TODO ?\n\t\t\tcase TFunction: \"Function\";\n\t\t\tcase TClass(c): Type.getClassName(c);\n\t\t\tcase TEnum(e):  Type.getEnumName(e);\n\t\t\tcase _:         null;\n\t\t}\n\t}\n\n\tpublic static function typeInheritance(type : Type.ValueType)\n\t{\n\t\treturn switch(type)\n\t\t{\n\t\t\tcase TInt:      [\"Int\"];\n\t\t\tcase TFloat:    [\"Float\"];\n\t\t\tcase TBool:     [\"Bool\"];\n\t\t\tcase TObject:   [\"Dynamic\"];\n\t\t\tcase TFunction: [\"Function\"];\n\t\t\tcase TClass(c):\n\t\t\t\tvar classes = [];\n\t\t\t\twhile (null != c)\n\t\t\t\t{\n\t\t\t\t\tclasses.push(c);\n\t\t\t\t\tc = Type.getSuperClass(c);\n\t\t\t\t}\n\t\t\t\tclasses.map(Type.getClassName);\n\t\t\tcase TEnum(e):  [Type.getEnumName(e)];\n\t\t\tcase _:         null;\n\t\t}\n\t}\n}","package thx.ref;\n\nclass BaseRef {\n\tpublic var parent(default, null) : IParentRef;\n\tpublic function new(?parent : IParentRef) {\n\t\tthis.parent = null != parent ? parent : EmptyParent.instance;\n\t}\n\n\tpublic function getRoot() : IRef {\n\t\tvar ref : IRef = cast this;\n\t\twhile(!Std.is(ref.parent, BaseRef.EmptyParent))\n\t\t\tref = cast ref.parent;\n\t\treturn ref;\n\t}\n}\n\nclass EmptyParent implements IParentRef {\n\tpublic static var instance(default, null) : IParentRef = new EmptyParent();\n\n\tfunction new() {}\n\n\tpublic function removeChild(child : IRef) { }\n}","package thx.ref;\n\nusing thx.core.Iterators;\nusing thx.core.Arrays;\nusing thx.core.Ints;\n\nclass ArrayRef extends BaseRef implements IRef implements IParentRef {\n\tvar items : Map<Int, IRef>;\n\tvar inverse : Map<IRef, Int>;\n\n\tpublic function new(?parent : IParentRef) {\n\t\tsuper(parent);\n\t\titems   = new Map();\n\t\tinverse = new Map();\n\t}\n\n\tpublic function get() {\n\t\tvar res = [];\n\t\titems\n\t\t\t.keys()\n\t\t\t.toArray()\n\t\t\t.order(Ints.compare)\n\t\t\t.map(function(i) return items.get(i))\n\t\t\t.map(function(ref) {\n\t\t\t\tif(ref.hasValue())\n\t\t\t\t\tres.push(ref.get());\n\t\t\t});\n\t\treturn res;\n\t}\n\n\tpublic function set(value : Dynamic) {\n\t\tif(!Std.is(value, Array)) throw 'value \"$value\" is not an array';\n\n\t\t(value : Array<Dynamic>).mapi(function(v, i) {\n\t\t\tvar ref = items.get(i);\n\t\t\tif(null == ref) {\n\t\t\t\titems.set(i, ref = Ref.fromValue(v, this));\n\t\t\t\tinverse.set(ref, i);\n\t\t\t} else {\n\t\t\t\tref.set(v);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic function remove() {\n\t\tfor(ref in items) {\n\t\t\tref.remove();\n\t\t}\n\t\tparent.removeChild(this);\n\t}\n\n\tpublic function removeChild(child : IRef) : Void {\n\t\tvar i = inverse.get(child);\n\t\tif(null == i) throw '\"$child\" is not child of \"$this\"';\n\t\titems.remove(i);\n\t\tinverse.remove(child);\n\t}\n\n\tpublic function hasValue() {\n\t\tfor(ref in items)\n\t\t\tif(ref.hasValue())\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tpublic function resolve(path : String, terminal : Bool = true) : IRef {\n\t\tif(path == \"\") return this;\n\t\tif(!Ref.reIndex.match(path))\n\t\t\tthrow 'unable to resolve \"$path\" for ArrayRef';\n\t\tvar index = Std.parseInt(Ref.reIndex.matched(1)),\n\t\t\trest  = Ref.reIndex.matchedRight(),\n\t\t\tref   = items.get(index);\n\t\tif(null == ref) {\n\t\t\titems.set(index, ref = Ref.fromPath(rest, this, terminal));\n\t\t\tinverse.set(ref, index);\n\t\t}\n\t\treturn ref.resolve(rest, terminal);\n\t}\n}","package thx.ref;\n\nusing thx.core.Iterators;\nusing thx.core.Iterables;\nimport thx.core.Types;\n\nclass ObjectRef extends BaseRef implements IRef implements IParentRef {\n\tvar fields : Map<String, IRef>;\n\tvar inverse : Map<IRef, String>;\n\n\tpublic function new(?parent : IParentRef) {\n\t\tsuper(parent);\n\t\tfields = new Map();\n\t\tinverse = new Map();\n\t}\n\n\tpublic function get() : Dynamic {\n\t\tvar o = {};\n\t\tfields.keys().map(function(key) {\n\t\t\tvar ref = fields.get(key);\n\t\t\tif(!ref.hasValue()) return;\n\t\t\tReflect.setField(o, key, ref.get());\n\t\t});\n\t\treturn o;\n\t}\n\n\tpublic function set(obj : Dynamic) {\n\t\tif(!Types.isAnonymousObject(obj)) throw 'object \"$obj\" is not an anonymous object';\n\t\tReflect.fields(obj).map(function(field) {\n\t\t\tvar ref   = fields.get(field),\n\t\t\t\tvalue = Reflect.field(obj, field);\n\t\t\tif(null == ref) {\n\t\t\t\tref = Ref.fromValue(value, this);\n\t\t\t\tfields.set(field, ref);\n\t\t\t\tinverse.set(ref, field);\n\t\t\t} else {\n\t\t\t\tref.set(value);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic function hasValue() {\n\t\tfor(ref in fields)\n\t\t\tif(ref.hasValue())\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tpublic function remove() {\n\t\tfields.map(function(ref) ref.remove());\n\t\tparent.removeChild(this);\n\t}\n\n\tpublic function removeChild(child : IRef) {\n\t\tvar key = inverse.get(child);\n\t\tif(null == key) throw '\"$child\" is not child of \"$this\"';\n\t\tinverse.remove(child);\n\t\tfields.remove(key);\n\t}\n\n\tpublic function resolve(path : String, terminal : Bool = true) : IRef {\n\t\tif(path == \"\") return this;\n\t\tif(!Ref.reField.match(path))\n\t\t\tthrow 'unable to resolve \"$path\" for ObjectRef';\n\t\tvar field = Ref.reField.matched(1),\n\t\t\trest  = Ref.reField.matchedRight(),\n\t\t\tref   = fields.get(field);\n\t\tif(null == ref) {\n\t\t\tfields.set(field, ref = Ref.fromPath(rest, this, terminal));\n\t\t\tinverse.set(ref, field);\n\t\t}\n\t\treturn ref.resolve(rest, terminal);\n\t}\n}","package thx.ref;\n\nusing thx.core.Types;\n\nclass Ref {\n\tpublic static function fromValue(value : Dynamic, ?parent : IParentRef) : IRef {\n\t\tif(null == parent)\n\t\t\tparent = BaseRef.EmptyParent.instance;\n\t\tvar ref : IRef = if(Std.is(value, Array)) {\n\t\t\t\tnew ArrayRef(parent);\n\t\t\t} else if(Types.isAnonymousObject(value)) {\n\t\t\t\tnew ObjectRef(parent);\n\t\t\t} else {\n\t\t\t\tnew ValueRef(parent);\n\t\t\t}\n\t\tref.set(value);\n\t\treturn ref;\n\t}\n\n\tpublic static var reField = ~/^\\.?([^.\\[]+)/;\n\tpublic static var reIndex = ~/^\\[(\\d+)\\]/;\n\tpublic static function fromPath(path : String, ?parent : IParentRef, terminal : Bool = true) : IRef {\n\t\tif(null == parent)\n\t\t\tparent = BaseRef.EmptyParent.instance;\n\t\tif(path == \"\") {\n\t\t\treturn terminal ? new ValueRef(parent) : new UnknownRef(parent);\n\t\t} else if(reField.match(path)) {\n\t\t\treturn new ObjectRef(parent);\n\t\t} else if(reIndex.match(path)) {\n\t\t\treturn new ArrayRef(parent);\n\t\t} else {\n\t\t\treturn throw 'invalid path \"$path\"';\n\t\t}\n\t}\n\n\tpublic static function resolvePath(path : String, ?parent : IParentRef, terminal : Bool = true) : IRef {\n\t\tvar ref = fromPath(path, parent, terminal);\n\t\treturn ref.resolve(path);\n\t}\n}","package thx.ref;\n\nusing thx.core.Objects;\nusing thx.core.Arrays;\n\nclass UnknownRef extends BaseRef implements IRef implements IParentRef {\n\tpublic var ref(default, null) : Null<IRef>;\n\tvar hasRef : Bool = false;\n\n\tpublic function get()\n\t\treturn hasRef ? ref.get() : null;\n\n\tpublic function set(value : Dynamic) {\n\t\tif(hasRef)\n\t\t\tref.set(value);\n\t\telse {\n\t\t\thasRef = true;\n\t\t\tref = Ref.fromValue(value, this);\n\t\t}\n\t}\n\n\tpublic function remove() : Void {\n\t\tif(hasRef)\n\t\t\tref.remove();\n\t\tparent.removeChild(this);\n\t}\n\n\tpublic function removeChild(child : IRef) : Void {\n\t\tif(hasRef) {\n\t\t\tref = null;\n\t\t\thasRef = false;\n\t\t}\n\t}\n\n\tpublic function hasValue() : Bool\n\t\treturn hasRef && ref.hasValue();\n\n\tpublic function resolve(path : String, terminal : Bool = true) : IRef {\n\t\tif(hasRef)\n\t\t\treturn ref.resolve(path, terminal);\n\t\tif(path == \"\")\n\t\t\treturn this;\n\t\thasRef = true;\n\t\tref = Ref.fromPath(path, this, terminal);\n\t\treturn ref.resolve(path, terminal);\n\t}\n}","package thx.ref;\n\nusing thx.core.Objects;\nusing thx.core.Arrays;\n\nclass ValueRef extends BaseRef implements IRef {\n\tvar _hasValue : Bool = false;\n\tvar value : Dynamic;\n\n\tpublic function get()\n\t\treturn value;\n\n\tpublic function set(value : Dynamic) {\n\t\tthis.value = value;\n\t\t_hasValue = true;\n\t}\n\n\tpublic function remove() : Void {\n\t\tvalue = null;\n\t\t_hasValue = false;\n\t\tparent.removeChild(this);\n\t}\n\n\tpublic function hasValue() : Bool\n\t\treturn _hasValue;\n\n\tpublic function resolve(path : String, terminal : Bool = true) : IRef {\n\t\tif(path != \"\") throw 'unable to resolve path \"$path\" on ValueRef';\n\t\treturn this;\n\t}\n}","package ui;\n\nimport js.html.Event;\nimport steamer.Producer;\nimport steamer.Value;\nimport sui.components.Component;\nusing steamer.dom.Dom;\nusing steamer.Consumer;\n\nclass Button {\n\tpublic var component(default, null) : Component;\n\tpublic var clicks(default, null) : Producer<Event>;\n\tpublic var enabled(default, null) : Value<Bool>;\n\tvar cancel : Void -> Void;\n\tpublic function new(text = '', ?icon : String) {\n\t\tcomponent = new Component({\n\t\t\ttemplate : null == icon\n\t\t\t\t? '<button>$text</button>'\n\t\t\t\t: '<button class=\"fa fa-$icon\">$text</button>'\n\t\t});\n\t\tvar pair = component.el.produceEvent('click');\n\t\tclicks = pair.producer;\n\t\tcancel = pair.cancel;\n\n\t\tenabled = new Value(true);\n\t\tenabled.feed(function(value : Bool) {\n\t\t\tif(value)\n\t\t\t\tcomponent.el.removeAttribute(\"disabled\");\n\t\t\telse\n\t\t\t\tcomponent.el.setAttribute(\"disabled\", \"disabled\");\n\t\t}.toConsumer());\n\t}\n\n\tpublic function destroy() {\n\t\tcancel();\n\t\tcomponent.destroy();\n\t}\n}","package ui;\n\nimport js.html.Element;\nimport sui.components.Component;\nimport dom.Dom;\n\nclass Card {\n\tpublic static function create(model : Model, schema : Schema, container : Element) {\n\t\tvar card    = new Component({\n\t\t\t\t\t\ttemplate : '<div class=\"card\"><div class=\"doc\"></div><aside><div class=\"context\"></div><div class=\"model\"></div></aside></div>'\n\t\t\t\t\t}),\n\t\t\t//doc     = Doc.create({ el : Query.first('.doc', card.el) }),\n\t\t\tcontext = Query.first('.context', card.el),\n\t\t\tmodelView = new ModelView();\n\n\t\tmodelView.component.appendTo(Query.first('.model', card.el));\n\n\t\tcard.appendTo(container);\n\t}\n}","package ui;\n\nimport haxe.Json;\nusing thx.core.Arrays;\nusing thx.core.Iterators;\nusing thx.core.Strings;\nimport steamer.Producer;\nimport steamer.Pulse;\nimport thx.ref.ObjectRef;\nimport thx.ref.IRef;\n\nclass Data {\n\tvar root : ObjectRef;\n\tvar cache : Map<String, IRef>;\n\tvar feed : Pulse<{}> -> Void;\n\n\tpublic var stream(default, null) : Producer<{}>;\n\n\tpublic function new(data : {}) {\n\t\tthis.feed = function(p){};\n\t\tstream = new Producer(function(feed) {\n\t\t\tthis.feed = feed;\n\t\t});\n\t\treset(data);\n\t}\n\n\tfunction resolve(path : String) {\n\t\tvar ref = cache.get(path);\n\t\tif(null == ref) {\n\t\t\tref = root.resolve(path);\n\t\t\tif(ref.hasValue())\n\t\t\t\tcache.set(path, ref);\n\t\t}\n\t\treturn ref;\n\t}\n\n\tpublic function get(path : String) : Dynamic {\n\t\treturn resolve(path).get();\n\t}\n\n\tpublic function hasValue(path : String) : Bool {\n\t\treturn resolve(path).hasValue();\n\t}\n\n\tpublic function set(path : String, value : Dynamic) : Data {\n\t\tvar ref = resolve(path);\n\t\tcache.set(path, ref);\n\t\tif(ref.get() != value) {\n\t\t\tref.set(value);\n\t\t\tfeed(Emit(toObject()));\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic function reset(value : Dynamic) : Data {\n\t\troot = new ObjectRef(null);\n\t\tcache = new Map();\n\t\tif(null != value) {\n\t\t\tset(\"\", value);\n\t\t}\n\t\tfeed(Emit(toObject()));\n\t\treturn this;\n\t}\n\n\tpublic function remove(path : String) {\n\t\tvar ref = cache.get(path);\n\t\tif(null == ref) {\n\t\t\tref = root.resolve(path);\n\t\t}\n\n\t\tif(ref.hasValue()) {\n\t\t\tref.remove();\n\t\t\tfeed(Emit(toObject()));\n\t\t}\n\t\tcache.remove(path);\n\t}\n\n\tpublic function rename(oldpath : String, newpath : String) {\n\t\tif(!hasValue(oldpath) || hasValue(newpath))\n\t\t\treturn false;\n\t\tvar v = get(oldpath);\n\t\tremove(oldpath);\n\t\tset(newpath, v);\n\t\tfeed(Emit(toObject()));\n\t\treturn true;\n\t}\n\n\tpublic function toObject() : {} {\n\t\treturn root.get();\n\t}\n\n\tpublic function toJSON()\n\t\treturn Json.stringify(toObject());\n}","package ui;\n\nimport steamer.Producer;\nimport sui.components.Component;\nimport dom.Dom;\nimport sui.components.ComponentOptions;\nimport ui.TextEditor;\n\nclass Field {\n\tpublic var component(default, null) : Component;\n\tpublic var key(default, null) : TextEditor;\n\tpublic var value(default, null) : TextEditor;\n\tpublic var focus(default, null) : Producer<Bool>;\n\n\tpublic function new(options : FieldOptions) {\n\t\tif(null == options.template && null == options.el)\n\t\t\toptions.template = '<div class=\"field\"><div class=\"key\"></div><div class=\"value\"></div></div>';\n\n\t\tcomponent = new Component(options);\n\t\t// setup field key\n\t\tkey = new TextEditor({\n\t\t\tel : Query.first('.key', component.el),\n\t\t\tparent : component,\n\t\t\tdefaultText : options.key\n\t\t});\n\n\t\t// setup field value\n\t\t// TODO support multiple editors data types\n\t\tvalue = new TextEditor({\n\t\t\tel : Query.first('.value', component.el),\n\t\t\tparent : component,\n\t\t\tdefaultText : ''\n\t\t});\n\n\t\tfocus = key.focus.merge(value.focus).debounce(20).distinct();\n\t}\n}\n\ntypedef FieldOptions = {>ComponentOptions,\n\tkey : String\n}","package ui;\n\nimport steamer.Producer;\nimport steamer.Pulse;\nimport ui.Schema;\n\nclass Model {\n\tpublic var data(default, null) : Data;\n\tpublic var schema(default, null) : Schema;\n\tpublic var changes(default, null) : Producer<ModelChange>;\n\tpublic var keys(get, null) : Array<String>;\n\n\tpublic function new(data : Data) {\n\t\tthis.data = data;\n\t\tthis.schema = new Schema();\n\t\tthis.changes = new Producer(function(feed) {\n\t\t\tdata.stream.feed({\n\t\t\t\tonPulse : function(p : Pulse<{}>) {\n\t\t\t\t\tswitch(p) {\n\t\t\t\t\t\tcase Emit(o):\n\n\t\t\t\t\t\tcase Fail(e):\n\t\t\t\t\t\t\tfeed(Fail(e));\n\t\t\t\t\t\tcase End:\n\t\t\t\t\t\t\tfeed(End);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t});\n\t\t\tschema.stream.feed({\n\t\t\t\tonPulse : function(p : Pulse<SchemaEvent>) {\n\t\t\t\t\tswitch(p) {\n\t\t\t\t\t\tcase Emit(e):\n\t\t\t\t\t\t\tswitch(e) {\n\t\t\t\t\t\t\t\tcase ListFields(list):\n\n\t\t\t\t\t\t\t\tcase AddField(name, type):\n\n\t\t\t\t\t\t\t\tcase DeleteField(name):\n\n\t\t\t\t\t\t\t\tcase RenameField(oldname, newname):\n\n\t\t\t\t\t\t\t\tcase _:\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase Fail(e):\n\t\t\t\t\t\t\tfeed(Fail(e));\n\t\t\t\t\t\tcase End:\n\t\t\t\t\t\t\tfeed(End);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction get_keys() {\n\t\treturn [];\n\t}\n\n}\n\nenum ModelChange {\n\n}","package ui;\n\nimport js.html.Element;\nusing steamer.Consumer;\nusing steamer.dom.Dom;\nimport steamer.MultiProducer;\nimport steamer.Producer;\nimport steamer.Pulse;\nimport sui.components.Component;\nimport sui.properties.Attribute;\nimport sui.properties.Text;\nimport ui.DataEvent;\nimport ui.SchemaEvent;\nimport ui.SchemaType;\nimport ui.TextEditor;\n\nclass ModelView {\n\tpublic var component(default, null) : Component;\n\tpublic var schema(default, null) : Producer<SchemaEvent>;\n\tpublic var data(default, null) : Producer<DataEvent>;\n\tpublic var toolbar(default, null) : Toolbar;\n\tpublic var currentField(default, null) : Null<Field>;\n\n\tvar feedSchema : Pulse<SchemaEvent> -> Void;\n\tvar feedData : Pulse<DataEvent> -> Void;\n\tvar fields : Map<String, Field>;\n\tvar fieldFocus : MultiProducer<Field>;\n\tvar fieldBlur : MultiProducer<Field>;\n\n\tpublic function new() {\n\t\tcomponent = new Component({\n\t\t\ttemplate : '<div class=\"modelview\"></div>'\n\t\t});\n\t\ttoolbar = new Toolbar();\n\t\ttoolbar.component.appendTo(component.el);\n\n\t\tvar buttonAdd = new Button('', 'plus');\n\t\tbuttonAdd.component.appendTo(toolbar.left);\n\t\tbuttonAdd.clicks.feed(function(_){\n\t\t\taddField(guessFieldName(), StringType);\n\t\t}.toConsumer());\n\n\t\tvar buttonRemove = new Button('', 'minus');\n\t\tbuttonRemove.component.appendTo(toolbar.right);\n\t\tbuttonRemove.clicks.feed(function(_) {\n\t\t\ttrace('remove');\n\t\t}.toConsumer());\n\t\tbuttonRemove.enabled.value = false;\n\n\n\t\tthis.feedSchema = function(_) {};\n\t\tschema = new Producer(function(feed) {\n\t\t\tthis.feedSchema = feed;\n\t\t});\n\n\t\tthis.feedData = function(_) {};\n\t\tdata = new Producer(function(feed) {\n\t\t\tthis.feedData = feed;\n\t\t});\n\n\t\tfields = new Map();\n\n\t\tfieldFocus = new MultiProducer();\n\t\tfieldFocus.feed(function(field) {\n\t\t\tthis.currentField = field;\n\t\t\tbuttonRemove.enabled.value = null != field;\n\t\t}.toConsumer());\n\t}\n\n\tpublic function guessFieldName() {\n\t\tvar id = 0,\n\t\t\tprefix = 'field',\n\t\t\tt;\n\t\tfunction assemble(id)\n\t\t\treturn id > 0 ? [prefix, '$id'].join('_') : prefix;\n\t\twhile(fields.exists(t = assemble(id))) id++;\n\t\treturn t;\n\t}\n\n\tpublic function addField(name : String, type : SchemaType) {\n\t\tvar field = new Field({\n\t\t\tcontainer : component.el,\n\t\t\tparent : component,\n\t\t\tkey : name\n\t\t});\n\n\t\t// setup field key\n\t\tvar oldname = null;\n\n\t\tfield.key.text\n\t\t\t.filter(function(newname : String) {\n\t\t\t\t// check that it doesn't exist already\n\t\t\t\tif(fields.exists(newname)) {\n\t\t\t\t\t// if exists revert and don't propagate\n\t\t\t\t\tfield.key.text.value = oldname;\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.map(function(newname : String) {\n\t\t\t\t// rename field name in fields\n\t\t\t\tif(null != oldname) {\n\t\t\t\t\tvar v = fields.get(oldname);\n\t\t\t\t\tfields.remove(oldname);\n\t\t\t\t\tfields.set(newname, v);\n\t\t\t\t}\n\t\t\t\tvar r = RenameField(oldname, newname);\n\t\t\t\toldname = newname;\n\t\t\t\treturn r;\n\t\t\t})\n\t\t\t.feed(Bus.feed(feedSchema));\n\n\t\t// setup field value\n\t\t// TODO support multiple editors data types\n\t\tfield.value.text.map(function(text : String) {\n\t\t\treturn SetStringValue(field.value.text.value, text);\n\t\t}).feed(Bus.feed(feedData));\n\t\tfieldFocus.add(field.focus.map(function(v) return v ? field : null));\n\n\t\tfields.set(name, field);\n\t}\n}","package ui;\n\nimport steamer.Consumer;\nimport steamer.Producer;\nimport steamer.Pulse;\nimport thx.Error;\nimport ui.SchemaEvent;\nimport ui.SchemaType;\n\nclass Schema {\n\tvar fields : Map<String, SchemaType>;\n\tpublic var stream(default, null) : SchemaProducer;\n\tvar feed : Pulse<SchemaEvent> -> Void;\n\n\tpublic function new() {\n\t\tfields = new Map();\n\t\tstream = new SchemaProducer(getPairs, function(feed : Pulse<SchemaEvent> -> Void) {\n\t\t\tthis.feed = feed;\n\t\t});\n\t}\n\n\tpublic function add(name : String, type : SchemaType) {\n\t\tif(fields.exists(name))\n\t\t\tthrow new Error('Schema already contains a field \"$name\"');\n\t\tfields.set(name, type);\n\t\tfeed(Emit(AddField(name, type)));\n\t}\n\n\tpublic function reset(?list : Array<FieldPair>) {\n\t\tif(null == list)\n\t\t\tlist = [];\n\t\tfields = new Map();\n\t\tlist.map(function(pair) {\n\t\t\tfields.set(pair.name, pair.type);\n\t\t});\n\t\tfeed(Emit(ListFields(list.copy())));\n\t}\n\n\tpublic function delete(name : String) {\n\t\tif(!fields.exists(name))\n\t\t\tthrow new Error('Schema does not contain a field \"${name}\"');\n\t\tfields.remove(name);\n\t\tfeed(Emit(DeleteField(name)));\n\t}\n\n\tpublic function rename(oldname : String, newname : String) {\n\t\tif(!fields.exists(oldname))\n\t\t\tthrow new Error('Schema does not contain a field \"${oldname}\"');\n\t\tvar type = fields.get(oldname);\n\t\tfields.remove(oldname);\n\t\tfields.set(newname, type);\n\t\tfeed(Emit(RenameField(oldname, newname)));\n\t}\n\n\tpublic function retype(name : String, type : SchemaType) {\n\t\tif(!fields.exists(name))\n\t\t\tthrow new Error('Schema does not contain a field \"${name}\"');\n\t\tfields.set(name, type);\n\t\tfeed(Emit(RetypeField(name, type)));\n\t}\n\n\tpublic function get(name : String) {\n\t\treturn fields.get(name);\n\t}\n\n\tpublic function exists(name : String) {\n\t\treturn fields.exists(name);\n\t}\n\n\tpublic function getFieldNames() {\n\t\tvar arr = [];\n\t\tfor(key in fields.keys())\n\t\t\tarr.push(key);\n\t\treturn arr;\n\t}\n\n\tpublic function getPairs() {\n\t\treturn getFieldNames().map(function(key) {\n\t\t\treturn {\n\t\t\t\tname : key,\n\t\t\t\ttype : fields.get(key)\n\t\t\t};\n\t\t});\n\t}\n}\n\nclass SchemaProducer extends Producer<SchemaEvent> {\n\tvar getPairs : Void -> Array<FieldPair>;\n\tpublic function new(getPairs : Void -> Array<FieldPair>, handler : (Pulse<SchemaEvent> -> Void) -> Void) {\n\t\tthis.getPairs = getPairs;\n\t\tsuper(handler, false);\n\t}\n\n\toverride function feed(consumer : Consumer<SchemaEvent>) {\n\t\tsuper.feed(consumer);\n\t\tconsumer.onPulse(Emit(ListFields(getPairs())));\n\t}\n}\n\n/*\nlocations[0].city = \"Milano\"\nlocations : ArrayType<ObjectType>\nlocations.city : StringType\n\naddress = { city : \"Milano\" }\n\naddress : ObjectType\naddress.city : StringType\n*/","package ui;\n\nimport steamer.Producer;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport steamer.Value;\nimport sui.properties.Text;\nusing steamer.dom.Dom;\n\nclass TextEditor {\n\tpublic var component(default, null) : Component;\n\tpublic var text(default, null) : Value<String>;\n\tpublic var focus(default, null) : Producer<Bool>;\n\tvar cancel : Void -> Void;\n\tpublic function new(options : TextEditorOptions) {\n\t\tif(null == options.defaultText)\n\t\t\toptions.defaultText = '';\n\t\tif(null == options.el && null == options.template)\n\t\t\toptions.template = '<span></span>';\n\t\tcomponent = new Component(options);\n\t\tcomponent.el.setAttribute('contenteditable', cast true);\n\n\t\tvar text      = new Text(component, options.defaultText),\n\t\t\tinputPair = component.el.produceEvent('input'),\n\t\t\tfocusPair = component.el.produceEvent('focus'),\n\t\t\tblurPair  = component.el.produceEvent('blur');\n\n\t\tthis.text = text.text;\n\t\tinputPair.producer\n\t\t\t.map(function(_) return text.component.el.textContent)\n\t\t\t.feed(this.text);\n\n\t\tfocus = focusPair.producer\n\t\t\t.map(function(_) return true)\n\t\t\t.merge(\n\t\t\t\tblurPair.producer\n\t\t\t\t\t.map(function(_) return false)\n\t\t\t);\n\t\tcancel = function() {\n\t\t\ttext.dispose();\n\t\t\tinputPair.cancel();\n\t\t\tfocusPair.cancel();\n\t\t\tblurPair.cancel();\n\t\t};\n\t}\n\n\tpublic function destroy() {\n\t\ttext.terminate();\n\t\tcomponent.destroy();\n\t\tcancel();\n\t}\n}\n\ntypedef TextEditorOptions = {> ComponentOptions,\n\tdefaultText : String\n}","package ui;\n\nimport dom.Dom;\nimport js.html.Element;\nimport sui.components.Component;\n\nclass Toolbar {\n\tpublic var component(default, null) : Component;\n\tpublic var left(default, null) : Element;\n\tpublic var center(default, null) : Element;\n\tpublic var right(default, null) : Element;\n\tpublic function new() {\n\t\tcomponent = new Component({\n\t\t\ttemplate : '<header class=\"toolbar\"><div class=\"left\"></div><div class=\"center\"></div><div class=\"right\"></div></header>'\n\t\t});\n\t\tleft   = Query.first('.left', component.el);\n\t\tcenter = Query.first('.center', component.el);\n\t\tright  = Query.first('.right', component.el);\n\t}\n}"],
"names":[],
"mappings":"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"
}