{
"version":3,
"file":"app.js",
"sourceRoot":"file:///",
"sources":["/usr/local/Cellar/haxe/HEAD/lib/haxe/std/DateTools.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/js/_std/EReg.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/js/_std/HxOverrides.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/Lambda.hx","/Users/francoponticelli/projects/cards/src/Main.hx","/Users/francoponticelli/projects/cards/src/PropertyFeeder.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/js/_std/Reflect.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/js/_std/Std.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/StringBuf.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/StringTools.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/js/_std/Type.hx","/Users/francoponticelli/projects/cards/src/cards/components/Component.hx","/Users/francoponticelli/projects/cards/src/cards/components/Properties.hx","/Users/francoponticelli/projects/cards/src/cards/model/Data.hx","/Users/francoponticelli/projects/cards/src/cards/model/Expression.hx","/Users/francoponticelli/projects/cards/src/cards/model/Model.hx","/Users/francoponticelli/projects/cards/src/cards/model/Runtime.hx","/Users/francoponticelli/projects/cards/src/cards/model/Schema.hx","/Users/francoponticelli/projects/cards/src/cards/model/Scope.hx","/Users/francoponticelli/projects/cards/src/cards/model/ref/BaseRef.hx","/Users/francoponticelli/projects/cards/src/cards/model/ref/ArrayRef.hx","/Users/francoponticelli/projects/cards/src/cards/model/ref/ObjectRef.hx","/Users/francoponticelli/projects/cards/src/cards/model/ref/Ref.hx","/Users/francoponticelli/projects/cards/src/cards/model/ref/UnknownRef.hx","/Users/francoponticelli/projects/cards/src/cards/model/ref/ValueRef.hx","/Users/francoponticelli/projects/cards/src/cards/properties/Property.hx","/Users/francoponticelli/projects/cards/src/cards/properties/ValueProperty.hx","/Users/francoponticelli/projects/cards/src/cards/properties/BoolProperty.hx","/Users/francoponticelli/projects/cards/src/cards/properties/PropertyName.hx","/Users/francoponticelli/projects/cards/src/cards/properties/StringProperty.hx","/Users/francoponticelli/projects/cards/src/cards/properties/Text.hx","/Users/francoponticelli/projects/cards/src/cards/properties/ToggleClass.hx","/Users/francoponticelli/projects/cards/src/cards/properties/ValueProperties.hx","/Users/francoponticelli/projects/cards/src/cards/properties/Visible.hx","/Users/francoponticelli/projects/cards/src/cards/types/ArrayTransform.hx","/Users/francoponticelli/projects/cards/src/cards/types/BoolTransform.hx","/Users/francoponticelli/projects/cards/src/cards/types/CodeTransform.hx","/Users/francoponticelli/projects/cards/src/cards/types/DateTransform.hx","/Users/francoponticelli/projects/cards/src/cards/types/DynamicTransform.hx","/Users/francoponticelli/projects/cards/src/cards/types/FloatTransform.hx","/Users/francoponticelli/projects/cards/src/cards/types/ObjectTransform.hx","/Users/francoponticelli/projects/cards/src/cards/types/ReferenceTransform.hx","/Users/francoponticelli/projects/cards/src/cards/types/StringTransform.hx","/Users/francoponticelli/projects/cards/src/cards/types/TypeTransform.hx","/Users/francoponticelli/projects/cards/src/cards/ui/Article.hx","/Users/francoponticelli/projects/cards/src/cards/ui/Card.hx","/Users/francoponticelli/projects/cards/src/cards/ui/ContextView.hx","/Users/francoponticelli/projects/cards/src/cards/ui/Document.hx","/Users/francoponticelli/projects/cards/src/cards/ui/ModelView.hx","/Users/francoponticelli/projects/cards/src/cards/ui/editors/TextEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/fragments/Block.hx","/Users/francoponticelli/projects/cards/src/cards/ui/fragments/FragmentMapper.hx","/Users/francoponticelli/projects/cards/src/cards/ui/fragments/FragmentName.hx","/Users/francoponticelli/projects/cards/src/cards/ui/fragments/FragmentProperties.hx","/Users/francoponticelli/projects/cards/src/cards/ui/fragments/InlineText.hx","/Users/francoponticelli/projects/cards/src/cards/ui/fragments/ReadonlyBlock.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/Editor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/RouteEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/BaseObjectEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/AnonymousObjectEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/ArrayEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/BoolEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/CodeMirrorEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/DateEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/DiffAt.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/EditorFactory.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/InputBasedEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/FieldNameEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/NumberEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/ObjectEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/Path.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/ReferenceEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/RuntimeObjectEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/TextEditor.hx","/Users/francoponticelli/projects/cards/src/cards/ui/input/TypedValue.hx","/Users/francoponticelli/projects/cards/src/cards/ui/widgets/Button.hx","/Users/francoponticelli/projects/cards/src/cards/ui/widgets/FrameOverlay.hx","/Users/francoponticelli/projects/cards/src/cards/ui/widgets/Menu.hx","/Users/francoponticelli/projects/cards/src/cards/ui/widgets/Statusbar.hx","/Users/francoponticelli/projects/cards/src/cards/ui/widgets/Toolbar.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/haxe/CallStack.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/haxe/Log.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/js/_std/haxe/ds/IntMap.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/js/_std/haxe/ds/ObjectMap.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/js/_std/haxe/ds/StringMap.hx","/usr/local/Cellar/haxe/HEAD/lib/haxe/std/js/Boot.hx","/Users/francoponticelli/projects/thx.core/src/thx/Arrays.hx","/Users/francoponticelli/projects/thx.core/src/thx/Dynamics.hx","/Users/francoponticelli/projects/thx.core/src/thx/Error.hx","/Users/francoponticelli/projects/thx.core/src/thx/Functions.hx","/Users/francoponticelli/projects/thx.core/src/thx/Ints.hx","/Users/francoponticelli/projects/thx.core/src/thx/Iterables.hx","/Users/francoponticelli/projects/thx.core/src/thx/Iterators.hx","/Users/francoponticelli/projects/thx.core/src/thx/Maps.hx","/Users/francoponticelli/projects/thx.core/src/thx/Objects.hx","/Users/francoponticelli/projects/thx.core/src/thx/Options.hx","/Users/francoponticelli/projects/thx.core/src/thx/Result.hx","/Users/francoponticelli/projects/thx.core/src/thx/Set.hx","/Users/francoponticelli/projects/thx.core/src/thx/Strings.hx","/Users/francoponticelli/projects/thx.core/src/thx/Timer.hx","/Users/francoponticelli/projects/thx.core/src/thx/Tuple.hx","/Users/francoponticelli/projects/thx.core/src/thx/Types.hx","/Users/francoponticelli/projects/thx.core/src/thx/Uuid.hx","/Users/francoponticelli/projects/thx.core/src/thx/error/ErrorWrapper.hx","/Users/francoponticelli/projects/thx.promise/src/thx/promise/Future.hx","/Users/francoponticelli/projects/thx.promise/src/thx/promise/Promise.hx","/Users/francoponticelli/projects/thx.promise/src/thx/promise/Timer.hx","/Users/francoponticelli/projects/thx.stream/src/thx/stream/Emitter.hx","/Users/francoponticelli/projects/thx.stream/src/thx/stream/Bus.hx","/Users/francoponticelli/projects/thx.stream/src/thx/stream/Stream.hx","/Users/francoponticelli/projects/thx.stream/src/thx/stream/Value.hx","/Users/francoponticelli/projects/thx.stream.dom/src/thx/stream/dom/Dom.hx","/Users/francoponticelli/projects/cards/src/udom/Dom.hx","/Users/francoponticelli/projects/cards/src/Config.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tThe DateTools class contains some extra functionalities for handling `Date`\n\tinstances and timestamps.\n\n\tIn the context of haxe dates, a timestamp is defined as the number of\n\tmilliseconds elapsed since 1st January 1970.\n**/\nclass DateTools {\n\n\t#if php\n\t#elseif (neko && !(macro || interp))\n\tstatic var date_format = neko.Lib.load(\"std\",\"date_format\",2);\n\t#else\n\tprivate static function __format_get( d : Date, e : String ) : String {\n\t\treturn switch( e ){\n\t\t\tcase \"%\":\n\t\t\t\t\"%\";\n\t\t\tcase \"C\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(Std.int(d.getFullYear()/100)),\"0\",2);\n\t\t\tcase \"d\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getDate()),\"0\",2);\n\t\t\tcase \"D\":\n\t\t\t\t__format(d,\"%m/%d/%y\");\n\t\t\tcase \"e\":\n\t\t\t\tuntyped Std.string(d.getDate());\n\t\t\tcase \"F\":\n\t\t\t\t__format(d,\"%Y-%m-%d\");\n\t\t\tcase \"H\",\"k\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getHours()),if( e == \"H\" ) \"0\" else \" \",2);\n\t\t\tcase \"I\",\"l\":\n\t\t\t\tvar hour = d.getHours()%12;\n\t\t\t\tuntyped StringTools.lpad(Std.string(hour == 0 ? 12 : hour),if( e == \"I\" ) \"0\" else \" \",2);\n\t\t\tcase \"m\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getMonth()+1),\"0\",2);\n\t\t\tcase \"M\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getMinutes()),\"0\",2);\n\t\t\tcase \"n\":\n\t\t\t\t\"\\n\";\n\t\t\tcase \"p\":\n\t\t\t\tuntyped if( d.getHours() > 11 ) \"PM\"; else \"AM\";\n\t\t\tcase \"r\":\n\t\t\t\t__format(d,\"%I:%M:%S %p\");\n\t\t\tcase \"R\":\n\t\t\t\t__format(d,\"%H:%M\");\n\t\t\tcase \"s\":\n\t\t\t\tStd.string(Std.int(d.getTime()/1000));\n\t\t\tcase \"S\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getSeconds()),\"0\",2);\n\t\t\tcase \"t\":\n\t\t\t\t\"\\t\";\n\t\t\tcase \"T\":\n\t\t\t\t__format(d,\"%H:%M:%S\");\n\t\t\tcase \"u\":\n\t\t\t\tuntyped{\n\t\t\t\t\tvar t = d.getDay();\n\t\t\t\t\tif( t == 0 ) \"7\"; else Std.string(t);\n\t\t\t\t}\n\t\t\tcase \"w\":\n\t\t\t\tuntyped Std.string(d.getDay());\n\t\t\tcase \"y\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getFullYear()%100),\"0\",2);\n\t\t\tcase \"Y\":\n\t\t\t\tuntyped Std.string(d.getFullYear());\n\t\t\tdefault:\n\t\t\t\tthrow \"Date.format %\"+e+\"- not implemented yet.\";\n\t\t}\n\t}\n\n\tprivate static function __format( d : Date, f : String ) : String {\n\t\tvar r = new StringBuf();\n\t\tvar p = 0;\n\t\twhile( true ){\n\t\t\tvar np = f.indexOf(\"%\", p);\n\t\t\tif( np < 0 )\n\t\t\t\tbreak;\n\n\t\t\tr.addSub(f,p,np-p);\n\t\t\tr.add( __format_get(d, f.substr(np+1,1) ) );\n\n\t\t\tp = np+2;\n\t\t}\n\t\tr.addSub(f,p,f.length-p);\n\t\treturn r.toString();\n\t}\n\t#end\n\n\t/**\n\t\tFormat the date `d` according to the format `f`. The format is\n\t\tcompatible with the `strftime` standard format, except that there is no\n\t\tsupport in Flash and JS for day and months names (due to lack of proper\n\t\tinternationalization API). On Haxe/Neko/Windows, some formats are not\n\t\tsupported.\n\t**/\n\tpublic static function format( d : Date, f : String ) : String {\n\t\t#if (neko && !(macro || interp))\n\t\t\treturn new String(untyped date_format(d.__t, f.__s));\n\t\t#elseif php\n\t\t\treturn untyped __call__(\"strftime\",f,d.__t);\n\t\t#else\n\t\t\treturn __format(d,f);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns the result of adding timestamp `t` to Date `d`.\n\n\t\tThis is a convenience function for calling\n\t\t`Date.fromTime(d.getTime() + t)`.\n\t**/\n\tpublic static inline function delta( d : Date, t : Float ) : Date {\n\t\treturn Date.fromTime( d.getTime() + t );\n\t}\n\n\tstatic var DAYS_OF_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n\t/**\n\t\tReturns the number of days in the month of Date `d`.\n\n\t\tThis method handles leap years.\n\t**/\n\tpublic static function getMonthDays( d : Date ) : Int {\n\t\tvar month = d.getMonth();\n\t\tvar year = d.getFullYear();\n\n\t\tif (month != 1)\n\t\t\treturn DAYS_OF_MONTH[month];\n\n\t\tvar isB = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n\t\treturn if (isB) 29 else 28;\n\t}\n\n\t/**\n\t\tConverts a number of seconds to a timestamp.\n\t**/\n\tpublic static inline function seconds( n : Float ) : Float {\n\t\treturn n * 1000.0;\n\t}\n\n\t/**\n\t\tConverts a number of minutes to a timestamp.\n\t**/\n\tpublic static inline function minutes( n : Float ) : Float {\n\t\treturn n * 60.0 * 1000.0;\n\t}\n\n\t/**\n\t\tConverts a number of hours to a timestamp.\n\t**/\n\tpublic static inline function hours( n : Float ) : Float {\n\t\treturn n * 60.0 * 60.0 * 1000.0;\n\t}\n\n\t/**\n\t\tConverts a number of days to a timestamp.\n\t**/\n\tpublic static inline function days( n : Float ) : Float {\n\t\treturn n * 24.0 * 60.0 * 60.0 * 1000.0;\n\t}\n\n\t/**\n\t\tSeparate a date-time into several components\n\t**/\n\tpublic static function parse( t : Float ) {\n\t\tvar s = t / 1000;\n\t\tvar m = s / 60;\n\t\tvar h = m / 60;\n\t\treturn {\n\t\t\tms : t % 1000,\n\t\t\tseconds : Std.int(s % 60),\n\t\t\tminutes : Std.int(m % 60),\n\t\t\thours : Std.int(h % 24),\n\t\t\tdays : Std.int(h / 24),\n\t\t};\n\t}\n\n\t/**\n\t\tBuild a date-time from several components\n\t**/\n\tpublic static function make( o : { ms : Float, seconds : Int, minutes : Int, hours : Int, days : Int } ) {\n\t\treturn o.ms + 1000.0 * (o.seconds + 60.0 * (o.minutes + 60.0 * (o.hours + 24.0 * o.days)));\n\t}\n\n\t#if (js || flash || php || cpp || python)\n\t/**\n\t\tRetrieve Unix timestamp value from Date components. Takes same argument sequence as the Date constructor.\n\t**/\n\tpublic static #if (js || flash || php) inline #end function makeUtc(year : Int, month : Int, day : Int, hour : Int, min : Int, sec : Int ):Float {\n\t    #if (js || flash || python)\n\t\t   return untyped Date.UTC(year, month, day, hour, min, sec);\n\t\t#elseif php\n\t\t   return untyped __call__(\"gmmktime\", hour, min, sec, month + 1, day, year) * 1000;\n\t\t#elseif cpp\n\t\t  return untyped __global__.__hxcpp_utc_date(year,month,day,hour,min,sec)*1000.0 ;\n\t\t#else\n\t\t\t//TODO\n\t\t   return 0.;\n\t\t#end\n\t}\n\t#end\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\n\tvar r : HaxeRegExp;\n\n\tpublic function new( r : String, opt : String ) : Void {\n\t\topt = opt.split(\"u\").join(\"\"); // 'u' (utf8) depends on page encoding\n\t\tthis.r = new HaxeRegExp(r, opt);\n\t}\n\n\tpublic function match( s : String ) : Bool {\n\t\tif( r.global ) r.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched( n : Int ) : String {\n\t\treturn if( r.m != null && n >= 0 && n < r.m.length ) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn r.s.substr(0,r.m.index);\n\t}\n\n\tpublic function matchedRight() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\tvar sz = r.m.index+r.m[0].length;\n\t\treturn r.s.substr(sz,r.s.length-sz);\n\t}\n\n\tpublic function matchedPos() : { pos : Int, len : Int } {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn { pos : r.m.index, len : r.m[0].length };\n\t}\n\n\tpublic function matchSub( s : String, pos : Int, len : Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match( len < 0 ? s.substr(pos) : s.substr(pos,len) );\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split( s : String ) : Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn untyped s.replace(r,d).split(d);\n\t}\n\n\tpublic function replace( s : String, by : String ) : String {\n\t\treturn untyped s.replace(r,by);\n\t}\n\n\tpublic function map( s : String, f : EReg -> String ) : String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n}\n\n@:native(\"RegExp\")\nprivate extern class HaxeRegExp extends js.RegExp {\n\tvar m:js.RegExp.RegExpMatch;\n\tvar s:String;\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn untyped undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif( pos != null && pos != 0 && len != null && len < 0 ) return \"\";\n\t\tif( len == null ) len = s.length;\n\t\tif( pos < 0 ){\n\t\t\tpos = s.length + pos;\n\t\t\tif( pos < 0 ) pos = 0;\n\t\t}else if( len < 0 ){\n\t\t\tlen = s.length + len - pos;\n\t\t}\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if !js_es5\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tThe `Lambda` class is a collection of methods to support functional\n\tprogramming. It is ideally used with 'using Lambda' and then acts as an\n\textension to Iterable types.\n\n\tOn static platforms, working with the Iterable structure might be slower\n\tthan performing the operations directly on known types, such as Array and\n\tList.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\nclass Lambda {\n\n\t/**\n\t\tCreates an Array from Iterable `it`.\n\n\t\tIf `it` is an Array, this function returns a copy of it.\n\t**/\n\tpublic static function array<A>( it : Iterable<A> ) : Array<A> {\n\t\tvar a = new Array<A>();\n\t\tfor(i in it)\n\t\t\ta.push(i);\n\t\treturn a;\n\t}\n\n\t/**\n\t\tCreates a List form Iterable `it`.\n\n\t\tIf `it` is a List, this function returns a copy of it.\n\t**/\n\tpublic static function list<A>( it : Iterable<A> ) : List<A> {\n\t\tvar l = new List<A>();\n\t\tfor(i in it)\n\t\t\tl.add(i);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tCreates a new List by applying function `f` to all elements of `it`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function map<A,B>( it : Iterable<A>, f : A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tfor( x in it )\n\t\t\tl.add(f(x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tSimilar to map, but also passes the index of each element to `f`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function mapi<A,B>( it : Iterable<A>, f : Int -> A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tvar i = 0;\n\t\tfor( x in it )\n\t\t\tl.add(f(i++,x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tTells if `it` contains `elt`.\n\n\t\tThis function returns true as soon as an element is found which is equal\n\t\tto `elt` according to the `==` operator.\n\n\t\tIf no such element is found, the result is false.\n\t**/\n\tpublic static function has<A>( it : Iterable<A>, elt : A ) : Bool {\n\t\tfor( x in it )\n\t\t\tif( x == elt )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `it` contains an element for which `f` is true.\n\n\t\tThis function returns true as soon as an element is found for which a\n\t\tcall to `f` returns true.\n\n\t\tIf no such element is found, the result is false.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function exists<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `f` is true for all elements of `it`.\n\n\t\tThis function returns false as soon as an element is found for which a\n\t\tcall to `f` returns false.\n\n\t\tIf no such element is found, the result is true.\n\n\t\tIn particular, this function always returns true if `it` is empty.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function foreach<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( !f(x) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tCalls `f` on all elements of `it`, in order.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function iter<A>( it : Iterable<A>, f : A -> Void ) {\n\t\tfor( x in it )\n\t\t\tf(x);\n\t}\n\n\t/**\n\t\tReturns a List containing those elements of `it` for which `f` returned\n\t\ttrue.\n\n\t\tIf `it` is empty, the result is the empty List even if `f` is null.\n\n\t\tOtherwise if `f` is null, the result is unspecified.\n\t**/\n\tpublic static function filter<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tvar l = new List<A>();\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tFunctional fold on Iterable `it`, using function `f` with start argument\n\t\t`first`.\n\n\t\tIf `it` has no elements, the result is `first`.\n\n\t\tOtherwise the first element of `it` is passed to `f` alongside `first`.\n\t\tThe result of that call is then passed to `f` with the next element of\n\t\t`it`, and so on until `it` has no more elements.\n\n\t\tIf `it` or `f` are null, the result is unspecified.\n\t**/\n\tpublic static function fold<A,B>( it : Iterable<A>, f : A -> B -> B, first : B ) : B {\n\t\tfor( x in it )\n\t\t\tfirst = f(x,first);\n\t\treturn first;\n\t}\n\n\t/**\n\t\tReturns the number of elements in `it` for which `pred` is true, or the\n\t\ttotal number of elements in `it` if `pred` is null.\n\n\t\tThis function traverses all elements.\n\t**/\n\tpublic static function count<A>( it : Iterable<A>, ?pred : A -> Bool ) {\n\t\tvar n = 0;\n\t\tif( pred == null )\n\t\t\tfor( _ in it )\n\t\t\t\tn++;\n\t\telse\n\t\t\tfor( x in it )\n\t\t\t\tif( pred(x) )\n\t\t\t\t\tn++;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tTells if Iterable `it` does not contain any element.\n\t**/\n\tpublic static function empty<T>( it : Iterable<T> ) : Bool {\n\t\treturn !it.iterator().hasNext();\n\t}\n\n\t/**\n\t\tReturns the index of the first element `v` within Iterable `it`.\n\n\t\tThis function uses operator `==` to check for equality.\n\n\t\tIf `v` does not exist in `it`, the result is -1.\n\t**/\n\tpublic static function indexOf<T>( it : Iterable<T>, v : T ) : Int {\n\t\tvar i = 0;\n\t\tfor( v2 in it ) {\n\t\t\tif( v == v2 )\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t\tReturns the first element of `it` for which `f` is true.\n\n\t\tThis function returns as soon as an element is found for which a call to\n\t\t`f` returns true.\n\n\t\tIf no such element is found, the result is null.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function find<T>( it : Iterable<T>, f : T -> Bool ) : Null<T> {\n\t\tfor( v in it ) {\n\t\t\tif(f(v)) return v;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tReturns a new List containing all elements of Iterable `a` followed by\n\t\tall elements of Iterable `b`.\n\n\t\tIf `a` or `b` are null, the result is unspecified.\n\t**/\n\tpublic static function concat<T>( a : Iterable<T>, b : Iterable<T> ) : List<T> {\n\t\tvar l = new List();\n\t\tfor( x in a )\n\t\t\tl.add(x);\n\t\tfor( x in b )\n\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n}\n","import cards.types.*;\n\nimport cards.model.Data;\nimport cards.model.Model;\nimport cards.model.Schema;\nimport cards.properties.ValueProperties;\nimport cards.ui.Card;\nimport cards.ui.fragments.FragmentMapper;\nimport cards.ui.fragments.FragmentProperties;\nimport cards.util.MacroVersion;\nimport thx.stream.dom.Dom;\nimport udom.Dom;\n\nclass Main {\n  public static function main() {\n    var version = MacroVersion.next();\n    Dom.ready().success(function(_) {\n      // START\n      var values    = new ValueProperties(),\n          fragments = new FragmentProperties(),\n          mapper    = new FragmentMapper(fragments, values);\n\n      PropertyFeeder.feedProperties(values);\n      PropertyFeeder.feedFragments(fragments);\n\n      var container = Query.first('.container'),\n          data      = new Data({}),\n          model     = new Model(data);\n\n      // Card\n      var items = Card.create(model, container, mapper);\n      items.document.statusbar.right.component.el.innerHTML = version.toString();\n    });\n  }\n}","import cards.components.Component;\nimport cards.properties.Text;\nimport cards.properties.ToggleClass;\nimport cards.properties.ValueProperties;\nimport cards.ui.fragments.FragmentProperties;\nimport cards.model.SchemaType;\n\nclass PropertyFeeder {\n  static var classes = [\n    { display : 'bold', name : 'strong'},\n    { display : 'italic', name : 'emphasis'}\n  ];\n\n  public static function feedProperties(properties : ValueProperties) {\n    classes.map(function(p) properties.add(p.name, createToggleClass(p.display, p.name)));\n    properties.add('text', createText());\n  }\n\n  public static function feedFragments(fragments : FragmentProperties) {\n    fragments.associateMany('text', ['strong', 'emphasis', 'text']);\n    fragments.associateMany('block', ['strong', 'emphasis']);\n    //fragments.associateMany('readonly', ['strong', 'emphasis', 'text']);\n  }\n\n  static function createToggleClass(display : String, name : String) : ValuePropertyInfo<Bool> {\n    return {\n      name    : name,\n      display : display,\n      type    : BoolType,\n      create  : function(component : Component) {\n        var cls = new ToggleClass(component, name, name);\n        cls.stream.set(true);\n        return cls;\n      }\n    };\n  }\n\n  static function createText() : ValuePropertyInfo<String> {\n    return {\n      name    : 'text',\n      display : 'content',\n      type    : StringType,\n      create  : function(component : Component) return new Text(component, null) // null means that the text will be taken from the HTML\n    };\n  }\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\n\tpublic inline static function hasField( o : Dynamic, field : String ) : Bool {\n\t\treturn untyped __js__('Object').prototype.hasOwnProperty.call(o, field);\n\t}\n\n\tpublic static function field( o : Dynamic, field : String ) : Dynamic {\n\t\ttry return untyped o[field] catch( e : Dynamic ) return null;\n\t}\n\n\tpublic inline static function setField( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\to[field] = value;\n\t}\n\n\tpublic static inline function getProperty( o : Dynamic, field : String ) : Dynamic untyped {\n\t\tvar tmp;\n\t\treturn if( o == null ) __define_feature__(\"Reflect.getProperty\",null) else if( o.__properties__ && (tmp=o.__properties__[\"get_\"+field]) ) o[tmp]() else o[field];\n\t}\n\n\tpublic static inline function setProperty( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\tvar tmp;\n\t\tif( o.__properties__ && (tmp=o.__properties__[\"set_\"+field]) ) o[tmp](value) else o[field] = __define_feature__(\"Reflect.setProperty\",value);\n\t}\n\n\tpublic inline static function callMethod( o : Dynamic, func : haxe.Constraints.Function, args : Array<Dynamic> ) : Dynamic untyped {\n\t\treturn func.apply(o,args);\n\t}\n\n\tpublic static function fields( o : Dynamic ) : Array<String> {\n\t\tvar a = [];\n\t\tif (o != null) untyped {\n\t\t\tvar hasOwnProperty = __js__('Object').prototype.hasOwnProperty;\n\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\tif( f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f) ) a.push(f);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static function isFunction( f : Dynamic ) : Bool untyped {\n\t\treturn __js__(\"typeof(f)\") == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>( a : T, b : T ) : Int {\n\t\treturn ( a == b ) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods( f1 : Dynamic, f2 : Dynamic ) : Bool {\n\t\tif( f1 == f2 )\n\t\t\treturn true;\n\t\tif( !isFunction(f1) || !isFunction(f2) )\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\tpublic static function isObject( v : Dynamic ) : Bool untyped {\n\t\tif( v == null )\n\t\t\treturn false;\n\t\tvar t = __js__(\"typeof(v)\");\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null)) || (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue( v : Dynamic ) : Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField( o : Dynamic, field : String ) : Bool untyped {\n\t\tif( !hasField(o,field) ) return false;\n\t\t__js__(\"delete\")(o[field]);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>( o : T ) : T {\n\t\tvar o2 : Dynamic = {};\n\t\tfor( f in Reflect.fields(o) )\n\t\t\tReflect.setField(o2,f,Reflect.field(o,f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function( f : Array<Dynamic> -> Void ) : Dynamic {})\n\tpublic static function makeVarArgs( f : Array<Dynamic> -> Dynamic ) : Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tIts cross-platform implementation uses String concatenation internally, but\n\tStringBuf may be optimized for different targets.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues. However, the internal buffer cannot be modified.\n**/\nclass StringBuf {\n\n\tvar b:String;\n\n\t/**\n\t\tThe length of `this` StringBuf in characters.\n\t**/\n\tpublic var length(get,never) : Int;\n\n\t/**\n\t\tCreates a new StringBuf instance.\n\n\t\tThis may involve initialization of the internal buffer.\n\t**/\n\tpublic inline function new() {\n\t\tb = \"\";\n\t}\n\n\tinline function get_length() : Int {\n\t\treturn b.length;\n\t}\n\n\t/**\n\t\tAppends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.\n\t**/\n\tpublic inline function add<T>( x : T ) : Void {\n\t\tb += x;\n\t}\n\n\t/**\n\t\tAppends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.\n\t**/\n\tpublic inline function addChar( c : Int ) : Void {\n\t\tb += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tAppends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.\n\t**/\n\tpublic inline function addSub( s : String, pos : Int, ?len : Int) : Void {\n\t\tb += (len == null ? s.substr(pos) : s.substr(pos, len));\n\t}\n\n\t/**\n\t\tReturns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation.\n\t**/\n\tpublic inline function toString() : String {\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t'using StringTools' and then acts as an extension to the String class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\n#if cpp\nusing cpp.NativeString;\n#end\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlEncode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"encodeURIComponent\"](s);\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped encodeURIComponent(s);\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLEncode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLEncoder.encode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.EscapeUriString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.quote(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlDecode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLDecode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLDecoder.decode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.unquote(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape( s : String, ?quotes : Bool ) : String {\n\t\ts = s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t\treturn quotes ? s.split('\"').join(\"&quot;\").split(\"'\").join(\"&#039;\") : s;\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: htmlUnescape(htmlEscape(s)) == s\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape( s : String ) : String {\n\t\treturn s.split(\"&gt;\").join(\">\").split(\"&lt;\").join(\"<\").split(\"&quot;\").join('\"').split(\"&#039;\").join(\"'\").split(\"&amp;\").join(\"&\");\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is null, the result is unspecified.\n\n\t\tIf `start` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function startsWith( s : String, start : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#elseif cpp\n\t\tif (s.length<start.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str();\n\t\tvar p1 = start.c_str();\n\t\tfor(i in 0...start.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#else\n\t\treturn( s.length >= start.length && s.substr(0, start.length) == start );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is null, the result is unspecified.\n\n\t\tIf `end` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function endsWith( s : String, end : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#elseif cpp\n\t\tif (s.length<end.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str().add( s.length-end.length );\n\t\tvar p1 = end.c_str();\n\t\tfor(i in 0...end.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn( slen >= elen && s.substr(slen - elen, elen) == end );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String \"\", or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace( s : String, pos : Int ) : Bool {\n\t\t#if python\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length) return false;\n\t\t#end\n\t\tvar c = s.charCodeAt( pos );\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function ltrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,r) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 )\n\t\t\treturn s.substr(r, l-r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function rtrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,l-r-1) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 ){\n\t\t\treturn s.substr(0, l-r);\n\t\t}else{\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for ltrim(rtrim(s)).\n\t**/\n\tpublic #if (cs || java) inline #end static function trim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn untyped s.trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = c + s;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = s + c;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReplace all occurences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String \"\", `by` is inserted after each character\n\t\tof `s`. If `by` is also the empty String \"\", `s` remains unchanged.\n\n\t\tThis is a convenience function for `s.split(sub).join(by)`.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace( s : String, sub : String, by : String ) : String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits length equals `digits`.\n\t**/\n\tpublic static function hex( n : Int, ?digits : Int ) {\n\t\t#if flash\n\t\t\tvar n : UInt = n;\n\t\t\tvar s : String = untyped n.toString(16);\n\t\t\ts = s.toUpperCase();\n\t\t#else\n\t\t\tvar s = \"\";\n\t\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\t\tdo {\n\t\t\t\ts = hexChars.charAt(n&15) + s;\n\t\t\t\tn >>>= 4;\n\t\t\t} while( n > 0 );\n\t\t#end\n\t\t#if python\n\t\tif (digits != null && s.length < digits) {\n\t\t\tvar diff = digits - s.length;\n\t\t\tfor (_ in 0...diff) {\n\t\t\t\ts = \"0\" + s;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tif( digits != null )\n\t\t\twhile( s.length < digits )\n\t\t\t\ts = \"0\"+s;\n\t\t#end\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than String.charCodeAt() on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the \\0\n\t\tcharacter.\n\t**/\n\tpublic static inline function fastCodeAt( s : String, index : Int ) : Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn ( index < s.length ) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn ( cast(index, UInt) < s.length ) ? cast(s[index], Int) : -1;\n\t\t#elseif js\n\t\treturn (untyped s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/*\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t*/\n\t@:noUsing public static inline function isEof( c : Int ) : Bool {\n\t\t#if (flash || cpp)\n\t\treturn c == 0;\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif neko\n\t\treturn c == null;\n\t\t#elseif cs\n\t\treturn c == -1;\n\t\t#elseif java\n\t\treturn c == -1;\n\t\t#elseif python\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16 return untyped str._charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\",\"url_encode\",1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\",\"url_decode\",1);\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass( c : Class<Dynamic> );\n\tTEnum( e : Enum<Dynamic> );\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\n\tpublic static inline function getClass<T>( o : T ) : Class<T> {\n\t\treturn if (o == null) null else @:privateAccess js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum( o : EnumValue ) : Enum<Dynamic> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn o.__enum__;\n\t}\n\n\tpublic static function getSuperClass( c : Class<Dynamic> ) : Class<Dynamic> untyped {\n\t\treturn c.__super__;\n\t}\n\n\n\tpublic static function getClassName( c : Class<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped c.__name__;\n\t\tif (a == null)\n\t\t\treturn null;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function getEnumName( e : Enum<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped e.__ename__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function resolveClass( name : String ) : Class<Dynamic> untyped {\n\t\tvar cl : Class<Dynamic> = $hxClasses[name];\n\t\t// ensure that this is a class\n\t\tif( cl == null || !js.Boot.isClass(cl) )\n\t\t\treturn null;\n\t\treturn cl;\n\t}\n\n\tpublic static function resolveEnum( name : String ) : Enum<Dynamic> untyped {\n\t\tvar e : Dynamic = $hxClasses[name];\n\t\t// ensure that this is an enum\n\t\tif( e == null || !js.Boot.isEnum(e) )\n\t\t\treturn null;\n\t\treturn e;\n\t}\n\n\tpublic static function createInstance<T>( cl : Class<T>, args : Array<Dynamic> ) : T untyped {\n\t\tswitch( args.length ) {\n\t\tcase 0:\n\t\t\treturn __new__(cl);\n\t\tcase 1:\n\t\t\treturn __new__(cl,args[0]);\n\t\tcase 2:\n\t\t\treturn __new__(cl,args[0],args[1]);\n\t\tcase 3:\n\t\t\treturn __new__(cl,args[0],args[1],args[2]);\n\t\tcase 4:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3]);\n\t\tcase 5:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4]);\n\t\tcase 6:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5]);\n\t\tcase 7:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);\n\t\tcase 8:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);\n\t\tdefault:\n\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static function createEmptyInstance<T>( cl : Class<T> ) : T untyped {\n\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\treturn __js__(\"new empty()\");\n\t}\n\n\tpublic static function createEnum<T>( e : Enum<T>, constr : String, ?params : Array<Dynamic> ) : T {\n\t\tvar f:Dynamic = Reflect.field(e,constr);\n\t\tif( f == null ) throw \"No such constructor \"+constr;\n\t\tif( Reflect.isFunction(f) ) {\n\t\t\tif( params == null ) throw \"Constructor \"+constr+\" need parameters\";\n\t\t\treturn Reflect.callMethod(e,f,params);\n\t\t}\n\t\tif( params != null && params.length != 0 )\n\t\t\tthrow \"Constructor \"+constr+\" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>( e : Enum<T>, index : Int, ?params : Array<Dynamic> ) : T {\n\t\tvar c : String = (untyped e.__constructs__)[index];\n\t\tif( c == null ) throw index+\" is not a valid enum constructor index\";\n\t\treturn createEnum(e,c,params);\n\t}\n\n\tpublic static function getInstanceFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\n\tpublic static function getEnumConstructs( e : Enum<Dynamic> ) : Array<String> {\n\t\tvar a : Array<String> = untyped e.__constructs__;\n\t\treturn a.copy();\n\t}\n\n\tpublic static function typeof( v : Dynamic ) : ValueType untyped {\n\t\tswitch( __js__(\"typeof\")(v) ) {\n\t\tcase \"boolean\": return TBool;\n\t\tcase \"string\": return TClass(String);\n\t\tcase \"number\":\n\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\tif( Math.ceil(v) == v%2147483648.0 )\n\t\t\t\treturn TInt;\n\t\t\treturn TFloat;\n\t\tcase \"object\":\n\t\t\tif( v == null )\n\t\t\t\treturn TNull;\n\t\t\tvar e = v.__enum__;\n\t\t\tif( e != null )\n\t\t\t\treturn TEnum(e);\n\t\t\tvar c = js.Boot.getClass(v);\n\t\t\tif( c != null )\n\t\t\t\treturn TClass(c);\n\t\t\treturn TObject;\n\t\tcase \"function\":\n\t\t\tif( js.Boot.isClass(v) || js.Boot.isEnum(v) )\n\t\t\t\treturn TObject;\n\t\t\treturn TFunction;\n\t\tcase \"undefined\":\n\t\t\treturn TNull;\n\t\tdefault:\n\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T>( a : T, b : T ) : Bool untyped {\n\t\tif( a == b )\n\t\t\treturn true;\n\t\ttry {\n\t\t\tif( a[0] != b[0] )\n\t\t\t\treturn false;\n\t\t\tfor( i in 2...a.length )\n\t\t\t\tif( !enumEq(a[i],b[i]) )\n\t\t\t\t\treturn false;\n\t\t\tvar e = a.__enum__;\n\t\t\tif( e != b.__enum__ || e == null )\n\t\t\t\treturn false;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic inline static function enumConstructor( e : EnumValue ) : String {\n\t\treturn untyped e[0];\n\t}\n\n\tpublic inline static function enumParameters( e : EnumValue ) : Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\n\tpublic inline static function enumIndex( e : EnumValue ) : Int {\n\t\treturn untyped e[1];\n\t}\n\n\tpublic static function allEnums<T>( e : Enum<T> ) : Array<T> {\n\t\treturn untyped e.__empty_constructs__;\n\t}\n\n}\n\n","package cards.components;\n\nimport udom.Dom;\nimport js.html.DOMElement as Element;\n\nclass Component {\n  public var children(get, null) : Iterable<Component>;\n  public var isAttached(default, null) : Bool = false;\n  public var parent(default, null) : Component;\n  public var properties(default, null) : Properties;\n  public var el(default, null) : Element;\n  var list : Array<Component>;\n\n  public function new(options : ComponentOptions) {\n    list = [];\n    properties = new Properties(this);\n    if(null == options.template) {\n      if(null == options.el)\n        throw '$this needs a template';\n      else {\n        el = options.el;\n        if(null != el.parentElement) {\n          isAttached = true;\n        }\n      }\n    } else {\n      el = Html.parse(options.template);\n    }\n    if(null != options.classes)\n      options.classes.split(' ').map(cast el.classList.add);\n    if(null != options.parent)\n      options.parent.add(this);\n    if(null != options.container)\n      appendTo(options.container);\n  }\n\n  public function appendTo(container : Element) {\n    container.appendChild(el);\n    isAttached = true;\n  }\n\n  public function detach() {\n    if(!isAttached)\n      throw 'Component is not attached';\n    el.parentElement.removeChild(el);\n    isAttached = false;\n  }\n\n  public function destroy() {\n    if(null != parent)\n      parent.remove(this);\n    if(isAttached)\n      detach();\n    properties.removeAll();\n  }\n\n  public function add(child : Component) {\n    if(null != child.parent)\n      child.parent.remove(child);\n    list.push(child);\n    child.parent = this;\n  }\n\n  public function remove(child : Component) {\n    if(!list.remove(child))\n      throw '$child is not a child of $this';\n    child.parent = null;\n  }\n\n  function get_children()\n    return list;\n\n  public function toString()\n    return Type.getClassName(Type.getClass(this)).split('.').pop();\n}\n","package cards.components;\n\nimport cards.properties.Property;\nimport cards.properties.PropertyName;\n\nclass Properties {\n  var properties : Map<String, Property>;\n  var target : Component;\n  public function new(target : Component) {\n    this.target = target;\n    properties = new Map();\n  }\n\n  public function removeAll() {\n    for(name in properties.keys())\n      remove(name);\n  }\n\n  function add(property : Property) {\n    if(properties.exists(property.name))\n      throw '$target already has a property $property';\n    properties.set(property.name, property);\n  }\n\n  public function get(name : PropertyName) {\n    return properties.get(name);\n  }\n\n  public function exists(name : PropertyName) {\n    return properties.exists(name);\n  }\n\n  function remove(name : PropertyName) {\n    if(!properties.exists(name))\n      throw 'property \"${name}\" does not exist in $target';\n    var prop = properties.get(name);\n    properties.remove(name);\n    prop.dispose();\n  }\n}","package cards.model;\n\nimport haxe.Json;\nimport cards.model.ref.ObjectRef;\nimport cards.model.ref.IRef;\nimport thx.stream.Value;\n\nclass Data {\n  var root : ObjectRef;\n  var cache : Map<String, IRef>;\n  public var value(default, null) : Value<{}>;\n\n  public function new(data : {}) {\n    value = new Value(data);\n    reset(data);\n  }\n\n  function resolve(path : String) {\n    var ref = cache.get(path);\n    if(null == ref) {\n      ref = root.resolve(path);\n      if(ref.hasValue())\n        cache.set(path, ref);\n    }\n    return ref;\n  }\n\n  public function get(path : String) : Dynamic\n    return resolve(path).get();\n\n  public function hasValue(path : String) : Bool\n    return resolve(path).hasValue();\n\n  public function set(path : String, value : Dynamic) : Data {\n    var ref = resolve(path);\n    cache.set(path, ref);\n    if(ref.get() != value) {\n      ref.set(value);\n      this.value.set(toObject());\n    }\n    return this;\n  }\n\n  public function reset(value : Dynamic) : Data {\n    root = new ObjectRef(null);\n    cache = new Map();\n    if(null != value) {\n      set(\"\", value);\n    }\n    this.value.set(toObject());\n    return this;\n  }\n\n  public function remove(path : String) {\n    var ref = cache.get(path);\n    if(null == ref) {\n      ref = root.resolve(path);\n    }\n\n    if(ref.hasValue()) {\n      ref.remove();\n      this.value.set(toObject());\n    }\n    cache.remove(path);\n  }\n\n  public function rename(oldpath : String, newpath : String) {\n    if(!hasValue(oldpath) || hasValue(newpath))\n      return false;\n    var v = get(oldpath);\n    remove(oldpath);\n    set(newpath, v);\n    this.value.set(toObject());\n    return true;\n  }\n\n  public function toObject() : {}\n    return root.get();\n\n  public function toJSON()\n    return Json.stringify(toObject());\n}","package cards.model;\n\nimport cards.model.Runtime;\nimport haxe.ds.Option;\n\nenum Expression {\n  Fun(f : Void -> RuntimeResult);\n  SyntaxError(msg : String);\n}\n\nclass Expressions {\n  public static function toErrorOption(exp : Expression) {\n    return switch exp {\n      case SyntaxError(e): Some(e);\n      case _: None;\n    };\n  }\n}","package cards.model;\n\nimport thx.stream.Bus;\nimport thx.stream.Emitter;\n\nclass Model {\n  public var data(default, null) : Data;\n  public var schema(default, null) : Schema;\n\n  public var dataEventSubscriber(default, null) : DataEvent -> Void;\n  public var schemaEventSubscriber(default, null) : SchemaEvent -> Void;\n\n  public var changes(default, null) : Emitter<String>;\n  var bus : Bus<String>;\n\n  public function new(data : Data) {\n    this.changes = this.bus = new Bus();\n    this.data = data;\n    this.schema = new Schema();\n    this.dataEventSubscriber = function(e : DataEvent)\n      switch e {\n        case SetValue(path, value, type):\n          data.set(path, value);\n          bus.pulse(path);\n      };\n\n    this.schemaEventSubscriber = function(e : SchemaEvent) {\n      switch e {\n        case ListFields(list):\n          for(item in list)\n            schema.add(item.name, item.type);\n          bus.pulse(\"\");\n        case AddField(path, type):\n          schema.add(path, type);\n        case DeleteField(path):\n          schema.delete(path);\n          data.remove(path);\n          bus.pulse(path);\n        case RenameField(oldpath, newpath):\n          schema.rename(oldpath, newpath);\n          data.rename(oldpath, newpath);\n          bus.pulse(oldpath);\n          bus.pulse(newpath);\n        case RetypeField(path, type):\n          schema.retype(path, type);\n          data.remove(path);\n          bus.pulse(path);\n      }\n    };\n  }\n}","package cards.model;\n\nimport haxe.ds.Option;\nusing thx.Set;\nusing thx.Iterables;\nimport cards.model.Expression;\nimport cards.model.Scope;\n\nclass Runtime {\n  static function createFunction(args : Array<String>, code : String) : Dynamic -> Dynamic -> Dynamic\n    return (untyped __js__('new Function'))(args.join(','), code);\n\n  static function formatCode(code : String, scope : Dynamic) {\n    var prelim = Reflect.fields(scope)\n      .map(function(field) {\n        return 'var $field = scope.$field;';\n      })\n      .join('\\n');\n    return '$prelim\ndelete scope;\nreturn $code;';\n  }\n\n  static var pattern = ~/\\$\\.(.+?)\\b/;\n  // TODO: poorman implementation\n  public static function extractDependencies(code : String) {\n    var set : Set<String> = [];\n    while(pattern.match(code)) {\n      set.add(pattern.matched(1));\n      code = pattern.matchedRight();\n    }\n    return set.order(thx.Strings.compare);\n  }\n\n  public static function toRuntime(code : String, model : Model) : Runtime {\n    var expression = try {\n        var scope = new Scope();\n        var formatted = formatCode(code, scope);\n        var f = createFunction(['$', 'scope'], formatted);\n\n        Fun(function() try return Result(f(model.data.toObject(), scope)) catch(e : Dynamic) return Error(Std.string(e)));\n      } catch(e : Dynamic) {\n        SyntaxError(Std.string(e));\n      };\n    return new Runtime(expression, code);\n  }\n\n  public static function toErrorOption(runtime : Runtime) : Option<String>\n    return switch runtime.expression {\n      case SyntaxError(e): Some(e);\n      case _: None;\n    };\n\n  public var expression(default, null) : Expression;\n  public var code(default, null) : String;\n  public var dependencies(default, null) : Array<String>;\n  public function new(expression : Expression, code : String) {\n    this.expression = expression;\n    this.code = code;\n    this.dependencies = extractDependencies(code);\n  }\n}\n\nenum RuntimeResult {\n  Result(value : Dynamic);\n  Error(msg : String);\n}","package cards.model;\n\nimport thx.Error;\nimport thx.stream.Bus;\nimport thx.stream.Emitter;\nimport cards.model.SchemaEvent;\n\nclass Schema {\n  var fields : Map<String, SchemaType>;\n  public var stream(default, null) : Emitter<SchemaEvent>;\n  var bus : Bus<SchemaEvent>;\n\n  public function new() {\n    fields = new Map();\n    stream = bus = new Bus();\n  }\n\n  public function add(name : String, type : SchemaType) {\n    if(fields.exists(name))\n      throw new Error('Schema already contains a field \"$name\"');\n    fields.set(name, type);\n    bus.pulse(AddField(name, type));\n  }\n\n  public function reset(?list : Array<FieldPair>) {\n    if(null == list)\n      list = [];\n    fields = new Map();\n    list.map(function(pair) {\n      fields.set(pair.name, pair.type);\n    });\n    bus.pulse(ListFields(list.copy()));\n  }\n\n  public function delete(name : String) {\n    if(!fields.exists(name))\n      throw new Error('Schema does not contain a field \"${name}\"');\n    fields.remove(name);\n    bus.pulse(DeleteField(name));\n  }\n\n  public function rename(oldname : String, newname : String) {\n    if(!fields.exists(oldname))\n      throw new Error('Schema does not contain a field \"${oldname}\"');\n    var type = fields.get(oldname);\n    fields.remove(oldname);\n    fields.set(newname, type);\n    bus.pulse(RenameField(oldname, newname));\n  }\n\n  public function retype(name : String, type : SchemaType) {\n    if(!fields.exists(name))\n      throw new Error('Schema does not contain a field \"${name}\"');\n    fields.set(name, type);\n    bus.pulse(RetypeField(name, type));\n  }\n\n  public function get(name : String) {\n    return fields.get(name);\n  }\n\n  public function exists(name : String) {\n    return fields.exists(name);\n  }\n\n  public function getFieldNames() {\n    var arr = [];\n    for(key in fields.keys())\n      arr.push(key);\n    return arr;\n  }\n\n  public function getPairs() {\n    return getFieldNames().map(function(key) {\n      return {\n        name : key,\n        type : fields.get(key)\n      };\n    });\n  }\n}","package cards.model;\n\nclass Scope {\n  public var name : String = \"Franco\";\n  public function new() {}\n}","package cards.model.ref;\n\nclass BaseRef {\n  public var parent(default, null) : IParentRef;\n  public function new(?parent : IParentRef) {\n    this.parent = null != parent ? parent : EmptyParent.instance;\n  }\n\n  public function getRoot() : IRef {\n    var ref : IRef = cast this;\n    while(!Std.is(ref.parent, BaseRef.EmptyParent))\n      ref = cast ref.parent;\n    return ref;\n  }\n}\n\nclass EmptyParent implements IParentRef {\n  public static var instance(default, null) : IParentRef = new EmptyParent();\n\n  function new() {}\n\n  public function removeChild(child : IRef) { }\n}","package cards.model.ref;\n\nusing thx.Iterators;\nusing thx.Arrays;\nusing thx.Ints;\n\nclass ArrayRef extends BaseRef implements IRef implements IParentRef {\n  var items : Map<Int, IRef>;\n  var inverse : Map<IRef, Int>;\n\n  public function new(?parent : IParentRef) {\n    super(parent);\n    items   = new Map();\n    inverse = new Map();\n  }\n\n  public function get() {\n    var res = [];\n    items\n      .keys()\n      .toArray()\n      .order(Ints.compare)\n      .map(function(i) return items.get(i))\n      .map(function(ref) {\n        if(ref.hasValue())\n          res.push(ref.get());\n      });\n    return res;\n  }\n\n  public function set(value : Dynamic) {\n    if(!Std.is(value, Array)) throw 'value \"$value\" is not an array';\n\n    (value : Array<Dynamic>).mapi(function(v, i) {\n      var ref = items.get(i);\n      if(null == ref) {\n        items.set(i, ref = Ref.fromValue(v, this));\n        inverse.set(ref, i);\n      } else {\n        ref.set(v);\n      }\n    });\n  }\n\n  public function remove() {\n    for(ref in items) {\n      ref.remove();\n    }\n    parent.removeChild(this);\n  }\n\n  public function removeChild(child : IRef) : Void {\n    var i = inverse.get(child);\n    if(null == i) throw '\"$child\" is not child of \"$this\"';\n    items.remove(i);\n    inverse.remove(child);\n  }\n\n  public function hasValue() {\n    for(ref in items)\n      if(ref.hasValue())\n        return true;\n    return false;\n  }\n\n  public function resolve(path : String, terminal : Bool = true) : IRef {\n    if(path == \"\") return this;\n    if(!Ref.reIndex.match(path))\n      throw 'unable to resolve \"$path\" for ArrayRef';\n    var index = Std.parseInt(Ref.reIndex.matched(1)),\n      rest  = Ref.reIndex.matchedRight(),\n      ref   = items.get(index);\n    if(null == ref) {\n      items.set(index, ref = Ref.fromPath(rest, this, terminal));\n      inverse.set(ref, index);\n    }\n    return ref.resolve(rest, terminal);\n  }\n\n  public function toString()\n    return 'ArrayRef: $items';\n}","package cards.model.ref;\n\nusing thx.Iterators;\nusing thx.Iterables;\nimport thx.Types;\n\nclass ObjectRef extends BaseRef implements IRef implements IParentRef {\n  var fields : Map<String, IRef>;\n  var inverse : Map<IRef, String>;\n\n  public function new(?parent : IParentRef) {\n    super(parent);\n    fields = new Map();\n    inverse = new Map();\n  }\n\n  public function get() : Dynamic {\n    var o = {};\n    fields.keys().map(function(key) {\n      var ref = fields.get(key);\n      if(!ref.hasValue()) return;\n      Reflect.setField(o, key, ref.get());\n    });\n    return o;\n  }\n\n  public function set(obj : Dynamic) {\n    if(!Types.isAnonymousObject(obj)) throw 'object \"$obj\" is not an anonymous object';\n    Reflect.fields(obj).map(function(field) {\n      var ref   = fields.get(field),\n        value = Reflect.field(obj, field);\n      if(null == ref) {\n        ref = Ref.fromValue(value, this);\n        fields.set(field, ref);\n        inverse.set(ref, field);\n      } else {\n        ref.set(value);\n      }\n    });\n  }\n\n  public function hasValue() {\n    for(ref in fields)\n      if(ref.hasValue())\n        return true;\n    return false;\n  }\n\n  public function remove() {\n    fields.map(function(ref) ref.remove());\n    parent.removeChild(this);\n  }\n\n  public function removeChild(child : IRef) {\n    var key = inverse.get(child);\n    if(null == key) throw '\"$child\" is not child of \"$this\"';\n    inverse.remove(child);\n    fields.remove(key);\n  }\n\n  public function resolve(path : String, terminal : Bool = false) : IRef {\n    if(path == \"\") return this;\n    if(!Ref.reField.match(path))\n      throw 'unable to resolve \"$path\" for ObjectRef';\n    var field = Ref.reField.matched(1),\n        rest  = Ref.reField.matchedRight(),\n        ref   = fields.get(field);\n    if(null == ref) {\n      fields.set(field, ref = Ref.fromPath(rest, this, terminal));\n      inverse.set(ref, field);\n    }\n    return ref.resolve(rest, terminal);\n  }\n\n  public function toString()\n    return 'ObjectRef: $fields';\n}","package cards.model.ref;\n\nusing thx.Types;\n\nclass Ref {\n  public static function fromValue(value : Dynamic, ?parent : IParentRef) : IRef {\n    if(null == parent)\n      parent = BaseRef.EmptyParent.instance;\n    var ref : IRef = if(Std.is(value, Array)) {\n        new ArrayRef(parent);\n      } else if(Types.isAnonymousObject(value)) {\n        new ObjectRef(parent);\n      } else {\n        new ValueRef(parent);\n      }\n    ref.set(value);\n    return ref;\n  }\n\n  public static var reField = ~/^\\.?([^.\\[]+)/;\n  public static var reIndex = ~/^\\[(\\d+)\\]/;\n  public static function fromPath(path : String, ?parent : IParentRef, terminal : Bool = true) : IRef {\n    trace('$path with $parent $terminal');\n    if(null == parent)\n      parent = BaseRef.EmptyParent.instance;\n    if(path == \"\") {\n      return terminal ? new ValueRef(parent) : new UnknownRef(parent);\n    } else if(reField.match(path)) {\n      return new ObjectRef(parent);\n    } else if(reIndex.match(path)) {\n      return new ArrayRef(parent);\n    } else {\n      return throw 'invalid path \"$path\"';\n    }\n  }\n\n  public static function resolvePath(path : String, ?parent : IParentRef, terminal : Bool = true) : IRef {\n    var ref = fromPath(path, parent, terminal);\n    return ref.resolve(path);\n  }\n}","package cards.model.ref;\n\nusing thx.Objects;\nusing thx.Arrays;\n\nclass UnknownRef extends BaseRef implements IRef implements IParentRef {\n  public var ref(default, null) : Null<IRef>;\n  var hasRef : Bool = false;\n\n  public function get() : Dynamic\n    return hasRef ? ref.get() : null;\n\n  public function set(value : Dynamic) {\n    if(hasRef)\n      ref.set(value);\n    else {\n      hasRef = true;\n      ref = Ref.fromValue(value, this);\n    }\n  }\n\n  public function remove() : Void {\n    if(hasRef)\n      ref.remove();\n    parent.removeChild(this);\n  }\n\n  public function removeChild(child : IRef) : Void {\n    if(hasRef) {\n      ref = null;\n      hasRef = false;\n    }\n  }\n\n  public function hasValue() : Bool\n    return hasRef && ref.hasValue();\n\n  public function resolve(path : String, terminal : Bool = true) : IRef {\n    if(hasRef)\n      return ref.resolve(path, terminal);\n    if(path == \"\")\n      return this;\n    hasRef = true;\n    ref = Ref.fromPath(path, this, terminal);\n    return ref.resolve(path, terminal);\n  }\n\n  public function toString()\n    return 'UnknownRef: $ref';\n}\n","package cards.model.ref;\n\nusing thx.Objects;\nusing thx.Arrays;\n\nclass ValueRef extends BaseRef implements IRef {\n  var _hasValue : Bool = false;\n  var value : Dynamic;\n\n  public function get()\n    return value;\n\n  public function set(value : Dynamic) {\n    this.value = value;\n    _hasValue = true;\n  }\n\n  public function remove() : Void {\n    value = null;\n    _hasValue = false;\n    parent.removeChild(this);\n  }\n\n  public function hasValue() : Bool\n    return _hasValue;\n\n  public function resolve(path : String, terminal : Bool = true) : IRef {\n    if(path != \"\") throw 'unable to resolve path \"$path\" on ValueRef';\n    return this;\n  }\n\n  public function toString()\n    return 'ValueRef: $value';\n}","package cards.properties;\n\nimport cards.components.Component;\n\n@:access(cards.components.Properties)\nclass Property {\n  public var component(default, null) : Component;\n  public var name(default, null) : String;\n  var cancels : Array<Void -> Void>;\n  public function new(component : Component, name : String) {\n    this.component = component;\n    this.name = name;\n    cancels = [];\n    component.properties.add(this);\n  }\n\n  public function dispose() {\n    while(cancels.length > 0)\n      cancels.shift()();\n    if(this.component.properties.exists(name)) {\n      this.component.properties.remove(name);\n      this.component = null;\n    }\n  }\n\n  public function toString()\n    return Type.getClassName(Type.getClass(this)).split('.').pop();\n}","package cards.properties;\n\nimport haxe.ds.Option;\nimport cards.components.Component;\nimport thx.stream.Value;\nimport cards.model.Runtime;\nusing thx.stream.Emitter;\nusing thx.stream.dom.Dom;\n\nclass ValueProperty<T> extends Property {\n  public var stream(default, null) : Value<T>;\n  public var runtime(default, null) : Value<Option<Runtime>>;\n  public var runtimeError(default, null) : Value<Option<String>>;\n\n  public function new(defaultValue : T, component : Component, name : String) {\n    stream = new Value(defaultValue);\n    runtime = new Value(None);\n    runtimeError = new Value(None);\n    super(component, name);\n\n    runtimeError\n      .toBool()\n      .subscribe(component.el.subscribeToggleClass('error'));\n\n    runtime\n      .subscribe(function(opt : Option<Runtime>) switch opt {\n        case None:\n          // TODO: Remove?\n          component.el.classList.remove('error');\n          runtimeError.set(None);\n        case Some(runtime):\n          switch runtime.expression {\n            case SyntaxError(e):\n              // TODO: Remove?\n              component.el.classList.add('error');\n              runtimeError.set(None);\n            case Fun(f):\n              // TODO: Remove?\n              component.el.classList.remove('error');\n              runtimeError.set(None);\n              switch f() {\n                case Result(v):\n                  stream.set(transform(v));\n                case Error(e):\n                  runtimeError.set(Some(e));\n              }\n          }\n      });\n  }\n\n  public function transform(value : Dynamic) : T {\n    return throw Type.getClassName(Type.getClass(this)).split('.').pop() + '.transform() is abstract and must be overridden';\n  }\n\n  override public function dispose() {\n    stream.clear();\n    runtime.clear();\n    runtimeError.clear();\n    super.dispose();\n  }\n\n  function get_value()\n    return stream.get();\n\n  function set_value(value : T)\n    return stream.set(value);\n}","package cards.properties;\n\nimport cards.types.DynamicTransform;\n\nclass BoolProperty extends ValueProperty<Bool> {\n  override public function transform(value : Dynamic) : Bool\n    return DynamicTransform.toBool(value);\n}","package cards.properties;\n\nabstract PropertyName(String) {\n  @:from public inline static function fromProperty(property : Property)\n    return new PropertyName(property.name);\n\n  @:from public inline static function fromString(name : String)\n    return new PropertyName(name);\n\n  public inline function new(name : String)\n    this = name;\n\n  @:to public inline function toString()\n    return this;\n}","package cards.properties;\n\nimport cards.types.DynamicTransform;\n\nclass StringProperty extends ValueProperty<String> {\n  override public function transform(value : Dynamic) : String\n    return DynamicTransform.toString(value);\n}","package cards.properties;\n\nimport cards.components.Component;\nusing thx.stream.dom.Dom;\n\nclass Text extends StringProperty {\n  public function new(component : Component, ?defaultText : String) {\n    super(null == defaultText ? component.el.textContent : defaultText, component, 'text');\n    stream.subscribe(component.el.subscribeText());\n  }\n}","package cards.properties;\n\nimport cards.components.Component;\nusing thx.stream.dom.Dom;\n\nclass ToggleClass extends BoolProperty {\n  public function new(component : Component, name : String, ?className : String) {\n    var defaultValue = component.el.classList.contains(className);\n    super(defaultValue, component, name);\n    className = null == className ? name : className;\n    stream.subscribe(component.el.subscribeToggleClass(className));\n  }\n}","package cards.properties;\n\nimport cards.components.Component;\nimport cards.properties.ValueProperty;\nimport cards.model.SchemaType;\n\nclass ValueProperties {\n  public var map : Map<String, ValuePropertyInfo<Dynamic>>;\n  public function new() {\n    map = new Map();\n  }\n\n  public function add(name : String, info : ValuePropertyInfo<Dynamic>)\n    map.set(name, info);\n\n  public function remove(name : String)\n    map.remove(name);\n\n  public function get(name : String)\n    return map.get(name);\n\n  public function ensure(name : String, component : Component) : ValueProperty<Dynamic>\n    return if(component.properties.exists(name))\n      cast(component.properties.get(name), ValueProperty<Dynamic>);\n    else\n      get(name).create(component);\n\n  public function list()\n    return map.keys();\n}\n\ntypedef ValuePropertyInfo<T> = {\n  name    : String,\n  display : String,\n  create  : Component -> ValueProperty<T>,\n  type    : SchemaType\n}","package cards.properties;\n\nusing thx.stream.dom.Dom;\nimport cards.components.Component;\n\nclass Visible extends BoolProperty {\n  public function new(component : Component, defaultValue : Bool) {\n    super(defaultValue, component, 'visible');\n    stream.subscribe(component.el.subscribeToggleVisibility());\n  }\n}","package cards.types;\n\nusing thx.Arrays;\n\nclass ArrayTransform {\n  public static function toArray(value : Array<Dynamic>) : Array<Dynamic> {\n     return null != value ? value : [];\n  }\n\n  public static function toBool(value : Array<Dynamic>) : Bool {\n    return toArray(value).length > 0;\n  }\n\n  public static function toDate(value : Array<Dynamic>) : Date {\n    var defaults = [2000, 0, 1, 0, 0, 0],\n      values   = toArray(value)\n        .map(DynamicTransform.toFloat)\n        .map(function(v) return Math.round(v))\n        .slice(0, defaults.length);\n    values = values.concat(defaults.slice(values.length));\n    return new Date(values[0], values[1], values[2], values[3], values[4], values[5]);\n  }\n\n  public static function toFloat(value : Array<Dynamic>) : Float {\n    return toArray(value).length;\n  }\n\n  public static function toObject(value : Array<Dynamic>) : {} {\n    var obj = {};\n    toArray(value).mapi(function(v, i) {\n      Reflect.setField(obj, 'field_${i+1}', v);\n    });\n    return obj;\n  }\n\n  public static function toString(value : Array<Dynamic>) : String {\n    return toArray(value).map(DynamicTransform.toString).join(', ');\n  }\n\n  public static function toCode(value : Array<Dynamic>) : String {\n    return '[${toArray(value).map(DynamicTransform.toCode).join(\",\")}]';\n  }\n\n  public static function toReference(value : Array<Dynamic>) : String {\n    return '';\n  }\n}","package cards.types;\n\nclass BoolTransform {\n  public static function toArray(value : Bool) : Array<Dynamic> {\n    return [toBool(value) ? false : value];\n  }\n\n  public static function toBool(value : Bool) : Bool {\n    return null != value && value;\n  }\n\n  public static function toDate(value : Bool) : Date {\n    return Date.now();\n  }\n\n  public static function toFloat(value : Bool) : Float {\n    return toBool(value) ? 1 : 0;\n  }\n\n  public static function toObject(value : Bool) : {} {\n    return ArrayTransform.toObject([toBool(value)]);\n  }\n\n  public static function toString(value : Bool) : String {\n    return toBool(value) ? 'Yes' : 'No';\n  }\n\n  public static function toCode<T>(value : Bool) : String {\n    return toBool(value) ? 'true' : 'false';\n  }\n\n  public static function toReference(value : Bool) : String {\n    return '';\n  }\n}","package cards.types;\n\nimport haxe.Json;\nusing StringTools;\n\nclass CodeTransform {\n  public static function toArray(value : String) : Array<Dynamic> {\n    return try {\n      var t = Json.parse(toCode(value));\n      if(Std.is(t, Array))\n        t;\n      else\n        DynamicTransform.toArray(t);\n    } catch(_ : Dynamic) {\n      [];\n    }\n  }\n\n  public static function toBool(value : String) : Bool {\n    return switch toCode(value) {\n      case 'true', '1': true;\n      case _: false;\n    }\n  }\n\n  static var datePattern = ~/Date\\(-?\\d+(:?\\.\\d+)?(:?e-?\\d+)?\\)/;\n  public static function toDate(value : String) : Date {\n    if(datePattern.match(value))\n      return Date.fromTime(Std.parseFloat(datePattern.matched(1)));\n    else\n      return Date.now();\n  }\n\n  public static function toFloat(value : String) : Float {\n    return Std.parseFloat(toCode(value));\n  }\n\n  public static function toObject(value : String) : {} {\n    return try {\n      var t = Json.parse(toCode(value));\n      if(Reflect.isObject(t) && !Std.is(t, String))\n        t;\n      else\n        DynamicTransform.toObject(t);\n    } catch(_ : Dynamic) {\n      {};\n    }\n  }\n\n  public static function toString(value : String) : String {\n    return try {\n      var t = Json.parse(toCode(value));\n      if(Std.is(t, String))\n        t;\n      else\n        DynamicTransform.toString(t);\n    } catch(_ : Dynamic) {\n      '';\n    }\n  }\n\n  public static function toCode(value : String) : String {\n    return null != value ? value.trim() : 'null';\n  }\n\n  static var PATTERN = ~/^\\s*\\$\\.([a-z](:?(\\.|\\[\\d+\\])?[a-z0-9]*)*)\\s*$/;\n  public static function toReference(value : String) : String {\n    var code = toCode(value);\n    return PATTERN.match(code) ? PATTERN.matched(1) : '';\n  }\n}","package cards.types;\n\nclass DateTransform {\n  public static function toArray(value : Date) : Array<Dynamic> {\n    return [toDate(value)];\n  }\n\n  public static function toBool(value : Date) : Bool {\n    return false;\n  }\n\n  public static function toDate(value : Date) : Date {\n    return null != value ? value : Date.now();\n  }\n\n  public static function toFloat(value : Date) : Float {\n    return toDate(value).getTime();\n  }\n\n  public static function toObject(value : Date) : {} {\n    return ArrayTransform.toObject([toDate(value)]);\n  }\n\n  public static function toString(value : Date) : String {\n    return toDate(value).toString();\n  }\n\n  public static function toCode(value : Date) : String {\n    return 'new Date(${toDate(value).getTime()})';\n  }\n\n  public static function toReference(value : Date) : String {\n    return '';\n  }\n}","package cards.types;\n\nclass DynamicTransform {\n  public static function toArray(value : Dynamic) : Array<Dynamic> {\n    if(null == value)\n      return [];\n    if(Std.is(value, Array))\n      return ArrayTransform.toArray(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toArray(value);\n    if(Std.is(value, Date))\n      return DateTransform.toArray(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toArray(value);\n    if(Std.is(value, String))\n      return StringTransform.toArray(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toArray(value);\n    if(Reflect.isFunction(value))\n      return toArray(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toArray';\n  }\n\n  public static function toBool(value : Dynamic) : Bool {\n    if(null == value)\n      return false;\n    if(Std.is(value, Array))\n      return ArrayTransform.toBool(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toBool(value);\n    if(Std.is(value, Date))\n      return DateTransform.toBool(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toBool(value);\n    if(Std.is(value, String))\n      return StringTransform.toBool(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toBool(value);\n    if(Reflect.isFunction(value))\n      return toBool(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toBool';\n  }\n\n  public static function toDate(value : Dynamic) : Date {\n    if(null == value)\n      return Date.now();\n    if(Std.is(value, Array))\n      return ArrayTransform.toDate(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toDate(value);\n    if(Std.is(value, Date))\n      return DateTransform.toDate(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toDate(value);\n    if(Std.is(value, String))\n      return StringTransform.toDate(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toDate(value);\n    if(Reflect.isFunction(value))\n      return toDate(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toDate';\n  }\n\n  public static function toFloat(value : Dynamic) : Float {\n    if(null == value)\n      return 0;\n    if(Std.is(value, Array))\n      return ArrayTransform.toFloat(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toFloat(value);\n    if(Std.is(value, Date))\n      return DateTransform.toFloat(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toFloat(value);\n    if(Std.is(value, String))\n      return StringTransform.toFloat(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toFloat(value);\n    if(Reflect.isFunction(value))\n      return toFloat(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toFloat';\n  }\n\n  public static function toObject(value : Dynamic) : {} {\n    if(null == value)\n      return {};\n    if(Std.is(value, Array))\n      return ArrayTransform.toObject(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toObject(value);\n    if(Std.is(value, Date))\n      return DateTransform.toObject(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toObject(value);\n    if(Std.is(value, String))\n      return StringTransform.toObject(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toObject(value);\n    if(Reflect.isFunction(value))\n      return toObject(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toObject';\n  }\n\n  public static function toString(value : Dynamic) : String {\n    if(null == value)\n      return '';\n    if(Std.is(value, Array))\n      return ArrayTransform.toString(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toString(value);\n    if(Std.is(value, Date))\n      return DateTransform.toString(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toString(value);\n    if(Std.is(value, String))\n      return StringTransform.toString(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toString(value);\n    if(Reflect.isFunction(value))\n      return toString(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toString';\n  }\n\n  public static function toCode(value : Dynamic) : String {\n    if(null == value)\n      return 'null';\n    if(Std.is(value, Array))\n      return ArrayTransform.toCode(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toCode(value);\n    if(Std.is(value, Date))\n      return DateTransform.toCode(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toCode(value);\n    if(Std.is(value, String))\n      return StringTransform.toCode(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toCode(value);\n    if(Reflect.isFunction(value))\n      return toCode(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toCode';\n  }\n\n  public static function toReference(value : Dynamic) : String {\n    if(null == value)\n      return '';\n    if(Std.is(value, Array))\n      return ArrayTransform.toReference(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toReference(value);\n    if(Std.is(value, Date))\n      return DateTransform.toReference(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toReference(value);\n    if(Std.is(value, String))\n      return StringTransform.toReference(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toReference(value);\n    if(Reflect.isFunction(value))\n      return toReference(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toReference';\n  }\n}","package cards.types;\n\nclass FloatTransform {\n  public static function toArray(value : Float) : Array<Dynamic> {\n    return [toFloat(value)];\n  }\n\n  public static function toBool(value : Float) : Bool {\n    return toFloat(value) != 0;\n  }\n\n  public static function toDate(value : Float) : Date {\n    return Date.fromTime(toFloat(value));\n  }\n\n  public static function toFloat(value : Float) : Float {\n    return null != value ? value : 0.0;\n  }\n\n  public static function toObject(value : Float) : {} {\n    return ArrayTransform.toObject([toFloat(value)]);\n  }\n\n  public static function toString(value : Float) : String {\n    return '' + toFloat(value);\n  }\n\n  public static function toCode(value : Float) : String {\n    return '' + toFloat(value);\n  }\n\n  public static function toReference(value : Array<Dynamic>) : String {\n    return '';\n  }\n}","package cards.types;\n\nimport thx.Objects;\n\nclass ObjectTransform {\n  public static function toArray(value : {}) : Array<Dynamic> {\n    return [toObject(value)];\n  }\n\n  public static function toBool(value : {}) : Bool {\n    return !Objects.isEmpty(toObject(value));\n  }\n\n  public static function toDate(value : {}) : Date {\n    return Date.now();\n  }\n\n  public static function toFloat(value : {}) : Float {\n    return Reflect.fields(toObject(value)).length;\n  }\n\n  public static function toObject(value : {}) : {} {\n    return null != value ? value : {};\n  }\n\n  public static function toString(value : {}) : String {\n    return Reflect.fields(toObject(value)).map(function(field) {\n      return '$field: ' + DynamicTransform.toString(Reflect.field(value, field));\n    }).join(', ');\n  }\n\n  public static function toCode(value : {}) : String {\n    return \"{\" + Reflect.fields(toObject(value)).map(function(field) {\n      return '\"$field\" : ' + DynamicTransform.toCode(Reflect.field(value, field));\n    }).join(', ') + \"}\";\n  }\n\n  public static function toReference(value : Array<Dynamic>) : String {\n    return '';\n  }\n}","package cards.types;\n\nimport haxe.Json;\nusing StringTools;\n\nclass ReferenceTransform {\n  public static function toArray(value : String) : Array<Dynamic> {\n    return ArrayTransform.toArray(null);\n  }\n\n  public static function toBool(value : String) : Bool {\n    return BoolTransform.toBool(null);\n  }\n\n  public static function toDate(value : String) : Date {\n    return DateTransform.toDate(null);\n  }\n\n  public static function toFloat(value : String) : Float {\n    return FloatTransform.toFloat(null);\n  }\n\n  public static function toObject(value : String) : {} {\n    return ObjectTransform.toObject(null);\n  }\n\n  public static function toString(value : String) : String {\n    return StringTransform.toString(null);\n  }\n\n  public static function toCode(value : String) : String {\n    value = toReference(value);\n    return '' == value ? '' : '$.$value';\n  }\n\n  public static function toReference(value : String) : String {\n    return null == value ? '' : value;\n  }\n}","package cards.types;\n\nusing StringTools;\n\nclass StringTransform {\n  public static function toArray(value : String) : Array<Dynamic> {\n    return toString(value).split(',').map(StringTools.trim);\n  }\n\n  public static function toBool(value : String) : Bool {\n    return switch toString(value).trim().toLowerCase() {\n      case '', 'off', 'no', 'false', '0': false;\n      case _: true;\n    };\n  }\n\n  public static function toDate(value : String) : Date {\n    return try {\n      Date.fromString(value);\n    } catch(e : Dynamic) {\n      Date.now();\n    };\n  }\n\n  public static function toFloat(value : String) : Float {\n    return Std.parseFloat(toString(value));\n  }\n\n  public static function toObject(value : String) : {} {\n    return ArrayTransform.toObject([toString(value)]);\n  }\n\n  public static function toString(value : String) : String {\n    return null != value ? value : '';\n  }\n\n  public static function toCode(value : String) : String {\n    return '\"' + toString(value).replace('\"', '\\\\\"') + '\"';\n  }\n\n  public static function toReference(value : Array<Dynamic>) : String {\n    return '';\n  }\n}","package cards.types;\n\nimport cards.types.ArrayTransform;\nimport cards.types.BoolTransform;\nimport cards.types.DateTransform;\nimport cards.types.FloatTransform;\nimport cards.types.ObjectTransform;\nimport cards.types.StringTransform;\nimport cards.model.SchemaType;\n\nclass TypeTransform {\n  public static function transform(srcType : SchemaType, dstType : SchemaType) : Dynamic -> Dynamic {\n    return switch srcType {\n      case ArrayType(_):\n        switch dstType {\n          case ArrayType(_):\n            ArrayTransform.toArray;\n          case BoolType:\n            ArrayTransform.toBool;\n          case DateType:\n            ArrayTransform.toDate;\n          case FloatType:\n            ArrayTransform.toFloat;\n          case ObjectType(_):\n            ArrayTransform.toObject;\n          case StringType:\n            ArrayTransform.toString;\n          case CodeType:\n            ArrayTransform.toCode;\n          case ReferenceType:\n            ArrayTransform.toReference;\n        }\n      case BoolType:\n        switch dstType {\n          case ArrayType(_):\n            BoolTransform.toArray;\n          case BoolType:\n            BoolTransform.toBool;\n          case DateType:\n            BoolTransform.toDate;\n          case FloatType:\n            BoolTransform.toFloat;\n          case ObjectType(_):\n            BoolTransform.toObject;\n          case StringType:\n            BoolTransform.toString;\n          case CodeType:\n            BoolTransform.toCode;\n          case ReferenceType:\n            BoolTransform.toReference;\n        }\n      case DateType:\n        switch dstType {\n          case ArrayType(_):\n            DateTransform.toArray;\n          case BoolType:\n            DateTransform.toBool;\n          case DateType:\n            DateTransform.toDate;\n          case FloatType:\n            DateTransform.toFloat;\n          case ObjectType(_):\n            DateTransform.toObject;\n          case StringType:\n            DateTransform.toString;\n          case CodeType:\n            DateTransform.toCode;\n          case ReferenceType:\n            DateTransform.toReference;\n        }\n      case FloatType:\n        switch dstType {\n          case ArrayType(_):\n            FloatTransform.toArray;\n          case BoolType:\n            FloatTransform.toBool;\n          case DateType:\n            FloatTransform.toDate;\n          case FloatType:\n            FloatTransform.toFloat;\n          case ObjectType(_):\n            FloatTransform.toObject;\n          case StringType:\n            FloatTransform.toString;\n          case CodeType:\n            FloatTransform.toCode;\n          case ReferenceType:\n            FloatTransform.toReference;\n        }\n      case ObjectType(_):\n        switch dstType {\n          case ArrayType(_):\n            ObjectTransform.toArray;\n          case BoolType:\n            ObjectTransform.toBool;\n          case DateType:\n            ObjectTransform.toDate;\n          case FloatType:\n            ObjectTransform.toFloat;\n          case ObjectType(_):\n            ObjectTransform.toObject;\n          case StringType:\n            ObjectTransform.toString;\n          case CodeType:\n            ObjectTransform.toCode;\n          case ReferenceType:\n            ObjectTransform.toReference;\n        }\n      case StringType:\n        switch dstType {\n          case ArrayType(_):\n            StringTransform.toArray;\n          case BoolType:\n            StringTransform.toBool;\n          case DateType:\n            StringTransform.toDate;\n          case FloatType:\n            StringTransform.toFloat;\n          case ObjectType(_):\n            StringTransform.toObject;\n          case StringType:\n            StringTransform.toString;\n          case CodeType:\n            StringTransform.toCode;\n          case ReferenceType:\n            StringTransform.toReference;\n        }\n      case CodeType:\n        switch dstType {\n          case ArrayType(_):\n            CodeTransform.toArray;\n          case BoolType:\n            CodeTransform.toBool;\n          case DateType:\n            CodeTransform.toDate;\n          case FloatType:\n            CodeTransform.toFloat;\n          case ObjectType(_):\n            CodeTransform.toObject;\n          case StringType:\n            CodeTransform.toString;\n          case CodeType:\n            CodeTransform.toCode;\n          case ReferenceType:\n            CodeTransform.toReference;\n        }\n      case ReferenceType:\n        switch dstType {\n          case ArrayType(_):\n            ReferenceTransform.toArray;\n          case BoolType:\n            ReferenceTransform.toBool;\n          case DateType:\n            ReferenceTransform.toDate;\n          case FloatType:\n            ReferenceTransform.toFloat;\n          case ObjectType(_):\n            ReferenceTransform.toObject;\n          case StringType:\n            ReferenceTransform.toString;\n          case CodeType:\n            ReferenceTransform.toCode;\n          case ReferenceType:\n            ReferenceTransform.toReference;\n        }\n    }\n  }\n}","package cards.ui;\n\nimport cards.components.Component;\nimport cards.components.ComponentOptions;\nimport cards.ui.fragments.Block;\nimport cards.ui.fragments.ReadonlyBlock;\nimport cards.ui.fragments.Fragment;\nimport cards.ui.fragments.InlineText;\nimport thx.stream.Value;\nimport haxe.ds.Option;\nusing thx.Options;\nusing thx.stream.Bus;\nusing thx.stream.Emitter;\n\nclass Article {\n  public var component(default, null) : Component;\n  public var fragment(default, null) : Value<Option<Fragment>>;\n\n  // TODO: possibly remove\n  var fragmentStream : Bus<Fragment>;\n  var fragmentsMap : Map<Fragment, Void -> Void>;\n\n  public function new(options : ComponentOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<article></article>';\n    component = new Component(options);\n    fragmentsMap = new Map();\n    fragmentStream = new Bus();\n    fragment = new Value(None);\n    fragmentStream.toOption().feed(fragment);\n    var filtered = fragment.filterOption();\n    filtered.previous().subscribe(function(fragment : Fragment) {\n      fragment.active.set(false);\n    });\n    filtered.subscribe(function(fragment : Fragment) {\n      fragment.active.set(true);\n    });\n  }\n\n  function addFragment(fragment : Fragment) {\n    var focusStream = fragment\n          .focus\n          .withValue(true)\n          .map(function(_) : Fragment return fragment)\n          .plug(fragmentStream);\n    fragmentsMap.set(fragment, focusStream.cancel);\n  }\n\n  public function addBlock() {\n    var fragment = new Block({\n        parent : component,\n        container : component.el\n      });\n    addFragment(fragment);\n    addInlineText(fragment);\n    return fragment;\n  }\n\n  public function addInlineText(parent : Block) {\n    var fragment = new InlineText({\n        fragmentParent : parent,\n        container : parent.component.el,\n        defaultText : ''\n      });\n    addFragment(fragment);\n    fragment.focus.set(true);\n  }\n\n  public function addReadonly() {\n    var fragment = new ReadonlyBlock({\n        parent : component,\n        container : component.el\n      });\n    addFragment(fragment);\n    return fragment;\n  }\n\n  public function removeFragment(fragment : Fragment) {\n    if(this.fragment.get().equalsValue(fragment))\n      this.fragment.set(None);\n    var finalizer = fragmentsMap.get(fragment);\n    fragmentsMap.remove(fragment);\n    finalizer();\n  }\n}","package cards.ui;\n\nimport cards.model.Model;\nimport cards.components.Component;\nimport cards.ui.fragments.FragmentMapper;\nimport js.html.DOMElement as Element;\nimport udom.Dom;\nusing thx.stream.Emitter;\n\nclass Card {\n  public static function create(model : Model, container : Element, mapper : FragmentMapper) {\n    var card = new Component({\n          template : '<div class=\"card\"><div class=\"doc\"></div><aside><div class=\"context\"></div><div class=\"model\"></div></aside></div>'\n        }),\n        modelView = new ModelView(),\n        document = new Document({ el : Query.first('.doc', card.el) }),\n        context = new ContextView(\n          document,\n          mapper,\n          Query.first('.context', card.el),\n          document.component\n//          model,\n//          modelView,\n//          mapper\n        );\n\n    modelView.component.appendTo(Query.first('.model', card.el));\n\n    //modelView.schema.subscribe(model.schemaEventSubscriber);\n    modelView.data.subscribe(model.dataEventSubscriber);\n\n    card.appendTo(container);\n\n    document.article.addBlock();\n\n    return {\n      card : card,\n      modelView : modelView,\n      document : document,\n      context : context\n    };\n  }\n}","package cards.ui;\n\nimport cards.components.Component;\nimport cards.ui.fragments.FragmentMapper;\nimport cards.ui.input.RuntimeObjectEditor;\nimport js.html.DOMElement as Element;\nimport cards.ui.fragments.Fragment;\nimport cards.properties.ValueProperty;\nusing thx.stream.Emitter;\n\nclass ContextView {\n  var editor : RuntimeObjectEditor;\n  var container : Element;\n  var parent : Component;\n  var mapper : FragmentMapper;\n  public function new(document : Document, mapper : FragmentMapper, container : Element, parent : Component) {\n    this.container = container;\n    this.parent = parent;\n    this.mapper = mapper;\n    resetEditor();\n    document.article.fragment.either(setFragmentStatus, resetEditor);\n  }\n\n  function resetEditor() {\n    if(null != editor)\n      editor.dispose();\n    container.innerHTML = \"\";\n  }\n\n  function setFragmentStatus(fragment : Fragment) {\n    resetEditor();\n    trace(fragment);\n    var fields = mapper\n      .getAttachedPropertiesForFragment(fragment)\n      .map(function(info) {\n        //var value = cast(fragment.component.properties.get(info.name), ValueProperty<Dynamic>);\n        return {\n          name : info.name,\n          type : info.type,\n          optional : false\n        };\n      })\n      .concat(\n        mapper.getAttachablePropertiesForFragment(fragment)\n          .map(function(info) {\n            return {\n              name : info.name,\n              type : info.type,\n              optional : true\n            };\n          })\n      );\n    editor = new RuntimeObjectEditor(container, parent, fields);\n    // TODO wire field values somehow\n  }\n}","package cards.ui;\n\nimport cards.components.Component;\nimport cards.components.ComponentOptions;\nimport cards.ui.fragments.Block;\nimport cards.ui.fragments.Fragment;\nimport cards.ui.fragments.InlineText;\nimport cards.ui.widgets.Toolbar;\nimport cards.ui.widgets.Statusbar;\nusing thx.stream.Emitter;\nusing thx.Options;\nusing thx.stream.dom.Dom;\n\nclass Document {\n  public var component(default, null) : Component;\n  public var toolbar(default, null) : Toolbar;\n  public var article(default, null) : Article;\n  public var statusbar(default, null) : Statusbar;\n\n  public function new(options : ComponentOptions) {\n    component = new Component(options);\n    toolbar   = new Toolbar({ parent : component, container : component.el });\n    article   = new Article({ parent : component, container : component.el });\n    statusbar = new Statusbar({ parent : component, container : component.el });\n\n\n    // TODO: change this to components\n    article.fragment\n      .map(function(r) switch r {\n        case Some(v):\n          return '$v';\n        case None:\n          return 'no fragment selected';\n      })\n      .subscribe(statusbar.left.component.el.subscribeHTML());\n\n    toolbar.left.addButton('block', Config.icons.add)\n      .clicks.subscribe(function(_) article.addBlock());\n\n    var buttonAddText = toolbar.left.addButton('text', Config.icons.add);\n    buttonAddText\n      .clicks.subscribe(function(_) {\n        var block = getNearestBlock(article.fragment.get().toValue());\n        if(null == block)\n          return;\n        article.addInlineText(block);\n      });\n    buttonAddText.enabled.set(false);\n    article.fragment\n      .map(function(r) switch r {\n        case Some(v):\n          return getNearestBlock(v) != null;\n        case None:    return false;\n      })\n      .feed(buttonAddText.enabled);\n\n    var buttonRemove = toolbar.right.addButton('', Config.icons.remove);\n    buttonRemove.enabled.set(false);\n    buttonRemove.clicks.subscribe(function(_) {\n      article.fragment.get().toValue().component.destroy();\n      article.fragment.set(None);\n    });\n    article.fragment.toBool().feed(buttonRemove.enabled);\n  }\n\n  static function getNearestBlock(fragment : Fragment) : Block {\n    if(null == fragment)\n      return null;\n    if(Std.is(fragment, Block))\n      return cast fragment;\n    return getNearestBlock(fragment.parent);\n  }\n}","package cards.ui;\n\nimport cards.types.TypeTransform;\nimport cards.ui.input.AnonymousObjectEditor;\nimport cards.ui.input.DiffAt;\nimport cards.ui.input.Path;\nimport cards.ui.input.TypedValue;\nimport js.html.DOMElement as Element;\nusing thx.stream.Emitter;\nimport cards.components.Component;\nimport cards.model.DataEvent;\nimport cards.model.SchemaEvent;\nimport cards.model.SchemaType;\nimport cards.ui.widgets.Toolbar;\nimport udom.Dom;\nimport thx.stream.Bus;\n\nclass ModelView {\n  public var component(default, null) : Component;\n  //public var schema(default, null) : Emitter<SchemaEvent>;\n  public var data(default, null) : Emitter<DataEvent>;\n\n  //var schemaBus : Bus<SchemaEvent>;\n  var dataBus : Bus<DataEvent>;\n  var editor : AnonymousObjectEditor;\n  public function new() {\n    component = new Component({\n      template : '<div class=\"modelview\"></div>'\n    });\n\n    //schema = this.schemaBus = new Bus();\n    data = this.dataBus = new Bus();\n\n    editor = new AnonymousObjectEditor(component.el, component);\n    editor.diff.subscribe(function(d) switch [d.diff, d.path] {\n      case [Add, path]:\n        //schemaBus.pulse(SchemaEvent.AddField(path.toString(), editor.typeAt(path)));\n      case [Remove, path]:\n        //schemaBus.pulse(SchemaEvent.DeleteField(path.toString()));\n      case [Set(v), path]:\n        dataBus.pulse(DataEvent.SetValue(path, v.asValue(), v.asType()));\n    });\n  }\n\n  public function setField(path : Path, value : Dynamic, type : SchemaType) {\n    if(path == \"\" || path == null)\n      return;\n      editor.diff.pulse(new DiffAt(path, Set(new TypedValue(type, value))));\n  }\n}","package cards.ui.editors;\n\nusing thx.stream.Emitter;\nimport js.html.DOMElement as Element;\nimport js.html.Event;\nimport cards.components.Component;\nimport cards.components.ComponentOptions;\nimport thx.stream.Value;\nimport cards.properties.Text;\nimport cards.model.SchemaType;\nusing thx.stream.dom.Dom;\nimport js.Browser;\n\nclass TextEditor implements Editor<String> {\n  public var component(default, null) : Component;\n  public var focus(default, null) : Value<Bool>;\n  public var value(default, null) : Value<String>;\n  public var type(default, null) : SchemaType;\n  var cancel : Void -> Void;\n  public function new(options : TextEditorOptions) {\n    type = StringType;\n    if(null == options.defaultText)\n      options.defaultText = '';\n    if(null == options.placeHolder)\n      options.placeHolder = '';\n    if(null == options.el && null == options.template)\n      options.template = '<div></div>';\n    if(null == options.inputEvent)\n      options.inputEvent = function(component : Component) return component.el.streamEvent('input');\n\n    component = new Component(options);\n    component.el.classList.add('editor');\n    component.el.classList.add('text');\n    component.el.setAttribute('tabindex', '1');\n    component.el.setAttribute('contenteditable', 'true');\n    component.el.setAttribute('placeholder', options.placeHolder);\n\n    // PREVENT SELECTION DRAG AND DROP\n    component.el.addEventListener('dragstart', function(e) e.preventDefault(), false);\n    component.el.addEventListener('drop', function(e) e.preventDefault(), false);\n\n    // TODO: find out how to set the content of :before programmatically\n    component.el.style.content = options.placeHolder;\n\n    var text = new Text(component, options.defaultText);\n\n    value = text.stream;\n    options.inputEvent(component)\n      .map(function(_) return text.component.el.textContent)\n      .feed(value);\n\n    focus = new Value(false);\n    // TODO: adding contenteditable dynamically doesn't work very well in FF\n    //focus.subscribe(component.el.subscribeToggleAttribute('contenteditable', 'true'));\n    focus.withValue(true).subscribe(component.el.subscribeFocus());\n    var focusStream = focus\n      .withValue(true)\n      .subscribe(function(_) {\n        Browser.document.getSelection().selectAllChildren(component.el);\n      });\n\n    component.el.streamFocus().feed(focus);\n    cancel = function() {\n      text.dispose();\n      focusStream.cancel();\n    };\n\n    var empty = new Value(options.defaultText == '');\n    component.el.streamEvent('input')\n      .map(function(_) return text.component.el.textContent == '')\n      .merge(value.map(function(t) return t == ''))\n      .feed(empty);\n    empty.subscribe(component.el.subscribeToggleClass('empty'));\n\n    // PASTE EVENT\n    component.el.streamEvent(\"paste\")\n      .map(function(ev) {\n        var e : Dynamic = ev;\n        e.preventDefault();\n        var data      = null == e.clipboardData ? \"\" : e.clipboardData.getData(\"text/plain\"),\n            current   = value.get(),\n            selection = Browser.window.getSelection(),\n            start     = selection.anchorOffset,\n            end       = untyped selection.extentOffset;\n        return current.substr(0, start) + data + current.substr(end);\n      })\n      .filter(function(v) return v.length > 0)\n      .feed(value);\n  }\n\n  public function destroy() {\n    value.clear();\n    component.destroy();\n    cancel();\n  }\n}\n\ntypedef TextEditorOptions = {> ComponentOptions,\n  defaultText : String,\n  ?placeHolder : String,\n  ?inputEvent : Component -> Emitter<Event>\n}\n","package cards.ui.fragments;\n\nimport thx.stream.Value;\nimport cards.components.Component;\nimport cards.properties.ToggleClass;\nimport cards.ui.editors.TextEditor;\nusing thx.stream.dom.Dom;\n\nclass Block implements Fragment {\n  public var name(default, null) : String = 'block';\n  public var component(default, null) : Component;\n  public var focus(default, null) : Value<Bool>;\n  public var active(default, null) : Value<Bool>;\n  public var uid(default, null) : String;\n  public var parent(default, null) : Fragment;\n  public function new(options : BlockOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<div class=\"block\" tabindex=\"1\"></div>';\n    parent = options.fragmentParent;\n    uid = null != options.uid ? options.uid : thx.Uuid.create();\n    component = new Component(options);\n    active = new Value(false);\n    active.feed(new ToggleClass(component, 'active').stream);\n\n    focus = new Value(false);\n    component.el.streamFocus().feed(focus);\n  }\n\n  public function destroy() {\n    focus.clear();\n    component.destroy();\n  }\n\n  public function toString()\n    return name;\n}\n\ntypedef BlockOptions = {> FragmentOptions,\n\n}","package cards.ui.fragments;\n\nimport cards.properties.ValueProperties;\nimport cards.ui.fragments.FragmentProperties;\nusing thx.Iterators;\n\nclass FragmentMapper {\n  public var fragments(default, null) : FragmentProperties;\n  public var values(default, null) : ValueProperties;\n  public function new(fragments : FragmentProperties, values : ValueProperties) {\n    this.fragments = fragments;\n    this.values = values;\n  }\n\n  public function getValuePropertyInfoForFragment(fragment : FragmentName)\n    return fragments.getAssociations(fragment)\n      .map(values.get);\n\n\n  public function getAttachedPropertiesForFragment(fragment : Fragment)\n    return fragments.getAssociations(fragment)\n      .filter(function(name) return fragment.component.properties.exists(name))\n      .map(values.get);\n\n  public function getAttachablePropertiesForFragment(fragment : Fragment)\n    return fragments.getAssociations(fragment)\n      .filter(function(name) return !fragment.component.properties.exists(name))\n      .map(values.get);\n}","package cards.ui.fragments;\n\nabstract FragmentName(String) {\n  @:from public inline static function fromFragment(fragment : Fragment)\n    return new FragmentName(fragment.name);\n\n  @:from public inline static function fromString(name : String)\n    return new FragmentName(name);\n\n  public inline function new(name : String)\n    this = name;\n\n  @:to public inline function toString()\n    return this;\n}","package cards.ui.fragments;\n\nimport thx.Set;\nimport cards.properties.PropertyName;\nusing thx.Iterables;\n\nclass FragmentProperties {\n  var map : Map<String, Set<String>>;\n  public function new() {\n    map = new Map();\n  }\n\n  public function associate(fragment : FragmentName, property : PropertyName) {\n    var s = map.get(fragment);\n    if(null == s)\n      map.set(fragment, s = []);\n    s.add(property);\n  }\n\n  public function associateMany(fragment : FragmentName, properties : Iterable<PropertyName>)\n    properties.map(associate.bind(fragment, _));\n\n  public function getAssociations(fragment : FragmentName) : Iterator<String> {\n    var s = map.get(fragment);\n    if(s == null)\n      s = [];\n    return s.iterator();\n  }\n}","package cards.ui.fragments;\n\nimport thx.stream.Value;\nimport cards.components.Component;\nimport cards.properties.ToggleClass;\nimport cards.ui.editors.TextEditor;\n\nclass InlineText implements Fragment {\n  public var name(default, null) : String = 'text';\n  public var editor(default, null) : TextEditor;\n  public var component(default, null) : Component;\n  public var focus(default, null) : Value<Bool>;\n  public var active(default, null) : Value<Bool>;\n  public var uid(default, null) : String;\n  public var parent(default, null) : Fragment;\n  public function new(options : InlineTextOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<span class=\"text\"></span>';\n    uid = null != options.uid ? options.uid : thx.Uuid.create();\n    if(null == options.placeHolder)\n      options.placeHolder = 'type some content';\n    parent = options.fragmentParent;\n    editor = new TextEditor(options);\n    active = new Value(false);\n    active.feed(new ToggleClass(editor.component, 'active').stream);\n    focus = editor.focus;\n    component = editor.component;\n  }\n\n  public function destroy() {\n    editor.destroy();\n  }\n\n  public function toString()\n    return name;\n}\n\ntypedef InlineTextOptions = {> TextEditorOptions,\n  ?uid : String,\n  fragmentParent : cards.ui.fragments.Block\n}\n","package cards.ui.fragments;\n\nimport thx.stream.Value;\nimport cards.components.Component;\nimport cards.components.ComponentOptions;\nusing thx.stream.dom.Dom;\nusing thx.stream.Emitter;\nusing thx.stream.IStream;\n\nclass ReadonlyBlock implements Fragment {\n  public var name(default, null) : String = 'readonly';\n  public var component(default, null) : Component;\n  public var focus(default, null) : Value<Bool>;\n  public var active(default, null) : Value<Bool>;\n  public var uid(default, null) : String;\n  public var parent(default, null) : Fragment;\n  var focusStream : IStream;\n  public function new(options : FragmentOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<div class=\"readonly block\" tabindex=\"1\">readonly</div>';\n\n    component = new Component(options);\n    focus = new Value(false);\n    active = new Value(false);\n    uid = null != options.uid ? options.uid : thx.Uuid.create();\n\n    focusStream = component.el.streamFocus().feed(focus);\n\n    active.subscribe(component.el.subscribeToggleClass('active'));\n  }\n\n  public function destroy() {\n    focusStream.cancel();\n    component.destroy();\n  }\n\n  public function toString()\n    return name;\n}","package cards.ui.input;\n\nimport cards.components.Component;\nimport cards.components.ComponentOptions;\nimport cards.model.SchemaType;\nimport thx.stream.Bus;\nimport thx.stream.Value;\n\n// TODO: add interface IRoutedEditor to support path\nclass Editor implements IEditor {\n  public var stream(default, null) : Bus<TypedValue>;\n  public var type(default, null) : SchemaType;\n  public var focus(default, null) : Value<Bool>;\n  public var component(default, null) : Component;\n\n  public function new(type : SchemaType, options : ComponentOptions) {\n    this.stream    = new Bus(true, TypedValue.equal);\n    this.type      = type;\n    this.focus     = new Value(false);\n    this.component = new Component(options);\n  }\n\n  public function dispose() {\n    stream.clear();\n    focus.clear();\n    component.destroy();\n  }\n\n  public function toString()\n    return Type.getClassName(Type.getClass(this)).split('.').pop();\n}","package cards.ui.input;\n\nimport cards.ui.input.Path;\nimport thx.stream.Bus;\nimport cards.model.SchemaType;\nimport cards.components.ComponentOptions;\n\nclass RouteEditor extends Editor implements IRouteEditor {\n  public var diff(default, null) : Bus<DiffAt>;\n\n  public function new(type : SchemaType, options : ComponentOptions) {\n    super(type, options);\n    diff = new Bus();\n  }\n\n  override public function dispose() {\n    super.dispose();\n    diff.clear();\n  }\n\n  public function typeAt(path : Path) : SchemaType {\n    return throw 'abstract method';\n  }\n}","package cards.ui.input;\n\nimport cards.components.Component;\nimport cards.model.SchemaType;\nimport cards.ui.widgets.Toolbar;\nimport js.Browser;\nimport js.html.DOMElement as Element;\nimport js.html.TableCellElement;\nimport js.html.TableElement;\nimport haxe.ds.Option;\nusing thx.Arrays;\nusing thx.Options;\nusing thx.stream.Emitter;\nimport thx.stream.Value;\nusing udom.Dom;\n\nclass BaseObjectEditor extends RouteEditor {\n  var fields : Array<FieldInfo>;\n  var object : {};\n  var editors : Map<String, IEditor>;\n  var defMap : Map<String, { field : FieldInfo, index : Int }>;\n  var table : TableElement;\n  var currentField : Value<Option<String>>;\n  var toolbar : Toolbar;\n  public function new(container : Element, parent : Component, fields : Array<FieldInfo>) {\n    this.object = {};\n    editors = new Map();\n    defMap = new Map();\n    currentField = Value.createOption();\n    var options = {\n      template  : '<div class=\"editor table\"></div>',\n      container : container,\n      parent : parent\n    };\n    super(ObjectType([]), options);\n    this.fields = [];\n\n    toolbar = new Toolbar({\n      parent : component,\n      container : component.el\n    });\n\n    var buttonRemove = toolbar.right.addButton('', Config.icons.remove);\n    buttonRemove.enabled.set(false);\n\n    currentField\n      .map(function(cur) return switch cur {\n        case None: false;\n        case Some(name): defMap.get(name).field.optional;\n      })\n      .feed(buttonRemove.enabled);\n\n    buttonRemove.clicks\n      .subscribe(function(_) {\n        var name = currentField.get().toValue();\n        if(null == name)\n          return;\n        removeField(name);\n      });\n\n    table = Browser.document.createTableElement();\n    component.el.appendChild(table);\n\n    diff.subscribe(function(d) {\n      switch [d.path.asArray(), d.diff] {\n        case [[Field(name)], Remove]:\n          if(editors.exists(name))\n            removeField(name);\n        case [[Field(name)], Add]:\n          ensureField(name);\n        case [[Field(name)], Set(tv)] if(Type.enumEq(tv.asType(), defMap.get(name).field.type)):\n          ensureField(name).stream.pulse(tv);\n        case [path, diff] if(path.length > 0):\n          var first = path.shift();\n          switch first {\n            case Field(name) if(switch defMap.get(name).field.type {\n                case ObjectType(_), ArrayType(_): true;\n                case _: false;\n              }):\n              (cast ensureField(name) : IRouteEditor)\n                .diff.pulse(new DiffAt(path, diff));\n            case _:\n              throw 'unable to forward $d within ObjectEditor';\n          }\n        case [[], Set(tv)] if(Type.enumEq(type, tv.asType())):\n          // TODO: set value?\n        case _:\n          trace(d.path.toString());\n          trace(switch d.diff {\n            case Set(d): Std.string(d);\n            case _: Std.string(d.diff);\n          });\n          throw 'unable to assign $d within ObjectEditor';\n      }\n      pulse();\n    });\n\n    fields.mapi(function(field, i) {\n      addFieldDefinition(field, i);\n    });\n/*\n    currentField\n      .toBool()\n      .feed(focus);\n*/\n  }\n\n  function ensureField(name : String) {\n    if(!editors.exists(name))\n      realizeField(name);\n    return editors.get(name);\n  }\n\n  public function addFieldDefinition(field : FieldInfo, ?index : Int) {\n    checkUnique(field.name);\n    if(null == index)\n      index = fields.length;\n    defMap.set(field.name, { field : field, index : index });\n    fields.push(field);\n    this.type = ObjectType(fields);\n    if(!field.optional)\n      realizeField(field.name);\n  }\n\n  function createFieldLabel(parent : Component, container : Element, name : String)\n    container.textContent = name;\n\n  public function realizeField(name : String, ?type : SchemaType) {\n    if(editors.exists(name))\n      throw 'field $name already realized';\n    var def = fields.find(function(field) return field.name == name);\n    if(null == def) throw 'unable to realize $name because it is not defined in ObjectType';\n    if(null == type)\n      type = def.type;\n    var editor = switch type {\n      case ObjectType(_), ArrayType(_):\n        var rowh = Browser.document.createTableRowElement(),\n            rowd = Browser.document.createTableRowElement(),\n            th : TableCellElement = cast Browser.document.createElement('th'),\n            td : TableCellElement = cast Browser.document.createElement('td');\n        var index = defMap.get(name).index;\n        rowh.setAttribute('data-index', cast index);\n        rowd.setAttribute('data-index', cast index);\n        th.colSpan = 2;\n        createFieldLabel(component, th, name);\n        th.className = \"composite\";\n        td.colSpan = 2;\n        td.className = \"composite\";\n        var editor = EditorFactory.create(type, td, component);\n        rowh.appendChild(th);\n        rowd.appendChild(td);\n        var ref = findRef(table, index);\n        if(null != ref) {\n          table.insertBefore(rowd, ref);\n        } else {\n          table.appendChild(rowd);\n        }\n        table.insertBefore(rowh, rowd);\n        editor;\n      case _:\n        var row = Browser.document.createTableRowElement(),\n            th  = Browser.document.createElement('th'),\n            td  = Browser.document.createElement('td');\n        var index = defMap.get(name).index;\n        row.setAttribute('data-index', cast index);\n        createFieldLabel(component, th, name);\n        th.className = \"primitive\";\n        td.className = \"primitive\";\n        var editor = EditorFactory.create(type, td, component);\n        row.appendChild(th);\n        row.appendChild(td);\n        var ref = findRef(table, index);\n        if(null != ref) {\n          table.insertBefore(row, ref);\n        } else {\n          table.appendChild(row);\n        }\n        editor;\n    }\n    editors.set(name, editor);\n\n    editor.focus.feed(focus);\n\n    editor.focus\n      .withValue(true)\n      .map(function(_) return def.name)\n      .toOption()\n      .feed(currentField);\n\n    editor.stream\n      .map(function(v)\n        return new DiffAt(name, Set(v)))\n      .plug(diff);\n\n    diff.pulse(new DiffAt(name, Add));\n  }\n\n  static function findRef(table : TableElement, index : Int) {\n    var trs = Query.all('tr', table).childrenOf(table);\n    for(tr in trs) {\n      var ref : Int = cast tr.getAttribute(\"data-index\");\n      if(ref > index)\n        return tr;\n    }\n    return null;\n  }\n\n  override public function typeAt(path : Path) {\n    return switch path.asArray() {\n      case [Field(name)]:\n        editors.get(name).type;\n      case [Index(_)]:\n        throw 'invalid path $path';\n      case []:\n        type;\n      case arr:\n        arr = arr.copy();\n        var first = arr.pop();\n        switch first {\n          case Field(name) if(Std.is(editors.get(name), IRouteEditor)):\n            Std.instance(editors.get(name), IRouteEditor).typeAt(arr);\n          case _:\n            throw 'invalid path $arr';\n        }\n    }\n  }\n\n  public function removeField(name : String) {\n    var editor = editors.get(name),\n        def    = defMap.get(name);\n    editor.dispose();\n    editors.remove(name);\n    var rows = Query.all('tr[data-index=\"${def.index}\"]', table).childrenOf(table);\n    rows.copy().map(function(row) {\n      table.removeChild(row);\n    });\n    currentField.set(None);\n  }\n\n  function checkUnique(name : String)\n    for(field in fields)\n      if(name == field.name)\n        throw '$name field already exists in this ObjectType';\n\n  // TODO: pulse passes original object and bad things can happen if it is modified elsewhere\n  function pulse()\n    stream.pulse(new TypedValue(type, object));\n}","package cards.ui.input;\n\nimport cards.ui.input.TypedValue;\nimport cards.ui.widgets.Button;\nimport cards.ui.widgets.Menu;\nimport haxe.ds.Option;\nimport cards.ui.widgets.Toolbar;\nimport cards.model.SchemaType;\nimport js.Browser;\nimport js.html.DOMElement as Element;\nimport js.html.TableCellElement;\nimport js.html.TableElement;\nusing thx.Arrays;\nusing thx.Iterables;\nusing thx.Options;\nusing thx.stream.Emitter;\nusing udom.Dom;\nimport thx.stream.Value;\nimport cards.components.Component;\n\nclass AnonymousObjectEditor extends BaseObjectEditor {\n  public static var defaultTypes(default, null) : Array<{ type : SchemaType, description : String }> = (function() {\n      var types = [\n          { type : StringType,     description : \"text\" },\n          { type : FloatType,      description : \"number\" },\n          { type : DateType,       description : \"date\" },\n          { type : CodeType,       description : \"code\" },\n          { type : BoolType,       description : \"yes/no\" },\n          { type : ObjectType([]), description : \"object\" }\n        ];\n      types = types\n        .concat(types.map(function(o) return {\n          type : ArrayType(o.type),\n          description : 'list of ${o.description}'\n        }))\n        //.concat(types.map(function(o) return {\n        //  type : ArrayType(ArrayType(o.type)),\n        //  description : 'list of list of ${o.description}'\n        //}))\n        ;\n      return types;\n    })();\n  var menuAdd : Menu;\n  var allowedTypes : Array<{ type : SchemaType, description : String }>;\n  public function new(container : Element, parent : Component, ?allowedTypes : Array<{ type : SchemaType, description : String }>) {\n    super(container, parent, []);\n    this.allowedTypes = null == allowedTypes ? defaultTypes : allowedTypes;\n    menuAdd = new Menu({ parent : component });\n    initMenu();\n\n    var buttonAdd = toolbar.left.addButton('', Config.icons.addMenu);\n\n    buttonAdd.clicks\n      .subscribe(function(_) {\n        menuAdd.anchorTo(buttonAdd.component.el);\n        menuAdd.visible.stream.set(true);\n      });\n  }\n\n  function initMenu()\n    allowedTypes.map(function(item) {\n      var button = new Button('add <b>${item.description}</b>');\n      button.clicks\n        .subscribe(function(_) {\n          var name = guessFieldName();\n          addFieldDefinition({ name : name, type : item.type, optional : true });\n          realizeField(name);\n          editors.get(name).focus.set(true);\n        });\n      menuAdd.addItem(button.component);\n    });\n\n  override public function removeField(name : String) {\n    super.removeField(name);\n    fields = fields.filter(function(field) return field.name != name);\n    this.type = ObjectType(fields);\n    defMap.remove(name);\n  }\n\n  override function createFieldLabel(parent : Component, container : Element, name : String) {\n    var editor = new cards.ui.input.FieldNameEditor(container, parent);\n    // TODO: change model\n    editor.stream\n      .map(function(v) return v.asValue())\n      .debounce(10)\n      .window(2, false)\n      .subscribe(function(names) switch names{\n        case [o, n] if(editors.exists(n)): // rename to existing key\n          // put in queue again.\n          // debounce() ensure that the original name is preserved\n          editor.stream.pulse((guessFieldName(n) : TypedValue));\n        case [o, n]: // rename\n          // change definition\n          var def = defMap.get(o);\n          defMap.remove(o);\n          def.field.name = n;\n          defMap.set(n, def);\n\n          // change editor reference\n          editors.remove(o);\n          editors.set(n, editor);\n\n          // set type\n          type = ObjectType(defMap\n            .order(function(a, b) return a.index - b.index)\n            .map(function(v) return v.field));\n        case _:\n          throw 'createFieldLabel should never reach this point';\n      });\n    editor.stream.pulse((name : TypedValue));\n  }\n\n  public function guessFieldName(?prefix = 'field') {\n    var id = 0,\n        t;\n    function assemble(id)\n      return id > 0 ? [prefix, '$id'].join('_') : prefix;\n    while(editors.exists(t = assemble(id))) id++;\n    return t;\n  }\n}","package cards.ui.input;\n\nimport cards.ui.widgets.*;\nimport cards.model.SchemaType;\nimport js.Browser;\nimport js.html.DOMElement as Element;\nimport js.html.LIElement;\nimport cards.ui.input.EditorFactory;\nimport thx.stream.Value;\nusing thx.stream.Emitter;\nimport haxe.ds.Option;\nimport js.html.OListElement;\nusing udom.Dom;\nusing thx.Options;\nimport cards.ui.input.Diff;\nimport cards.components.Component;\n\n// TODO\n//  * drag and drop item\n//  * set value at once\n//  * change SchemaType dynamically\nclass ArrayEditor extends RouteEditor {\n  var list : OListElement;\n  var editors : Array<IEditor>;\n  var innerType : SchemaType;\n  var currentIndex : Value<Option<Int>>;\n  var values : Array<Null<Dynamic>>;\n  public function new(container : Element, parent : Component, innerType : SchemaType) {\n    values = [];\n    editors = [];\n    currentIndex = Value.createOption();\n    var options = {\n      template  : '<div class=\"editor array\"></div>',\n      container : container,\n      parent : parent\n    };\n    super(ArrayType(innerType), options);\n    this.innerType = innerType;\n\n    var toolbar = new Toolbar({\n      parent : component,\n      container : component.el\n    });\n\n    // create DOM containers\n    list = Browser.document.createOListElement();\n    var items = Browser.document.createDivElement();\n    items.className = \"items\";\n    component.el.appendChild(items);\n    items.appendChild(list);\n\n    var buttonAdd = toolbar.left.addButton('', Config.icons.add),\n        buttonRemove = toolbar.right.addButton('', Config.icons.remove);\n\n    currentIndex\n      .toBool()\n      .feed(buttonRemove.enabled);\n\n    diff.subscribe(function(d) {\n      switch [d.path.asArray(), d.diff] {\n        case [[Index(i)], Remove]:\n          values.splice(i, 1);\n          removeEditor(i);\n        case [[Index(i)], Add]:\n          values.insert(i, null);\n          createEditor(i);\n        case [[Index(i)], Set(tv)] if(Type.enumEq(tv.asType(), innerType)):\n          values[i] = tv.asValue();\n          setEditor(i, tv);\n        case [path, diff] if(path.length > 0):\n          var first = path.shift();\n          switch first {\n            case Index(index) if(Std.is(editors[index], IRouteEditor)):\n              (cast editors[index] : IRouteEditor).diff.pulse(new DiffAt(path, diff));\n            case _:\n              throw 'unable to forward $d within ArrayEditor';\n          }\n        case [[], Set(tv)] if(Type.enumEq(type, tv.asType())):\n          // TODO: set value?\n        case _:\n          throw 'unable to assign $d within ArrayEditor';\n      }\n      pulse();\n    });\n\n    currentIndex\n      .audit(function(_) {\n        var prev = Query.first('li.active', list).childOf(list);\n        if(null == prev) return;\n        prev.classList.remove('active');\n      })\n      .filterOption()\n      .subscribe(function(index) {\n        var el = Query.first('li:nth-child(${index+1})', list).childOf(list);\n        if(null == el) return;\n        el.classList.add('active');\n      });\n\n    buttonAdd.clicks\n      .subscribe(function(_) {\n        var index = currentIndex.get().toBool() ? currentIndex.get().toValue() + 1 : values.length;\n        diff.pulse(new DiffAt(index, Add));\n        editors[index].focus.set(true);\n      });\n    buttonRemove.clicks\n      .subscribe(function(_) {\n        if(!currentIndex.get().toBool())\n          return;\n        var index = currentIndex.get().toValue();\n        diff.pulse(new DiffAt(index, Remove));\n      });\n  }\n\n  public function pushItem(?value : TypedValue)\n    insertItem(values.length, value);\n\n  public function insertItem(index : Int, ?value : TypedValue) {\n    diff.pulse(new DiffAt(index, Add));\n    if(null != value)\n      diff.pulse(new DiffAt(index, Set(value)));\n  }\n\n  override public function typeAt(path : Path) {\n    return switch path.asArray() {\n      case [Index(_)]:\n        innerType;\n      case []:\n        type;\n      case arr:\n        arr = arr.copy();\n        var first = arr.pop();\n        switch first {\n          case Index(i) if(Std.is(editors[i], IRouteEditor)):\n            Std.instance(editors[i], IRouteEditor).typeAt(arr);\n          case _:\n            throw 'invalid path $arr';\n        }\n    }\n  }\n\n  function createEditor(index : Int) {\n    var item = Browser.document.createLIElement(),\n        ref  = Query.first('li:nth-child(${index+1})', list).childOf(list);\n    if(null == ref)\n      list.appendChild(item);\n    else\n      list.insertBefore(item, ref);\n    var editor = EditorFactory.create(innerType, item, component);\n    editors.insert(index, editor);\n\n    editor.focus\n      .feed(focus);\n\n    editor.focus\n      .withValue(true)\n      .map(function(_) return editor.component.el.parentElement)\n      .map(function(el) return el.getElementIndex())\n      .toOption()\n      .feed(currentIndex);\n\n    editor.stream\n      .filter(function(v) return currentIndex.get().toBool())\n      .map(function(v) return new DiffAt(currentIndex.get().toValue(), Set(v)))\n      .distinct(DiffAt.equal)\n      // don't use plug or the diff stream will be killed when killing the editor\n      .subscribe(function(v) diff.pulse(v));\n  }\n\n  function setEditor(index : Int, value : TypedValue) {\n    editors[index].stream.pulse(value);\n  }\n\n  function removeEditor(index : Int) {\n    var item = Query.first('li:nth-child(${index+1})', list).childOf(list),\n        editor = editors[index];\n    list.removeChild(item);\n    editor.dispose();\n    editors.splice(index, 1);\n    currentIndex.set(None);\n\n    // set focus after removal\n    thx.Timer.delay(function() {\n      if(editors.length == 0)\n        return;\n      if(index == editors.length)\n        index--;\n      editors[index].focus.set(true);\n    }, 10);\n  }\n\n  // TODO: pulse passes original object and bad things can happen if it is modified elsewhere\n  function pulse()\n    stream.pulse(new TypedValue(type, values));\n}","package cards.ui.input;\n\nimport cards.components.ComponentOptions;\nimport cards.model.SchemaType;\nimport js.html.DOMElement as Element;\nimport js.html.InputElement;\nimport udom.Dom.Query;\nusing thx.stream.dom.Dom;\nimport cards.components.Component;\n\nclass BoolEditor extends Editor {\n  public function new(container : Element,parent : Component) {\n    var options = {\n      template  : '<input class=\"editor bool\" placeholder=\"on/off\" type=\"checkbox\" />',\n      container : container,\n      parent : parent\n    };\n    super(BoolType, options);\n\n    var el : InputElement = cast component.el;\n    el.streamEvent('change')\n      .map(function(_) return (el.checked : TypedValue))\n      .plug(stream);\n    el.streamFocus().feed(focus);\n\n    stream.subscribe(function(num) {\n      var v = num.asValue();\n      if(el.value != v)\n        el.value = v;\n    });\n\n    focus.subscribe(el.subscribeFocus());\n  }\n}","package cards.ui.input;\n\nimport cards.components.ComponentOptions;\nimport cards.model.SchemaType;\nimport cards.ui.input.TypedValue;\nimport js.html.DOMElement as Element;\nimport js.html.TextAreaElement;\nimport udom.Dom.Query;\nusing thx.stream.dom.Dom;\nimport cards.components.Component;\n\n// TODO: focus\nclass CodeMirrorEditor extends Editor {\n  var editor : Dynamic;\n  public function new(container : Element, parent : Component) {\n    var options = {\n      template  : '<div class=\"editor code\"></div>',\n      container : container,\n      parent : parent\n    };\n    super(CodeType, options);\n\n    editor = untyped __js__('CodeMirror')(component.el, {\n      mode : \"javascript\",\n      tabSize : 2,\n      lineNumbers : true,\n      tabindex : 1,\n      lineWrapping : true\n\n    });\n    editor.on(\"changes\", changes);\n    editor.on(\"focus\", setFocus);\n    editor.on(\"blur\", blurFocus);\n\n    stream.subscribe(function(text) {\n      var v = text.asValue();\n      if(editor.doc.getValue() != v) {\n        editor.doc.setValue(v);\n      }\n    });\n\n    focus.subscribe(function(_) editor.focus());\n\n    thx.Timer.delay(function() {\n        editor.refresh();\n      }, 10);\n  }\n\n  function changes() {\n    var content = editor.doc.getValue();\n    stream.pulse(new TypedValue(CodeType, content));\n  }\n\n  function setFocus() focus.set(true);\n  function blurFocus() focus.set(false);\n\n  override public function dispose() {\n    super.dispose();\n    editor.off(\"changes\", changes);\n    editor.off(\"focus\", setFocus);\n    editor.off(\"blur\", blurFocus);\n    editor = null;\n  }\n}","package cards.ui.input;\n\nimport cards.components.ComponentOptions;\nimport cards.model.SchemaType;\nimport js.html.DOMElement as Element;\nimport js.html.InputElement;\nimport udom.Dom.Query;\nusing thx.stream.dom.Dom;\n//import thx.date.ISO8601;\nimport cards.components.Component;\n\nclass DateEditor extends Editor {\n  var format : String;\n  public function new(container : Element, parent : Component, useTime = true) {\n    format = useTime ? '%Y-%m-%dT%H:%M' : '%Y-%m-%d';\n    var options = {\n      template  : '<input class=\"editor date\" placeholder=\"insert date\" type=\"${useTime?\"datetime-local\":\"date\"}\" />',\n      container : container,\n      parent : parent\n    };\n    super(DateType, options);\n\n    var el : InputElement = cast component.el;\n    el.streamEvent('change')\n      .map(function(_) return try (Date.fromString(el.value) : TypedValue) catch(e : Dynamic) null)\n      .notNull()\n      .filter(function(v) return !Math.isNaN(v.asValue().getTime()))\n      .plug(stream);\n    el.streamFocus().feed(focus);\n\n    stream.subscribe(function(num) {\n      var v = num.asValue(),\n          s = DateTools.format(v, format);\n      if(el.value != s)\n        el.value = s;\n    });\n\n    focus.subscribe(el.subscribeFocus());\n  }\n}","package cards.ui.input;\n\nimport cards.model.SchemaType;\nusing thx.Dynamics;\nusing thx.Tuple;\n\nabstract DiffAt(Tuple2<Path, Diff>) {\n  public inline function new(path : Path, diff : Diff)\n    this = new Tuple2(path, diff);\n\n  public var path(get, never) : Path;\n  public var diff(get, never) : Diff;\n\n  public inline function get_path() : Path\n    return this._0;\n\n  public inline function get_diff() : Diff\n    return this._1;\n\n  @:op(A==B) public static function equal(a : DiffAt, b : DiffAt) : Bool\n    if(null == a && null == b)\n      return true;\n    else if(null == a || null == b)\n      return false;\n    else\n      return Path.equal(a.path, b.path) && Dynamics.equals(a.diff, b.diff);\n\n  public function toString()\n    return this._0.toString() + ':' + Std.string(this._1);\n}","package cards.ui.input;\n\nimport js.html.DOMElement as Element;\nimport cards.components.Component;\nimport cards.model.SchemaType;\n\nclass EditorFactory {\n  public static function create(type : SchemaType, container : Element, parent : Component) : IEditor {\n    return switch type {\n      case ArrayType(t):\n        new ArrayEditor(container, parent, t);\n      case BoolType:\n        new BoolEditor(container, parent);\n      case CodeType:\n        new CodeMirrorEditor(container, parent);\n      case DateType:\n        new DateEditor(container, parent, false);\n      case FloatType:\n        new NumberEditor(container, parent);\n      case ObjectType(fields):\n        fields.length == 0\n          ? new AnonymousObjectEditor(container, parent)\n          : new ObjectEditor(container, parent, fields);\n      case ReferenceType:\n        new ReferenceEditor(container, parent);\n      case StringType:\n        new TextEditor(container, parent);\n      case _:\n        throw 'Editor for $type has not been implemented yet';\n    }\n  }\n}","package cards.ui.input;\n\nimport cards.components.ComponentOptions;\nimport cards.model.SchemaType;\nimport js.html.DOMElement as Element;\nimport js.html.InputElement;\nimport udom.Dom.Query;\nusing thx.stream.dom.Dom;\nimport cards.components.Component;\n\nclass InputBasedEditor extends Editor {\n  public function new(container : Element, parent : Component, valueType : SchemaType, name : String, ?type : String, ?event : String = 'change', ?extract : InputElement -> TypedValue, ?assign : InputElement -> TypedValue -> Void) {\n    if(null == type)\n      type = name;\n    if(null == extract)\n      extract = function(input) return (input.value : TypedValue);\n    if(null == assign)\n      assign = function(input, value) input.value = value.asValue();\n    var options = {\n      template  : '<input class=\"editor $name\" placeholder=\"$name\" type=\"$type\" />',\n      container : container,\n      parent : parent\n    };\n    super(valueType, options);\n\n    var el : InputElement = cast component.el;\n    el.streamEvent(event)\n      .map(function(_) return extract(el))\n      .plug(stream);\n    el.streamFocus().feed(focus);\n\n    stream.subscribe(function(value) {\n      var v = value.asValue();\n      if(extract(el) != v)\n        assign(el, value);\n    });\n\n    focus.subscribe(el.subscribeFocus());\n  }\n}","package cards.ui.input;\n\nimport cards.model.SchemaType;\nimport js.html.DOMElement as Element;\nimport cards.components.Component;\nimport js.html.KeyboardEvent;\n\n// TODO: limit input to acceptable field value\n// TODO: limit paste values\nclass FieldNameEditor extends InputBasedEditor {\n  //static var pattern = ~/[a-z]_/i;\n  public function new(container : Element, parent : Component) {\n    super(container, parent, FloatType, 'fieldname', 'text', 'change');\n    component.el.addEventListener('keyup', function(e : KeyboardEvent) {\n\n    }, false);\n  }\n}","package cards.ui.input;\n\nimport cards.model.SchemaType;\nimport js.html.DOMElement as Element;\nimport cards.components.Component;\n\nclass NumberEditor extends InputBasedEditor {\n  public function new(container : Element, parent : Component) {\n    super(container, parent, FloatType, 'number', 'number', 'input', function(el) return (el.valueAsNumber : TypedValue));\n  }\n}","package cards.ui.input;\n\nimport cards.components.Component;\nimport cards.model.SchemaType;\nimport cards.ui.widgets.Button;\nimport cards.ui.widgets.Menu;\nimport js.html.DOMElement as Element;\n\nclass ObjectEditor extends BaseObjectEditor {\n  var menuAdd : Menu;\n  var buttonAdd : Button;\n  var inited = false;\n  public function new(container : Element, parent : Component, fields : Array<FieldInfo>) {\n    super(container, parent, fields);\n\n    buttonAdd = toolbar.left.addButton('', Config.icons.addMenu);\n    buttonAdd.enabled.set(false);\n\n    buttonAdd.clicks\n      .subscribe(function(_) {\n        menuAdd.anchorTo(buttonAdd.component.el);\n        menuAdd.visible.stream.set(true);\n      });\n\n    menuAdd = new Menu({ parent : component });\n    inited = true;\n    setAddState();\n  }\n\n  override public function removeField(name : String) {\n    super.removeField(name);\n    setAddState();\n  }\n\n  override public function realizeField(name : String, ?type : SchemaType) {\n    super.realizeField(name, type);\n    setAddState();\n  }\n\n  function setAddState() {\n    if(!inited) return;\n    var fields = this.fields.copy().filter(function(field) {\n      return !editors.exists(field.name);\n    });\n    var enabled = fields.length > 0;\n    buttonAdd.enabled.set(enabled);\n    if(enabled) {\n      menuAdd.clear();\n      fields.map(function(field) {\n        var button = new Button('add <b>${field.name}</b>');\n        button.clicks\n          .subscribe(function(_) {\n            realizeField(field.name);\n            setAddState();\n            editors.get(field.name).focus.set(true);\n          });\n        menuAdd.addItem(button.component);\n      });\n    }\n  }\n}","package cards.ui.input;\n\nusing StringTools;\n\nabstract Path(Array<PathItem>) from Array<PathItem> to Array<PathItem> {\n  inline public function new(arr : Array<PathItem>)\n    this = arr;\n\n  @:from public static function stringAsPath(path : String) : Path\n    return path.replace('[', '.[').split('.')\n      .filter(function(s) return s.length > 0)\n      .map(function(v) {\n        if(v.substr(0,1) == '[')\n          return Index(Std.parseInt(v.substr(1, v.length - 1)));\n        else\n          return Field(v);\n      });\n\n  @:from public static function intAsPath(index : Int)\n    return new Path([Index(index)]);\n\n  @:to public inline function asArray() : Array<PathItem>\n    return this;\n\n  @:to public function toString() {\n    if(null == this)\n      return '';\n    return this.map(function(item) return switch item {\n        case Field(name): name.replace('.', '\\\\.');\n        case Index(pos): '[$pos]';\n      }).join('.').replace('.[', '[');\n  }\n\n  @:op(A==B) public function equal(other : Path) {\n    var other : Array<PathItem> = other;\n    if(this == null || other == null)\n      return false;\n    if(this.length != other.length)\n      return false;\n    for(i in 0...this.length) {\n      if(!Type.enumEq(this[i], other[i]))\n        return false;\n    }\n    return true;\n  }\n\n}\n\nenum PathItem {\n  Field(name : String);\n  Index(pos : Int);\n}\n","package cards.ui.input;\n\nimport cards.model.SchemaType;\nimport js.html.DOMElement as Element;\nimport cards.components.Component;\n\nclass ReferenceEditor extends InputBasedEditor {\n  public function new(container : Element, parent : Component) {\n    super(container, parent, ReferenceType, 'reference', 'text', 'input', function(el) return new TypedValue(ReferenceType, el.value));\n  }\n}","package cards.ui.input;\n\nimport js.html.DOMElement as Element;\nimport cards.components.Component;\nimport cards.model.SchemaType;\nusing thx.stream.Emitter;\n\nclass RuntimeObjectEditor extends ObjectEditor {\n  public function new(container : Element, parent : Component, fields : Array<FieldInfo>) {\n    super(container, parent, fields);\n\n    var buttonValue     = toolbar.center.addButton(null, Config.icons.value),\n        buttonCode      = toolbar.center.addButton(null, Config.icons.code),\n        buttonReference = toolbar.center.addButton(null, Config.icons.reference),\n        buttons         = [buttonValue, buttonCode, buttonReference];\n\n    function disableAllButtons()\n      buttons.map(function(button) button.enabled.set(false));\n\n    currentField\n      .either(function(name) {\n          disableAllButtons();\n          var editor = this.editors.get(name);\n          if(null == editor)\n            return;\n          var toEnable = buttons.copy();\n          if(Type.enumEq(editor.type, ReferenceType))\n            toEnable.remove(buttonReference);\n          else if(Type.enumEq(editor.type, CodeType))\n            toEnable.remove(buttonCode);\n          else\n            toEnable.remove(buttonValue);\n          toEnable.map(function(button) button.enabled.set(true));\n        }, disableAllButtons);\n\n    function changeEditorType(name : String, newType : SchemaType) {\n        removeField(name);\n        realizeField(name, newType);\n        editors.get(name).focus.set(true);\n    }\n\n    currentField\n      .filterOption()\n      .sampleBy(buttonCode.clicks)\n      .left()\n      .subscribe(changeEditorType.bind(_, CodeType));\n\n    currentField\n      .filterOption()\n      .sampleBy(buttonReference.clicks)\n      .left()\n      .subscribe(changeEditorType.bind(_, ReferenceType));\n\n    currentField\n      .filterOption()\n      .sampleBy(buttonValue.clicks)\n      .left()\n      .subscribe(changeEditorType.bind(_, null));\n  }\n}","package cards.ui.input;\n\nimport cards.components.ComponentOptions;\nimport cards.model.SchemaType;\nimport js.html.DOMElement as Element;\nimport js.html.TextAreaElement;\nimport udom.Dom.Query;\nusing thx.stream.dom.Dom;\nimport cards.components.Component;\n\nclass TextEditor extends Editor {\n  function resize() {\n    var el = component.el;\n    el.style.height = \"5px\";\n    el.style.height = (1+el.scrollHeight) + \"px\";\n  }\n\n  public function new(container : Element, parent : Component) {\n    var options = {\n      template  : '<textarea class=\"editor text\" placeholder=\"text\"></textarea>',\n      container : container,\n      parent : parent\n    };\n    super(StringType, options);\n\n    var el : TextAreaElement = cast component.el;\n    el.streamEvent('input')\n      .audit(function(_) resize())\n      .map(function(_) return (el.value : TypedValue))\n      .plug(stream);\n    el.streamFocus().feed(focus);\n\n    stream.subscribe(function(text) {\n      var v = text.asValue();\n      if(el.value != v)\n        el.value = v;\n    });\n\n    focus.subscribe(el.subscribeFocus());\n  }\n}","package cards.ui.input;\n\nimport cards.model.SchemaType;\nimport thx.Tuple;\nimport thx.Dynamics;\n\nabstract TypedValue(Tuple2<SchemaType, Dynamic>) {\n  public inline function new(type : SchemaType, value : Dynamic)\n    this = new Tuple2(type, value);\n\n  @:to public inline function asType()\n    return this._0;\n\n  public inline function asValue() : Dynamic\n    return this._1;\n\n  @:from public static inline function fromString(s : String)\n    return new TypedValue(StringType, s);\n\n  @:from public static inline function fromFloat(f : Float)\n    return new TypedValue(FloatType, f);\n\n  @:from public static inline function fromDate(d : Date)\n    return new TypedValue(DateType, d);\n\n  @:from public static inline function fromBool(b : Bool)\n    return new TypedValue(BoolType, b);\n\n  @:to public function asString()\n    return Std.string(this._1); // TODO: use type transform here\n\n  @:op(A==B) public static function equal(a : TypedValue, b : TypedValue) {\n    if(null == a && null == b)\n      return true;\n    else if(null == a || null == b)\n      return false;\n    else\n      return Dynamics.equals(a.asValue(), b.asValue()) && Dynamics.equals(a.asType(), b.asType());\n  }\n\n  public function toString()\n    return Std.string(this._1) + ' : ' + Std.string(this._0);\n}","package cards.ui.widgets;\n\nimport js.html.Audio;\nimport js.html.MouseEvent;\nusing thx.stream.Emitter;\nimport thx.stream.Value;\nimport cards.components.Component;\nusing thx.stream.dom.Dom;\n\nclass Button {\n  public static var sound(default, null) : Audio = (function() {\n      var audio = new Audio();\n      audio.volume = 0.5;\n      audio.src = 'sound/click.mp3';\n      return audio;\n    })();\n  public var component(default, null) : Component;\n  public var clicks(default, null) : Emitter<MouseEvent>;\n  public var enabled(default, null) : Value<Bool>;\n  var cancel : Void -> Void;\n  public function new(text = '', ?icon : String) {\n    component = new Component({\n      template : null == icon\n        ? '<button>$text</button>'\n        : '<button class=\"fa fa-$icon\">$text</button>'\n    });\n    clicks = component.el.streamClick()\n      .audit(playSound);\n\n    enabled = new Value(true);\n    enabled.negate().subscribe(\n      component.el.subscribeToggleAttribute(\"disabled\", \"disabled\")\n    );\n  }\n\n  function playSound(_) {\n    sound.load();\n    sound.play();\n  }\n\n  public function destroy() {\n    cancel();\n    component.destroy();\n  }\n}","package cards.ui.widgets;\n\nimport js.Browser;\nimport cards.components.Component;\nimport cards.components.ComponentOptions;\nimport js.html.DOMElement as Element;\nimport cards.properties.Visible;\nimport udom.Dom;\n\nclass FrameOverlay {\n  public var component(default, null) : Component;\n  public var visible(default, null) : Visible;\n  public var anchorElement(default, null) : Element;\n  var my : AnchorPoint;\n  var at : AnchorPoint;\n  public function new(options : ComponentOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<div class=\"frame-overlay\"></div>';\n    component = new Component(options);\n    visible = new Visible(component, false);\n    function clear(_) {\n      visible.stream.set(false);\n    }\n    visible.stream\n      .filter(function(b) {\n        return !b;\n      })\n      .subscribe(function(_) {\n        Browser.document.removeEventListener('mouseup', clear, false);\n      });\n    visible.stream\n      .filter(function(b) {\n        return b;\n      })\n      .subscribe(function(_) {\n        Browser.document.addEventListener('mouseup', clear, false);\n        reposition();\n      });\n    anchorElement = Browser.document.body;\n  }\n\n  public function anchorTo(el : Element, ?my : AnchorPoint, ?at : AnchorPoint) {\n    anchorElement = el;\n    this.my = null == my ? TopLeft : my;\n    this.at = null == at ? BottomLeft : at;\n    if(visible.stream.get())\n      reposition();\n  }\n\n  public function reposition() {\n    if(!component.isAttached) {\n      var parent = [Query.first(Config.selectors.app), Browser.document.body].filter(function(v) return null != v).shift();\n      component.appendTo(parent);\n    }\n    var style = component.el.style;\n    style.position = \"fixed\";\n\n    var atrect = anchorElement.getBoundingClientRect(),\n      myrect = component.el.getBoundingClientRect(),\n      x = 0.0,\n      y = 0.0;\n    // AT Y\n    switch at {\n      case TopLeft, Top, TopRight:\n        y = atrect.top;\n      case Left, Center, Right:\n        y = atrect.top + atrect.height / 2;\n      case BottomLeft, Bottom, BottomRight:\n        y = atrect.top + atrect.height;\n    }\n    // AT X\n    switch at {\n      case TopLeft, Left, BottomLeft:\n        x = atrect.left;\n      case Top, Center, Bottom:\n        x = atrect.left + atrect.width / 2;\n      case TopRight, Right, BottomRight:\n        x = atrect.left + atrect.width;\n    }\n    // MY Y\n    switch my {\n      case TopLeft, Top, TopRight:\n        y -= 0;\n      case Left, Center, Right:\n        y -= myrect.height / 2;\n      case BottomLeft, Bottom, BottomRight:\n        y -= myrect.height;\n    }\n    // MY X\n    switch my {\n      case TopLeft, Left, BottomLeft:\n        x -= 0;\n      case Top, Center, Bottom:\n        x -= myrect.width / 2;\n      case TopRight, Right, BottomRight:\n        x -= myrect.width;\n    }\n    style.top  = y + 'px';\n    style.left = x + 'px';\n  }\n}","package cards.ui.widgets;\n\nimport js.Browser;\nimport cards.components.Component;\nimport cards.components.ComponentOptions;\nimport js.html.DOMElement as Element;\nimport udom.Dom;\n\nclass Menu extends FrameOverlay {\n  var items : Map<Component, Element>;\n  var ul : Element;\n  public function new(options : ComponentOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<menu class=\"frame-overlay\"><ul></ul></menu>';\n    super(options);\n    ul = Query.first('ul', component.el);\n    items = new Map();\n  }\n\n  public function clear() {\n    ul.innerHTML = '';\n    items = new Map();\n  }\n\n  public function addItem(item : Component) {\n    var el = Browser.document.createLIElement();\n    item.appendTo(el);\n    component.add(item);\n    ul.appendChild(el);\n    items.set(item, el);\n  }\n\n  public function removeItem(item : Component) {\n    var el = items.get(item);\n    item.detach();\n    ul.removeChild(el);\n  }\n}","package cards.ui.widgets;\n\nimport cards.components.Component;\nimport cards.components.ComponentOptions;\nimport cards.ui.widgets.Toolbar.ToolbarGroup;\nimport udom.Dom;\n\nclass Statusbar {\n  public var component(default, null) : Component;\n  public var left(default, null) : ToolbarGroup;\n  public var center(default, null) : ToolbarGroup;\n  public var right(default, null) : ToolbarGroup;\n  public function new(options : ComponentOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<footer class=\"statusbar\"><div><div class=\"left\"></div><div class=\"center\"></div><div class=\"right\"></div></div></footer>';\n    component = new Component(options);\n    left   = new ToolbarGroup(Query.first('.left',   component.el), component);\n    center = new ToolbarGroup(Query.first('.center', component.el), component);\n    right  = new ToolbarGroup(Query.first('.right',  component.el), component);\n  }\n}","package cards.ui.widgets;\n\nimport udom.Dom;\nimport js.html.DOMElement as Element;\nimport cards.components.Component;\nimport cards.components.ComponentOptions;\n\nclass Toolbar {\n  public var component(default, null) : Component;\n  public var left(default, null) : ToolbarGroup;\n  public var center(default, null) : ToolbarGroup;\n  public var right(default, null) : ToolbarGroup;\n  public function new(options : ComponentOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<header class=\"toolbar\"><div><div class=\"left\"></div><div class=\"center\"></div><div class=\"right\"></div></div></header>';\n    component = new Component(options);\n    left   = new ToolbarGroup(Query.first('.left', component.el), component);\n    center = new ToolbarGroup(Query.first('.center', component.el), component);\n    right  = new ToolbarGroup(Query.first('.right', component.el), component);\n  }\n}\n\nclass ToolbarGroup {\n  public var component(default, null) : Component;\n\n  public function new(el : Element, parent : Component) {\n    this.component =  new Component({ el : el, parent : parent});\n  }\n\n  public function addButton(text = '', ?icon : String) {\n    var button = new Button(text, icon);\n    button.component.appendTo(component.el);\n    component.add(button.component);\n    return button;\n  }\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule( m : String );\n\tFilePos( s : Null<StackItem>, file : String, line : Int );\n\tMethod( classname : String, method : String );\n\tLocalFunction( ?v : Int );\n}\n\n/**\n\tGet informations about the call stack.\n**/\nclass CallStack {\n\t#if js\n\tstatic var lastException:js.Error;\n\n\tstatic function getStack(e:js.Error):Array<StackItem> {\n\t\tif (e == null) return [];\n\t\t// https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\tvar oldValue = (untyped Error).prepareStackTrace;\n\t\t(untyped Error).prepareStackTrace = function (error, callsites :Array<Dynamic>) {\n\t\t\tvar stack = [];\n\t\t\tfor (site in callsites) {\n\t\t\t\tif (wrapCallSite != null) site = wrapCallSite(site);\n\t\t\t\tvar method = null;\n\t\t\t\tvar fullName :String = site.getFunctionName();\n\t\t\t\tif (fullName != null) {\n\t\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tvar className = fullName.substr(0, idx);\n\t\t\t\t\t\tvar methodName = fullName.substr(idx+1);\n\t\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstack.push(FilePos(method, site.getFileName(), site.getLineNumber()));\n\t\t\t}\n\t\t\treturn stack;\n\t\t}\n\t\tvar a = makeStack(e.stack);\n\t\t(untyped Error).prepareStackTrace = oldValue;\n\t\treturn a;\n\t}\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:Dynamic->Dynamic;\n\t#end\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\tvar a = makeStack(untyped __dollar__callstack());\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\tvar a = makeStack( new flash.errors.Error().getStackTrace() );\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif php\n\t\t\treturn makeStack(\"%s\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_call_stack(true);\n\t\t\treturn makeStack(s);\n\t\t#elseif js\n\t\t\ttry {\n\t\t\t\tthrow new js.Error();\n\t\t\t} catch( e : Dynamic ) {\n\t\t\t\tvar a = getStack(e);\n\t\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.lang.Thread.currentThread().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(1, true));\n\t\t#elseif python\n\t\t\tvar stack = [];\n\t\t\tvar infos = python.lib.Traceback.extract_stack();\n\t\t\tinfos.pop();\n\t\t\tinfos.reverse();\n\t\t\tfor (elem in infos)\n\t\t\t\tstack.push(FilePos(null, elem._1, elem._2));\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t**/\n\t#if cpp @:noStack #end /* Do not mess up the exception stack */\n\tpublic static function exceptionStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\treturn makeStack(untyped __dollar__excstack());\n\t\t#elseif as3\n\t\t\treturn new Array();\n\t\t#elseif flash\n\t\t\tvar err : flash.errors.Error = untyped flash.Boot.lastError;\n\t\t\tif( err == null ) return new Array();\n\t\t\tvar a = makeStack( err.getStackTrace() );\n\t\t\tvar c = callStack();\n\t\t\tvar i = c.length - 1;\n\t\t\twhile( i > 0 ) {\n\t\t\t\tif( Std.string(a[a.length-1]) == Std.string(c[i]) )\n\t\t\t\t\ta.pop();\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif php\n\t\t\treturn makeStack(\"%e\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_exception_stack();\n\t\t\treturn makeStack(s);\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.internal.Exceptions.currentException().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// stack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(cs.internal.Exceptions.exception, true));\n\t\t#elseif python\n\t\t\tvar stack = [];\n\t\t\tvar exc = python.lib.Sys.exc_info();\n\t\t\tif (exc._3 != null)\n\t\t\t{\n\t\t\t\tvar infos = python.lib.Traceback.extract_tb(exc._3);\n\t\t\t\tinfos.reverse();\n\t\t\t\tfor (elem in infos)\n\t\t\t\t\tstack.push(FilePos(null, elem._1, elem._2));\n\t\t\t}\n\t\t\treturn stack;\n\t\t#elseif js\n\t\t\treturn untyped __define_feature__(\"haxe.CallStack.exceptionStack\", getStack(lastException));\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tpublic static function toString( stack : Array<StackItem> ) {\n\t\tvar b = new StringBuf();\n\t\tfor( s in stack ) {\n\t\t\tb.add(\"\\nCalled from \");\n\t\t\titemToString(b,s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tprivate static function itemToString( b : StringBuf, s ) {\n\t\tswitch( s ) {\n\t\tcase CFunction:\n\t\t\tb.add(\"a C function\");\n\t\tcase Module(m):\n\t\t\tb.add(\"module \");\n\t\t\tb.add(m);\n\t\tcase FilePos(s,file,line):\n\t\t\tif( s != null ) {\n\t\t\t\titemToString(b,s);\n\t\t\t\tb.add(\" (\");\n\t\t\t}\n\t\t\tb.add(file);\n\t\t\tb.add(\" line \");\n\t\t\tb.add(line);\n\t\t\tif( s != null ) b.add(\")\");\n\t\tcase Method(cname,meth):\n\t\t\tb.add(cname);\n\t\t\tb.add(\".\");\n\t\t\tb.add(meth);\n\t\tcase LocalFunction(n):\n\t\t\tb.add(\"local function #\");\n\t\t\tb.add(n);\n\t\t}\n\t}\n\n\t#if cpp @:noStack #end /* Do not mess up the exception stack */\n\tprivate static function makeStack(s #if cs : cs.system.diagnostics.StackTrace #end) {\n\t\t#if neko\n\t\t\tvar a = new Array();\n\t\t\tvar l = untyped __dollar__asize(s);\n\t\t\tvar i = 0;\n\t\t\twhile( i < l ) {\n\t\t\t\tvar x = s[i++];\n\t\t\t\tif( x == null )\n\t\t\t\t\ta.unshift(CFunction);\n\t\t\t\telse if( untyped __dollar__typeof(x) == __dollar__tstring )\n\t\t\t\t\ta.unshift(Module(new String(x)));\n\t\t\t\telse\n\t\t\t\t\ta.unshift(FilePos(null,new String(untyped x[0]),untyped x[1]));\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\tvar a = new Array();\n\t\t\tvar r = ~/at ([^\\/]+?)\\$?(\\/[^\\(]+)?\\(\\)(\\[(.*?):([0-9]+)\\])?/;\n\t\t\tvar rlambda = ~/^MethodInfo-([0-9]+)$/g;\n\t\t\twhile( r.match(s) ) {\n\t\t\t\tvar cl = r.matched(1).split(\"::\").join(\".\");\n\t\t\t\tvar meth = r.matched(2);\n\t\t\t\tvar item;\n\t\t\t\tif( meth == null ) {\n\t\t\t\t\tif( rlambda.match(cl) )\n\t\t\t\t\t\titem = LocalFunction(Std.parseInt(rlambda.matched(1)));\n\t\t\t\t\telse\n\t\t\t\t\t\titem = Method(cl,\"new\");\n\t\t\t\t} else\n\t\t\t\t\titem = Method(cl,meth.substr(1));\n\t\t\t\tif( r.matched(3) != null )\n\t\t\t\t\titem = FilePos( item, r.matched(4), Std.parseInt(r.matched(5)) );\n\t\t\t\ta.push(item);\n\t\t\t\ts = r.matchedRight();\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif php\n\t\t\tif (!untyped __call__(\"isset\", __var__(\"GLOBALS\", s)))\n\t\t\t\treturn [];\n\t\t\tvar a : Array<String> = untyped __var__(\"GLOBALS\", s);\n\t\t\tvar m = [];\n\t\t\tfor( i in 0...a.length - ((s == \"%s\") ? 2 : 0)) {\n\t\t\t\tvar d = a[i].split(\"::\");\n\t\t\t\tm.unshift(Method(d[0],d[1]));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif cpp\n\t\t\tvar stack : Array<String> = s;\n\t\t\tvar m = new Array<StackItem>();\n\t\t\tfor(func in stack) {\n\t\t\t\tvar words = func.split(\"::\");\n\t\t\t\tif (words.length==0)\n\t\t\t\t\tm.push(CFunction)\n\t\t\t\telse if (words.length==2)\n\t\t\t\t\tm.push(Method(words[0],words[1]));\n\t\t\t\telse if (words.length==4)\n\t\t\t\t\tm.push(FilePos( Method(words[0],words[1]),words[2],Std.parseInt(words[3])));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif js\n\t\t\tif (s == null) {\n\t\t\t\treturn [];\n\t\t\t} else if ((untyped __js__(\"typeof\"))(s) == \"string\") {\n\t\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\t\tvar stack : Array<String> = s.split(\"\\n\");\n\t\t\t\tif( stack[0] == \"Error\" ) stack.shift();\n\t\t\t\tvar m = [];\n\t\t\t\tvar rie10 = ~/^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$/;\n\t\t\t\tfor( line in stack ) {\n\t\t\t\t\tif( rie10.match(line) ) {\n\t\t\t\t\t\tvar path = rie10.matched(1).split(\".\");\n\t\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\t\tvar file = rie10.matched(2);\n\t\t\t\t\t\tvar line = Std.parseInt(rie10.matched(3));\n\t\t\t\t\t\tm.push(FilePos( meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"),meth), file, line ));\n\t\t\t\t\t} else\n\t\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t\treturn m;\n\t\t\t} else {\n\t\t\t\treturn cast s;\n\t\t\t}\n\t\t#elseif cs\n\t\t\tvar stack = [];\n\t\t\tfor (i in 0...s.FrameCount)\n\t\t\t{\n\t\t\t\tvar frame = s.GetFrame(i);\n\t\t\t\tvar m = frame.GetMethod();\n\n\t\t\t\tvar method = StackItem.Method(m.ReflectedType.ToString(), m.Name);\n\n\t\t\t\tvar fileName = frame.GetFileName();\n\t\t\t\tvar lineNumber = frame.GetFileLineNumber();\n\n\t\t\t\tif (fileName != null || lineNumber >= 0)\n\t\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t\telse\n\t\t\t\t\tstack.push(method);\n\t\t\t}\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tLog primarily provides the trace() method, which is invoked upon a call to\n\ttrace() in haxe code.\n**/\nclass Log {\n\n\t/**\n\t\tOutputs `v` in a platform-dependent way.\n\n\t\tThe second parameter `infos` is injected by the compiler and contains\n\t\tinformation about the position where the trace() call was made.\n\n\t\tThis method can be rebound to a custom function:\n\t\t\tvar oldTrace = haxe.Log.trace; // store old function\n\t\t\thaxe.Log.trace = function(v,infos) { // handle trace }\n\t\t\t...\n\t\t\thaxe.Log.trace = oldTrace;\n\n\t\tIf it is bound to null, subsequent calls to trace() will cause an\n\t\texception.\n\t**/\n\tpublic static dynamic function trace( v : Dynamic, ?infos : PosInfos ) : Void {\n\t\t#if flash\n\t\t\t#if (fdb || native_trace)\n\t\t\t\tvar pstr = infos == null ? \"(null)\" : infos.fileName + \":\" + infos.lineNumber;\n\t\t\t\tvar str = flash.Boot.__string_rec(v, \"\");\n\t\t\t\tif( infos != null && infos.customParams != null ) for( v in infos.customParams ) str += \",\" + flash.Boot.__string_rec(v, \"\");\n\t\t\t\tuntyped __global__[\"trace\"](pstr+\": \"+str);\n\t\t\t#else\n\t\t\t\tuntyped flash.Boot.__trace(v,infos);\n\t\t\t#end\n\t\t#elseif neko\n\t\t\tuntyped {\n\t\t\t\t$print(infos.fileName + \":\" + infos.lineNumber + \": \", v);\n\t\t\t\tif( infos.customParams != null ) for( v in infos.customParams ) $print(\",\", v);\n\t\t\t\t$print(\"\\n\");\n\t\t\t}\n\t\t#elseif js\n\t\t\tuntyped js.Boot.__trace(v,infos);\n\t\t#elseif php\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __call__('_hx_trace', v + extra, infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __call__('_hx_trace', v, infos);\n\t\t#elseif cpp\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __trace(v + extra,infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __trace(v,infos);\n\t\t#elseif (cs || java)\n\t\t\tvar str:String = null;\n\t\t\tif (infos != null) {\n\t\t\t\tstr = infos.fileName + \":\" + infos.lineNumber + \": \" + v;\n\t\t\t\tif (infos.customParams != null)\n\t\t\t\t{\n\t\t\t\t\tstr += \",\" + infos.customParams.join(\",\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = v;\n\t\t\t}\n\t\t\t#if cs\n\t\t\tcs.system.Console.WriteLine(str);\n\t\t\t#elseif java\n\t\t\tuntyped __java__(\"java.lang.System.out.println(str)\");\n\t\t\t#end\n\t\t#elseif (python)\n\t\t\tvar str:String = null;\n\t\t\tif (infos != null) {\n\t\t\t\tstr = infos.fileName + \":\" + Std.string(infos.lineNumber) + \": \" + v;\n\t\t\t\tif (infos.customParams != null) {\n\t\t\t\t\tstr += \",\" + infos.customParams.join(\",\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = v;\n\t\t\t}\n\t\t\tpython.Lib.println(str);\n\t\t#end\n\t}\n\n\t#if (flash || js)\n\t/**\n\t\tClears the trace output.\n\t**/\n\tpublic static dynamic function clear() : Void {\n\t\t#if flash\n\t\tuntyped flash.Boot.__clear_trace();\n\t\t#elseif js\n\t\tuntyped js.Boot.__clear_trace();\n\t\t#end\n\t}\n\t#end\n\n\t#if flash\n\t/**\n\t\tSets the color of the trace output to `rgb`.\n\t**/\n\tpublic static dynamic function setColor( rgb : Int ) {\n\t\tuntyped flash.Boot.__set_trace_color(rgb);\n\t}\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\n@:coreApi class IntMap<T> implements haxe.Constraints.IMap<Int,T> {\n\n\tprivate var h : Dynamic;\n\n\tpublic inline function new() : Void {\n\t\th = {};\n\t}\n\n\tpublic inline function set( key : Int, value : T ) : Void {\n\t\tuntyped h[key] = value;\n\t}\n\n\tpublic inline function get( key : Int ) : Null<T> {\n\t\treturn untyped h[key];\n\t}\n\n\tpublic inline function exists( key : Int ) : Bool {\n\t\treturn untyped h.hasOwnProperty(key);\n\t}\n\n\tpublic function remove( key : Int ) : Bool {\n\t\tif( untyped !h.hasOwnProperty(key) ) return false;\n\t\tuntyped  __js__(\"delete\")(h[key]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<Int> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(key|0);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<T> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[i]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(i);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of h software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and h permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n@:coreApi\nclass ObjectMap<K:{ }, V> implements haxe.Constraints.IMap<K,V> {\n\n\tstatic var count = 0;\n\n\tstatic inline function assignId(obj: { } ):Int {\n\t\treturn untyped obj.__id__ = ++count;\n\t}\n\n\tstatic inline function getId(obj: { } ):Int {\n\t\treturn untyped obj.__id__;\n\t}\n\n\tvar h : { };\n\n\tpublic function new() : Void {\n\t\th = { };\n\t\tuntyped h.__keys__ = { };\n\t}\n\n\tpublic function set(key:K, value:V):Void untyped {\n\t\tvar id : Int = untyped key.__id__ || assignId(key);\n\t\th[id] = value;\n\t\th.__keys__[id] = key;\n\t}\n\n\tpublic inline function get(key:K):Null<V> {\n\t\treturn untyped h[getId(key)];\n\t}\n\n\tpublic inline function exists(key:K):Bool {\n\t\treturn untyped h.__keys__[getId(key)] != null;\n\t}\n\n\tpublic function remove( key : K ) : Bool {\n\t\tvar id = getId(key);\n\t\tif ( untyped h.__keys__[id] == null ) return false;\n\t\tuntyped  __js__(\"delete\")(h[id]);\n\t\tuntyped  __js__(\"delete\")(h.__keys__[id]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<K> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h.__keys__ ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(h.__keys__[key]);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<V> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[getId(i)]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(Std.string(i));\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\nprivate class StringMapIterator<T> {\n\tvar map : StringMap<T>;\n\tvar keys : Array<String>;\n\tvar index : Int;\n\tvar count : Int;\n\tpublic inline function new(map:StringMap<T>, keys:Array<String>) {\n\t\tthis.map = map;\n\t\tthis.keys = keys;\n\t\tthis.index = 0;\n\t\tthis.count = keys.length;\n\t}\n\tpublic inline function hasNext() {\n\t\treturn index < count;\n\t}\n\tpublic inline function next() {\n\t\treturn map.get(keys[index++]);\n\t}\n}\n\n@:coreApi class StringMap<T> implements haxe.Constraints.IMap<String,T> {\n\n\tprivate var h : Dynamic;\n\tprivate var rh : Dynamic;\n\n\tpublic inline function new() : Void {\n\t\th = {};\n\t}\n\n\tinline function isReserved(key:String) : Bool {\n\t\treturn untyped __js__(\"__map_reserved\")[key] != null;\n\t}\n\n\tpublic inline function set( key : String, value : T ) : Void {\n\t\tif( isReserved(key) )\n\t\t\tsetReserved(key, value);\n\t\telse\n\t\t\th[cast key] = value;\n\t}\n\n\tpublic inline function get( key : String ) : Null<T> {\n\t\tif( isReserved(key) )\n\t\t\treturn getReserved(key);\n\t\treturn h[cast key];\n\t}\n\n\tpublic inline function exists( key : String ) : Bool {\n\t\tif( isReserved(key) )\n\t\t\treturn existsReserved(key);\n\t\treturn h.hasOwnProperty(key);\n\t}\n\n\tfunction setReserved( key : String, value : T ) : Void {\n\t\tif( rh == null ) rh = {};\n\t\trh[cast \"$\"+key] = value;\n\t}\n\n\tfunction getReserved( key : String ) : Null<T> {\n\t\treturn rh == null ? null : rh[cast \"$\"+key];\n\t}\n\n\tfunction existsReserved( key : String ) : Bool {\n\t\tif( rh == null ) return false;\n\t\treturn untyped rh.hasOwnProperty(\"$\"+key);\n\t}\n\n\tpublic function remove( key : String ) : Bool {\n\t\tif( isReserved(key) ) {\n\t\t\tkey = \"$\" + key;\n\t\t\tif( rh == null || !rh.hasOwnProperty(key) ) return false;\n\t\t\tuntyped __js__(\"delete\")(rh[key]);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif( !h.hasOwnProperty(key) )\n\t\t\t\treturn false;\n\t\t\tuntyped __js__(\"delete\")(h[key]);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic function keys() : Iterator<String> {\n\t\treturn arrayKeys().iterator();\n\t}\n\t\n\tfunction arrayKeys() : Array<String> {\n\t\tvar out = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\tout.push(key);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\tif( rh != null ) untyped {\n\t\t\t__js__(\"for( var key in this.rh ) {\");\n\t\t\t\tif( key.charCodeAt(0) == \"$\".code )\n\t\t\t\t\tout.push(key.substr(1));\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn out;\n\t}\n\n\tpublic inline function iterator() : Iterator<T> {\n\t\treturn new StringMapIterator(this, arrayKeys());\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar keys = arrayKeys();\n\t\tfor( i in 0...keys.length ) {\n\t\t\tvar k = keys[i];\n\t\t\ts.add(k);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(k)));\n\t\t\tif( i < keys.length )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\tstatic function __init__() : Void {\n\t\tuntyped __js__(\"var __map_reserved = {}\");\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nprivate class HaxeError extends js.Error {\n\n\tvar val:Dynamic;\n\n\tpublic function new(val:Dynamic) untyped {\n\t\tsuper();\n\t\tthis.val = __define_feature__(\"js.Boot.HaxeError\", val);\n\t\tthis.message = String(val);\n\t\tif (js.Error.captureStackTrace) js.Error.captureStackTrace(this, HaxeError);\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") && __typeof__(tostr) == \"function\" ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if ( (untyped __js__(\"typeof\"))(cl) == \"object\" && __isNativeObj(cl) ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n\tstatic var __toStr = untyped __js__(\"{}.toString\");\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name = untyped __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class (with window or global):\n\tstatic function __resolveNativeClass(name:String) untyped {\n\t\tif (__js__(\"typeof window\") != \"undefined\")\n\t\t\treturn window[name];\n\t\telse\n\t\t\treturn global[name];\n\t}\n\n}\n","package thx;\n\nimport thx.Functions.Functions in F;\nimport thx.Functions;\n\n#if macro\nimport haxe.macro.Expr;\n#end\nimport thx.Tuple;\n\n/**\n`Arrays` provides additional extension methods on top of the `Array` type.\n\nNote that some of the examples imply `using thx.Arrays;`.\n**/\nclass Arrays {\n/**\nFinds the first occurrance of `element` and returns all the elements after it.\n**/\n  inline public static function after<T>(array : Array<T>, element : T)\n    return array.slice(array.indexOf(element)+1);\n\n/**\nChecks if `predicate` returns true for all elements in the array.\n**/\n  public static function all<T>(arr : Array<T>, predicate : T -> Bool) {\n    for(item in arr)\n      if(!predicate(item))\n        return false;\n    return true;\n  }\n\n/**\nChecks if `predicate` returns true for at least one element in the array.\n**/\n  public static function any<T>(arr : Array<T>, predicate : T -> Bool) {\n    for(item in arr)\n      if(predicate(item))\n        return true;\n    return false;\n  }\n\n/**\nCreates an array of elements from the specified indexes.\n**/\n  public static function at<T>(arr : Array<T>, indexes : Array<Int>) : Array<T>\n    return indexes.map(function(i) return arr[i]);\n\n/**\nFinds the first occurrance of `element` and returns all the elements before it.\n**/\n  inline public static function before<T>(array : Array<T>, element : T)\n    return array.slice(0, array.indexOf(element));\n\n/**\nFilters out all null elements in the array\n**/\n  public static function compact<T>(arr : Array<Null<T>>) : Array<T> {\n#if cs\n    var result : Array<T> = [];\n    for(item in arr) {\n      if(null != item)\n        result.push(item);\n    }\n    return result;\n#else\n    return arr.filter(function(v : Null<T>) return null != v);\n#end\n  }\n\n/**\nReturns a Map containing the number of occurrances for each value in the array.\n**/\n  @:generic\n  public static function count<T>(arr : Array<T>) : Map<T, Int> {\n    var map = new Map<T, Int>();\n    arr.map(function(v)\n      map.set(v, map.exists(v) ? map.get(v) + 1 : 1)\n    );\n    return map;\n  }\n\n/**\nReturns `true` if `element` is found in the array.\n\nAn optional equality function can be passed as the last argument. If not provided, strict equality is adopted.\n**/\n  public static function contains<T>(array : Array<T>, element : T, ?eq : T -> T -> Bool) : Bool {\n    if(null == eq) {\n      return array.indexOf(element) >= 0;\n    } else {\n      for(i in 0...array.length)\n        if(eq(array[i], element))\n          return true;\n      return false;\n    }\n  }\n\n/**\nIt returns the cross product between two arrays.\n\n```haxe\nvar r = [1,2,3].cross([4,5,6]);\ntrace(r); // [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]\n```\n**/\n  public static function cross<T>(a : Array<T>, b : Array<T>) {\n    var r = [];\n    for (va in a)\n      for (vb in b)\n        r.push([va, vb]);\n    return r;\n  }\n\n/**\nIt produces the cross product of each array element.\n\n```haxe\nvar r = [[1,2],[3,4],[5,6]].crossMulti();\ntrace(r); // [[1,3,5],[2,3,5],[1,4,5],[2,4,5],[1,3,6],[2,3,6],[1,4,6],[2,4,6]]\n```\n**/\n  public static function crossMulti<T>(array : Array<Array<T>>) {\n    var acopy  = array.copy(),\n        result = acopy.shift().map(function(v) return [v]);\n    while (acopy.length > 0) {\n      var array = acopy.shift(),\n          tresult = result;\n      result = [];\n      for (v in array) {\n        for (ar in tresult) {\n          var t = ar.copy();\n          t.push(v);\n          result.push(t);\n        }\n      }\n    }\n    return result;\n  }\n\n/**\nReturns a new array containing only unique values from the input array.\nInput array does not need to be sorted.\nA predicate comparison function can be provided for comparing values.  Default\ncomparison is ==.\n**/\n  public static function distinct<T>(array : Array<T>, ?predicate : T -> T -> Bool) : Array<T> {\n    var result = [];\n\n    if (array.length <= 1)\n      return array;\n\n    if (null == predicate)\n      predicate = Functions.equality;\n\n    for (v in array) {\n      var keep = !any(result, function(r) {\n        return predicate(r, v);\n      });\n      if (keep) result.push(v);\n    }\n\n    return result;\n  }\n\n/**\nIt allows to iterate an array pairing each element with every other element in the array.\n\nThe iteration ends as soon as the `callback` returns `false`.\n**/\n  public static function eachPair<TIn, TOut>(array : Array<TIn>, callback : TIn -> TIn -> Bool)\n    for(i in 0...array.length)\n      for(j in i...array.length)\n        if(!callback(array[i], array[j]))\n          return;\n\n/**\nIt compares the lengths and elements of two given arrays and returns `true` if they match.\n\nAn optional equality function can be passed as the last argument. If not provided, strict equality is adopted.\n**/\n  public static function equals<T>(a : Array<T>, b : Array<T>, ?equality : T -> T -> Bool) {\n    if(a == null || b == null || a.length != b.length) return false;\n    if(null == equality) equality = F.equality;\n    for(i in 0...a.length)\n      if(!equality(a[i], b[i]))\n        return false;\n    return true;\n  }\n\n/**\nIt finds an element in the array using `predicate` and returns it. The element is also\nremoved from the original array.\n\nIf no element satisfies `predicate` the array is left unmodified and `null` is returned.\n**/\n  public static function extract<T>(a : Array<T>, predicate : T -> Bool) : T {\n    for(i in 0...a.length)\n      if(predicate(a[i]))\n        return a.splice(i, 1)[0];\n    return null;\n  }\n\n/**\nFilters an array according to the expression passed as the second argument.\n\nThe special symbol `_` refers to the current item.\n\n```haxe\n[1,2,3,4,5,6].filterPluck(_ % 2 != 0); // holds [1,3,5]\n```\n**/\n  macro public static function filterPluck<T>(a : ExprOf<Array<T>>, expr : ExprOf<Bool>) : ExprOf<Array<T>>\n    return macro $e{a}.filter(function(_) return $e{expr});\n\n/**\nIt returns the first element of the array that matches the provided predicate function.\nIf none is found it returns null.\n**/\n  public static function find<T>(array : Array<T>, predicate : T -> Bool) : Null<T> {\n    for(item in array)\n      if(predicate(item))\n        return item;\n    return null;\n  }\n\n/**\nIt returns the last element of the array that matches the provided predicate function.\nIf none is found it returns null.\n**/\n  public static function findLast<T>(array : Array<T>, predicate : T -> Bool) : Null<T> {\n    var len = array.length,\n        j;\n    for(i in 0...len) {\n      j = len - i - 1;\n      if(predicate(array[j]))\n        return array[j];\n    }\n    return null;\n  }\n\n/**\nIt returns the first element of the array or null if the array is empty.\n**/\n  inline public static function first<T>(array : Array<T>) : Null<T>\n    return array[0];\n\n/**\nIt traverses an array of elements. Each element is split using the `callback` function and a 'flattened' array is returned.\n\n```haxe\nvar chars = ['Hello', 'World'].flatMap(function(s) return s.split(''));\ntrace(chars); // ['H','e','l','l','o','W','o','r','l','d']\n```\n**/\n  inline public static function flatMap<TIn, TOut>(array : Array<TIn>, callback : TIn -> Array<TOut>) : Array<TOut>\n    return flatten(array.map(callback));\n\n/**\nIt takes an array of arrays and 'flattens' it into an array.\n\n```haxe\nvar arr = [[1,2,3],[4,5,6],[7,8,9]];\ntrace(arr); // [1,2,3,4,5,6,7,8,9]\n```\n**/\n  #if js inline #end\n  public static function flatten<T>(array : Array<Array<T>>) : Array<T>\n    #if js\n      return untyped __js__('Array.prototype.concat.apply')([], array);\n    #else\n      return reduce(array, function(acc : Array<T>, item) return acc.concat(item), []);\n    #end\n\n/**\nFinds the first occurrance of `element` and returns all the elements from that point on.\n**/\n  inline public static function from<T>(array : Array<T>, element : T)\n    return array.slice(array.indexOf(element));\n\n/**\nReturns a Map of arrays. Each value in the array is passed to `resolver` that returns a key to use\nto group such element.\n\nThis method is tagged with `@:generic` and needs a compatible type to be used (ex: no anonymous objects).\n\nIn case you have to use a type that is not supported by `@:generic`, please use `groupByAppend`.\n**/\n  @:generic\n  public static function groupBy<TKey, TValue>(arr : Array<TValue>, resolver : TValue -> TKey) : Map<TKey, Array<TValue>> {\n    var map : Map<TKey, Array<TValue>> = new Map<TKey, Array<TValue>>();\n    arr.map(function(v : TValue) {\n      var key : TKey = resolver(v),\n          arr : Array<TValue> = map.get(key);\n      if(null == arr) {\n        arr = [v];\n        map.set(key, arr);\n      } else {\n        arr.push(v);\n      }\n    });\n    return map;\n  }\n\n  /**\n  Each value in the array is passed to `resolver` that returns a key to use to group such element.\n  Groups are appended to the passed map.\n  **/\n  public static function groupByAppend<TKey, TValue>(arr : Array<TValue>, resolver : TValue -> TKey, map : Map<TKey, Array<TValue>>) : Map<TKey, Array<TValue>> {\n    arr.map(function(v : TValue) {\n      var key : TKey = resolver(v),\n          arr : Array<TValue> = map.get(key);\n      if(null == arr) {\n        arr = [v];\n        map.set(key, arr);\n      } else {\n        arr.push(v);\n      }\n    });\n    return map;\n  }\n\n\n/**\nIt returns the first element of the array or null if the array is empty. Same as `first`.\n**/\n  inline public static function head<T>(array : Array<T>) : Null<T>\n    return array[0];\n\n/**\n`ifEmpty` returns `value` if it is neither `null` or empty, otherwise it returns `alt`\n**/\n  public static inline function ifEmpty<T>(value : Array<T>, alt : Array<T>) : Array<T>\n    return null != value && 0 != value.length ? value : alt;\n\n/**\nGet all the elements from `array` except for the last one.\n**/\n  inline public static function initial<T>(array : Array<T>) : Array<T>\n    return array.slice(0, array.length - 1);\n\n/**\nIt returns `true` if the array contains zero elements.\n**/\n  inline public static function isEmpty<T>(array : Array<T>) : Bool\n    return array.length == 0;\n\n/**\nIt returns the last element of the array or null if the array is empty.\n**/\n  inline public static function last<T>(array : Array<T>) : Null<T>\n    return array[array.length-1];\n\n/**\nSame as `Array.map` but it adds a second argument to the `callback` function with the current index value.\n**/\n  #if js inline #end\n  public static function mapi<TIn, TOut>(array : Array<TIn>, callback : TIn -> Int -> TOut) : Array<TOut> {\n    var r = [];\n    for(i in 0...array.length)\n      r.push(callback(array[i], i));\n    return r;\n  }\n\n/**\nSame as `Array.map` but traverses the array from the last to the first element.\n**/\n  public static function mapRight<TIn, TOut>(array : Array<TIn>, callback : TIn -> TOut) : Array<TOut> {\n    var i = array.length,\n        result = [];\n    while(--i >= 0)\n      result.push(callback(array[i]));\n    return result;\n  }\n\n/**\nIt works the same as `Array.sort()` but doesn't change the original array and returns a sorted copy it.\n**/\n  public static function order<T>(array : Array<T>, sort : T -> T -> Int) {\n    var n = array.copy();\n    n.sort(sort);\n    return n;\n  }\n\n/**\nUses the pluck strategy to order an array.  Returns an ordered copy of the Array, leaving the original unchanged.\nArguments for pluck are `_0` and `_1`.\n**/\n  macro public static function orderPluck<T>(array : ExprOf<Array<T>>, expr : ExprOf<Int>)\n    return macro $e{array}.order(function(_0, _1) return $e{expr});\n\n/**\nThe method works like a normal `Array.map()` but instead of passing a function that\nreceives an item, you can pass an expression that defines how to access to a member\nof the item itself.\n\nThe following two examples are equivalent:\n\n```\nvar r = ['a','b','c'].pluck(_.toUppercase());\ntrace(r); // ['A','B','C']\n```\n\nAlternative using traditional `map`.\n\n```\nvar r = ['a','b','c'].map(function(o) return o.toUppercase());\ntrace(r); // ['A','B','C']\n```\n\nYou can use `pluck` on any kind of field including properties and methods and you can even pass arguments\nto such functions.\n\nThe method is a macro method that guarantees that the correct types and identifiers are used.\n**/\n  macro public static function pluck<T, TOut>(a : ExprOf<Array<T>>, expr : ExprOf<TOut>) : ExprOf<Array<TOut>>\n    return macro $e{a}.map(function(_) return ${expr});\n\n/**\nSame as pluck but in reverse order.\n**/\n  macro public static function pluckRight<T, TOut>(a : ExprOf<Array<T>>, expr : ExprOf<TOut>) : ExprOf<Array<TOut>>\n    return macro thx.Arrays.mapRight($e{a}, function(_) return ${expr});\n\n/**\nLike `pluck` but with an extra argument `i` that can be used to infer the index of the iteration.\n\n```haxe\nvar r = arr.plucki(_.increment(i)); // where increment() is a method of the elements in the array\n```\n**/\n  macro public static function plucki<T>(a : ExprOf<Array<T>>, expr : Expr)\n    return macro thx.Arrays.mapi($e{a}, function(_, i) return ${expr});\n\n/**\nPulls from `array` all occurrences of all the elements in `toRemove`. Optionally takes\nan `equality` function.\n**/\n  public static function pull<T>(array : Array<T>, toRemove : Array<T>, ?equality : T -> T -> Bool)\n    for(item in toRemove)\n      removeAll(array, item, equality);\n\n/**\nIt pushes `value` onto the array if `condition` is true. Also returns the array for easy method chaining.\n**/\n  public static function pushIf<T>(array : Array<T>, condition : Bool, value : T) {\n    if (condition)\n      array.push(value);\n    return array;\n  }\n\n/**\nIt applies a function against an accumulator and each value of the array (from left-to-right) has to reduce it to a single value.\n**/\n  inline public static function reduce<TItem, TAcc>(array : Array<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc {\n    #if js\n      return untyped array.reduce(callback, initial);\n    #else\n      array.map(function(v) initial = callback(initial, v));\n      return initial;\n    #end\n  }\n\n/**\nResizes an array of `T` to an arbitrary length by adding more elements to its end\nor by removing extra elements.\n\nNote that the function changes the passed array and doesn't create a copy.\n**/\n  public static function resize<T>(array : Array<T>, length : Int, fill : T) {\n    while(array.length < length)\n      array.push(fill);\n    array.splice(length, array.length - length);\n    return array;\n  }\n\n/**\nIt is the same as `reduce` but with the extra integer `index` parameter.\n**/\n  inline public static function reducei<TItem, TAcc>(array : Array<TItem>, callback : TAcc -> TItem -> Int -> TAcc, initial : TAcc) : TAcc {\n    #if js\n      return untyped array.reduce(callback, initial);\n    #else\n      Arrays.mapi(array, function(v, i) initial = callback(initial, v, i));\n      return initial;\n    #end\n  }\n\n/**\nSame as `Arrays.reduce` but starting from the last element and traversing to the first\n**/\n  inline public static function reduceRight<TItem, TAcc>(array : Array<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc {\n    var i = array.length;\n    while(--i >= 0)\n      initial = callback(initial, array[i]);\n    return initial;\n  }\n\n/**\nRemove every occurrance of `element` from `array`. If `equality` is not specified, strict equality\nwill be adopted.\n**/\n  public static function removeAll<T>(array : Array<T>, element : T, ?equality : T -> T -> Bool) {\n    if(null == equality)\n      equality = Functions.equality;\n    var i = array.length;\n    while(--i >= 0)\n      if(equality(array[i], element))\n        array.splice(i, 1);\n  }\n\n/**\nReturns all but the first element of the array\n**/\n  inline public static function rest<T>(array : Array<T>) : Array<T>\n    return array.slice(1);\n\n/**\nReturns `n` elements at random from the array. Elements will not be repeated.\n**/\n  inline public static function sample<T>(array : Array<T>, n : Int) : Array<T> {\n    n = Ints.min(n, array.length);\n    var copy   = array.copy(),\n        result = [];\n    for(i in 0...n)\n      result.push(copy.splice(Std.random(copy.length), 1)[0]);\n    return result;\n  }\n\n/**\nReturns one element at random from the array or null if the array is empty.\n**/\n  inline public static function sampleOne<T>(array : Array<T>) : Null<T>\n    return array[Std.random(array.length)];\n\n/**\nIt returns a copy of the array with its elements randomly changed in position.\n**/\n  public static function shuffle<T>(a : Array<T>) : Array<T> {\n    var t = Ints.range(a.length),\n        array = [];\n    while (t.length > 0) {\n      var pos = Std.random(t.length),\n        index = t[pos];\n      t.splice(pos, 1);\n      array.push(a[index]);\n    }\n    return array;\n  }\n\n/**\nUses the plcuk strategy to sort an array. Arguments for pluck are `_0` and `_1`.\n**/\n  macro public static function sortPluck<T>(array : ExprOf<Array<T>>, expr : ExprOf<Int>)\n    return macro $e{array}.sort(function(_0, _1) return $e{expr});\n\n/**\nReturns the first `n` elements from the array.\n**/\n  inline public static function take<T>(arr : Array<T>, n : Int) : Array<T>\n    return arr.slice(0, n);\n/**\nReturns the last `n` elements from the array.\n**/\n  inline public static function takeLast<T>(arr : Array<T>, n : Int) : Array<T>\n    return arr.slice(arr.length - n);\n\n/**\nTransforms an array like `[[a0,b0],[a1,b1],[a2,b2]]` into\n`[[a0,a1,a2],[b0,b1,b2]]`.\n**/\n  public static function rotate<T>(arr : Array<Array<T>>) : Array<Array<T>> {\n    var result = [];\n    for(i in 0...arr[0].length) {\n      var row = [];\n      result.push(row);\n      for(j in 0...arr.length) {\n        row.push(arr[j][i]);\n      }\n    }\n    return result;\n  }\n\n/**\nPairs the elements of two arrays in an array of `Tuple2`.\n**/\n  public static function zip<T1, T2>(array1 : Array<T1>, array2 : Array<T2>) : Array<Tuple2<T1, T2>> {\n    var length = Ints.min(array1.length, array2.length),\n        array  = [];\n    for(i in 0...length)\n      array.push(new Tuple2(array1[i], array2[i]));\n    return array;\n  }\n\n/**\nPairs the elements of three arrays in an array of `Tuple3`.\n**/\n  public static function zip3<T1, T2, T3>(array1 : Array<T1>, array2 : Array<T2>, array3 : Array<T3>) : Array<Tuple3<T1, T2, T3>> {\n    var length = ArrayInts.min([array1.length, array2.length, array3.length]),\n        array  = [];\n    for(i in 0...length)\n      array.push(new Tuple3(array1[i], array2[i], array3[i]));\n    return array;\n  }\n\n/**\nPairs the elements of four arrays in an array of `Tuple4`.\n**/\n  public static function zip4<T1, T2, T3, T4>(array1 : Array<T1>, array2 : Array<T2>, array3 : Array<T3>, array4 : Array<T4>) : Array<Tuple4<T1, T2, T3, T4>> {\n    var length = ArrayInts.min([array1.length, array2.length, array3.length, array4.length]),\n        array  = [];\n    for(i in 0...length)\n      array.push(new Tuple4(array1[i], array2[i], array3[i], array4[i]));\n    return array;\n  }\n\n/**\nPairs the elements of five arrays in an array of `Tuple5`.\n**/\n  public static function zip5<T1, T2, T3, T4, T5>(array1 : Array<T1>, array2 : Array<T2>, array3 : Array<T3>, array4 : Array<T4>, array5 : Array<T5>) : Array<Tuple5<T1, T2, T3, T4, T5>> {\n    var length = ArrayInts.min([array1.length, array2.length, array3.length, array4.length, array5.length]),\n        array  = [];\n    for(i in 0...length)\n      array.push(new Tuple5(array1[i], array2[i], array3[i], array4[i], array5[i]));\n    return array;\n  }\n\n/**\nUnzip an array of Tuple2<T1, T2> to a Tuple2<Array<T1>, Array<T2>>.\n**/\n  public static function unzip<T1, T2>(array : Array<Tuple2<T1, T2>>) {\n    var a1 = [], a2 = [];\n    array.map(function(t) {\n      a1.push(t._0);\n      a2.push(t._1);\n    });\n    return new Tuple2(a1, a2);\n  }\n\n/**\nUnzip an array of Tuple3<T1, T2, T3> to a Tuple3<Array<T1>, Array<T2>, Array<T3>>.\n**/\n  public static function unzip3<T1, T2, T3>(array : Array<Tuple3<T1, T2, T3>>) {\n    var a1 = [], a2 = [], a3 = [];\n    array.map(function(t) {\n      a1.push(t._0);\n      a2.push(t._1);\n      a3.push(t._2);\n    });\n    return new Tuple3(a1, a2, a3);\n  }\n\n/**\nUnzip an array of Tuple4<T1, T2, T3, T4> to a Tuple4<Array<T1>, Array<T2>, Array<T3>, Array<T4>>.\n**/\n  public static function unzip4<T1, T2, T3, T4>(array : Array<Tuple4<T1, T2, T3, T4>>) {\n    var a1 = [], a2 = [], a3 = [], a4 = [];\n    array.map(function(t) {\n      a1.push(t._0);\n      a2.push(t._1);\n      a3.push(t._2);\n      a4.push(t._3);\n    });\n    return new Tuple4(a1, a2, a3, a4);\n  }\n\n/**\nUnzip an array of Tuple5<T1, T2, T3, T4, T5> to a Tuple5<Array<T1>, Array<T2>, Array<T3>, Array<T4>, Array<T5>>.\n**/\n  public static function unzip5<T1, T2, T3, T4, T5>(array : Array<Tuple5<T1, T2, T3, T4, T5>>) {\n    var a1 = [], a2 = [], a3 = [], a4 = [], a5 = [];\n    array.map(function(t) {\n      a1.push(t._0);\n      a2.push(t._1);\n      a3.push(t._2);\n      a4.push(t._3);\n      a5.push(t._4);\n    });\n    return new Tuple5(a1, a2, a3, a4, a5);\n  }\n\n#if js\n  static function __init__() {\n    untyped __js__(\"\n      // Production steps of ECMA-262, Edition 5, 15.4.4.21\n      // Reference: http://es5.github.io/#x15.4.4.21\n      if (!Array.prototype.reduce) {\n        Array.prototype.reduce = function(callback /*, initialValue*/) {\n          'use strict';\n          if (this == null) {\n            throw new TypeError('Array.prototype.reduce called on null or undefined');\n          }\n          if (typeof callback !== 'function') {\n            throw new TypeError(callback + ' is not a function');\n          }\n          var t = Object(this), len = t.length >>> 0, k = 0, value;\n          if (arguments.length == 2) {\n            value = arguments[1];\n          } else {\n            while (k < len && ! k in t) {\n              k++;\n            }\n            if (k >= len) {\n              throw new TypeError('Reduce of empty array with no initial value');\n            }\n            value = t[k++];\n          }\n          for (; k < len; k++) {\n            if (k in t) {\n              value = callback(value, t[k], k, t);\n            }\n          }\n          return value;\n        };\n      }\n    \");\n  }\n#end\n}\n\n/**\nHelper class for `Array<Float>`.\n**/\nclass ArrayFloats {\n/**\nFinds the average of all the elements in the array.\n\nIt returns `NaN` if the array is empty.\n**/\n  public static function average(arr : Array<Float>) : Float {\n    return sum(arr) / arr.length;\n  }\n\n/**\nFilters out all null or Math.NaN floats in the array\n**/\n  public static function compact(arr : Array<Null<Float>>) : Array<Float>\n    // the cast is required to compile safely to C#\n    return cast arr.filter(function(v) return null != v && Math.isFinite(v));\n\n/**\nFinds the max float element in the array.\n**/\n  public static function max(arr : Array<Float>) : Null<Float>\n    return arr.length == 0 ? null : Arrays.reduce(arr, function(max, v) return v > max ? v : max, arr[0]);\n\n/**\nFinds the min float element in the array.\n**/\n  public static function min(arr : Array<Float>) : Null<Float>\n    return arr.length == 0 ? null : Arrays.reduce(arr, function(min, v) return v < min ? v : min, arr[0]);\n\n/**\nResizes an array of `Float` to an arbitrary length by adding more elements (default is `0.0`)\nto its end or by removing extra elements.\n\nNote that the function changes the passed array and doesn't create a copy.\n**/\n  public static function resize(array : Array<Float>, length : Int, fill : Float = 0.0) {\n    while(array.length < length)\n      array.push(fill);\n    array.splice(length, array.length - length);\n    return array;\n  }\n\n/**\nFinds the sum of all the elements in the array.\n**/\n  public static function sum(arr : Array<Float>) : Null<Float>\n    return Arrays.reduce(arr, function(tot, v) return tot + v, 0.0);\n}\n\n/**\nHelper class for `Array<Int>`.\n**/\nclass ArrayInts {\n/**\nFinds the average of all the elements in the array.\n**/\n  public static function average(arr : Array<Int>) : Null<Float>\n    return sum(arr) / arr.length;\n\n/**\nFinds the max int element in the array.\n**/\n  public static function max(arr : Array<Int>) : Null<Int>\n    return arr.length == 0 ? null : Arrays.reduce(arr, function(max, v) return v > max ? v : max, arr[0]);\n\n/**\nFinds the min int element in the array.\n**/\n  public static function min(arr : Array<Int>) : Null<Int>\n    return arr.length == 0 ? null : Arrays.reduce(arr, function(min, v) return v < min ? v : min, arr[0]);\n\n/**\nResizes an array of `Int` to an arbitrary length by adding more elements (default is `0`)\nto its end or by removing extra elements.\n\nNote that the function changes the passed array and doesn't create a copy.\n**/\n  public static function resize(array : Array<Int>, length : Int, fill : Int = 0) {\n    while(array.length < length)\n      array.push(fill);\n    array.splice(length, array.length - length);\n    return array;\n  }\n\n/**\nFinds the sum of all the elements in the array.\n**/\n  public static function sum(arr : Array<Int>) : Null<Int>\n    return Arrays.reduce(arr, function(tot, v) return tot + v, 0);\n}\n\n/**\nHelper class for `Array<String>`.\n**/\nclass ArrayStrings {\n/**\nFilters out all null or empty strings in the array\n**/\n  public static function compact(arr : Array<String>) : Array<String>\n    return arr.filter(function(v) return !Strings.isEmpty(v));\n\n/**\nFinds the max string element in the array.\n**/\n  public static function max(arr : Array<String>) : Null<String>\n    return arr.length == 0 ? null : Arrays.reduce(arr, function(max, v) return v > max ? v : max, arr[0]);\n\n/**\nFinds the min string element in the array.\n**/\n  public static function min(arr : Array<String>) : Null<String>\n    return arr.length == 0 ? null : Arrays.reduce(arr, function(min, v) return v < min ? v : min, arr[0]);\n}\n","package thx;\n\nimport thx.Objects;\n\n/**\n`Dynamics` provides additional extension methods on any type.\n**/\nclass Dynamics {\n/**\nStructural and recursive equality.\n**/\n  public static function equals<T1, T2>(a : T1, b : T2) : Bool {\n    // type check\n    if(!Types.sameType(a, b))\n      return false;\n\n    // quick check\n    if(untyped a == b)\n      return true;\n\n    switch Type.typeof(a) {\n      case TFloat, TNull, TInt, TBool:\n        return false;\n      case TFunction:\n        return Reflect.compareMethods(a, b);\n      case TClass(c):\n        var ca = Type.getClassName(c),\n            cb = Type.getClassName(Type.getClass(b));\n        if (ca != cb)\n          return false;\n\n        // string\n        if (Std.is(a, String))\n          return false;\n\n        // arrays\n        if (Std.is(a, Array)) {\n          var aa : Array<Dynamic> = cast a,\n              ab : Array<Dynamic> = cast b;\n          if (aa.length != ab.length)\n            return false;\n          for (i in 0...aa.length)\n            if (!equals(aa[i], ab[i]))\n              return false;\n          return true;\n        }\n\n        // date\n        if(Std.is(a, Date))\n          return untyped a.getTime() == b.getTime();\n\n        // map\n        if (Maps.isMap(a)) {\n          var ha : Map<Dynamic, Dynamic> = cast a,\n              hb : Map<Dynamic, Dynamic> = cast b;\n          var ka = Iterators.toArray(ha.keys()),\n              kb = Iterators.toArray(hb.keys());\n          if (ka.length != kb.length)\n            return false;\n          for (key in ka)\n            if (!hb.exists(key) || !equals(ha.get(key), hb.get(key)))\n              return false;\n          return true;\n        }\n\n        // iterator or iterable\n        var t = false;\n        if ((t = Iterators.isIterator(a)) || Iterables.isIterable(a)) {\n          var va = t ? Iterators.toArray(cast a) : Iterables.toArray(cast a),\n              vb = t ? Iterators.toArray(cast b) : Iterables.toArray(cast b);\n          if (va.length != vb.length)\n            return false;\n\n          for (i in 0...va.length)\n            if (!equals(va[i], vb[i]))\n              return false;\n          return true;\n        }\n\n        // custom class with equality method\n        var f = null;\n        if(Reflect.hasField(a, 'equals') && Reflect.isFunction(f = Reflect.field(a, 'equals')))\n          return Reflect.callMethod(a, f, [b]);\n\n        // custom class\n        var fields = Type.getInstanceFields(Type.getClass(a));\n        for (field in fields) {\n          var va = Reflect.field(a, field);\n          if (Reflect.isFunction(va))\n            continue;\n          var vb = Reflect.field(b, field);\n          if(!equals(va, vb))\n            return false;\n        }\n        return true;\n      case TEnum(e) :\n        var ea  = Type.getEnumName(e),\n            teb = Type.getEnum(cast b),\n            eb  = Type.getEnumName(teb);\n        if (ea != eb)\n          return false;\n\n        if (Type.enumIndex(cast a) != Type.enumIndex(cast b))\n          return false;\n        var pa = Type.enumParameters(cast a),\n          pb = Type.enumParameters(cast b);\n        for (i in 0...pa.length)\n          if (!equals(pa[i], pb[i]))\n            return false;\n        return true;\n      case TObject  :\n        // anonymous object\n        var fa = Reflect.fields(a),\n            fb = Reflect.fields(b);\n        for (field in fa) {\n          fb.remove(field);\n          if (!Reflect.hasField(b, field))\n            return false;\n          var va = Reflect.field(a, field);\n          if(Reflect.isFunction(va))\n            continue;\n          var vb = Reflect.field(b, field);\n          if(!equals(va, vb))\n            return false;\n        }\n        if (fb.length > 0)\n          return false;\n\n        // iterator\n        var t = false;\n        if ((t = Iterators.isIterator(a)) || Iterables.isIterable(a)) {\n          if (t && !Iterators.isIterator(b))\n            return false;\n          if (!t && !Iterables.isIterable(b))\n            return false;\n\n\n          var aa = t ? Iterators.toArray(cast a) : Iterables.toArray(cast a);\n          var ab = t ? Iterators.toArray(cast b) : Iterables.toArray(cast b);\n          if (aa.length != ab.length)\n            return false;\n          for (i in 0...aa.length)\n            if (!equals(aa[i], ab[i]))\n              return false;\n          return true;\n        }\n        return true;\n      case TUnknown :\n        return throw \"Unable to compare two unknown types\";\n    }\n    return throw new Error('Unable to compare values: $a and $b');\n  }\n\n/**\nClone the object.\n\nNull values, strings, dates, numbers, enums and functions are immutable so will be returned as is.\nAnonymous objects will be created and each field cloned recursively.\nArrays will be recreated and each object cloned recursively.\nClass instances will either be cloned, or the reference copied, depending on the value of `cloneInstances`.\n\n@param v The object which will be cloned.\n@param cloneInstances If true, class instances will be cloned using `Type.createEmptyInstance` and `Reflect.setField`. If false, class instances will be re-used, not cloned. Default is false.\n**/\n  public static function clone(v : Dynamic, ?cloneInstances = false) : Dynamic {\n    switch(Type.typeof(v)) {\n      case TNull:\n        return null;\n      case TInt, TFloat, TBool, TEnum(_), TUnknown, TFunction:\n        return v;\n      case TObject:\n        return Objects.copyTo(v,{});\n      case TClass(c):\n        var name = Type.getClassName(c);\n        switch(name) {\n          case \"Array\":\n            return (v : Array<Dynamic>).map(function(v)\n              return clone(v, cloneInstances)\n            );\n          case \"String\", \"Date\":\n            return v;\n          default:\n            if(cloneInstances) {\n              var o = Type.createEmptyInstance(c);\n              for (field in Type.getInstanceFields(c))\n                Reflect.setField(o, field, clone(Reflect.field(v, field), cloneInstances));\n              return o;\n            } else {\n              return v;\n            }\n        }\n    }\n  }\n}","package thx;\n\nimport haxe.PosInfos;\nimport haxe.CallStack;\nimport thx.error.ErrorWrapper;\n\n/**\nDefines a generic Error type. When the target platform is JS, `Error` extends the native\n`js.Error` type.\n**/\nclass Error #if js extends js.Error #end {\n/**\nIt creates an instance of Error from any value.\n\nIf `err` is already an instance of `Error`, it is returned and nothing is created.\n**/\n  public static function fromDynamic(err : Dynamic, ?pos : PosInfos) : Error {\n    if(Std.is(err, Error))\n      return cast err;\n    return new ErrorWrapper(\"\"+err, err, null, pos);\n  }\n\n#if !js\n/**\nThe text message associated with the error.\n**/\n  public var message(default, null) : String;\n#end\n/**\nThe location in code where the error has been instantiated.\n**/\n  public var pos(default, null) : PosInfos;\n\n/**\nThe collected error stack.\n**/\n  public var stackItems(default, null) : Array<StackItem>;\n\n/**\nThe `Error` constructor only requires a steing message. `stack` and `pos` are automatically\npopulate but can be provided if preferred.\n**/\n  public function new(message : String, ?stack : Array<StackItem>, ?pos : PosInfos) {\n#if js\n    super(message);\n#end\n    this.message = message;\n\n    if(null == stack) {\n      stack = try CallStack.exceptionStack() catch(e : Dynamic) [];\n      if(stack.length == 0)\n        stack = try CallStack.callStack() catch(e : Dynamic) [];\n    }\n    this.stackItems = stack;\n    this.pos = pos;\n  }\n\n  public function toString()\n    return message + \"\\nfrom: \" + pos.className + \".\" + pos.methodName + \"() at \" + pos.lineNumber + \"\\n\\n\" + CallStack.toString(stackItems);\n}\n","package thx;\n\n#if macro\nimport haxe.macro.Expr;\nimport haxe.macro.ExprTools;\n#end\n\n/**\nExtension methods for functions with arity 0 (functions that do not take arguments).\n**/\nclass Functions0 {\n/**\nReturns a function that invokes `callback` after being being invoked `n` times.\n**/\n  inline public static function after(callback : Void -> Void, n : Int)\n    return function()\n      if(--n == 0)\n        callback();\n/**\n`join` creates a function that calls the 2 functions passed as arguments in sequence.\n**/\n  public inline static function join(fa : Void -> Void, fb : Void -> Void)\n    return function() {\n      fa();\n      fb();\n    }\n\n/**\n`once` wraps and returns the argument function. `once` ensures that `f` will be called\nat most once even if the returned function is invoked multiple times.\n**/\n  public inline static function once(f : Void -> Void)\n    return function() {\n      var t = f;\n      f = Functions.noop;\n      t();\n    };\n\n/**\nWraps `callback` in a function that negates its results.\n**/\n  public inline static function negate(callback : Void -> Bool)\n    return function()\n      return !callback();\n\n/**\nCreates a function that calls `callback` `n` times and returns an array of results.\n**/\n  public inline static function times<T>(n : Int, callback : Void -> T)\n    return function()\n      return Ints.range(n).map(function(_) return callback());\n\n/**\nCreates a function that calls `callback` `n` times and returns an array of results.\n\nCallback takes an additional argument `index`.\n**/\n  public inline static function timesi<T>(n : Int, callback : Int -> T)\n    return function()\n      return Ints.range(n).map(function(i) return callback(i));\n}\n\n/**\nExtension methods for functions with arity 1 (functions that take exactly 1 argument).\n**/\nclass Functions1 {\n /**\n`compose` returns a function that calls the first arguemnt function with the result\nof the following one.\n **/\n  public inline static function compose<TIn, TRet1, TRet2>(fa : TRet2 -> TRet1, fb : TIn -> TRet2)\n    return function(v : TIn) return fa(fb(v));\n\n/**\n`join` creates a function that calls the 2 functions passed as arguments in sequence\nand passes the same argument value to the both of them.\n**/\n  public inline static function join<TIn>(fa : TIn -> Void, fb : TIn -> Void)\n    return function(v : TIn) {\n      fa(v);\n      fb(v);\n    }\n\n/**\n`memoize` wraps `callback` and calls it only once storing the result for future needs.\n\nComputed results are stored in an internal map. The keys to this map are generated by\nthe resolver function that by default directly converts the first argument into a string.\n**/\n  public static function memoize<TIn, TOut>(callback : TIn -> TOut, ?resolver : TIn -> String) : TIn -> TOut {\n    if(null == resolver)\n      resolver = function(v : TIn) return '$v';\n    var map = new Map<String, TOut>();\n    return function(v : TIn) {\n      var key = resolver(v);\n      if(map.exists(key))\n        return map.get(key);\n      var result = callback(v);\n      map.set(key, result);\n      return result;\n    }\n  }\n\n/**\nWraps `callback` in a function that negates its results.\n**/\n  public inline static function negate<T1>(callback : T1 -> Bool)\n    return function(v : T1)\n      return !callback(v);\n\n/**\n`noop` is a function that has no side effects and doesn't return any value.\n**/\n  public static function noop<T>(_ : T) : Void {}\n\n/**\nCreates a function that calls `callback` `n` times and returns an array of results.\n**/\n  public inline static function times<TIn, TOut>(n : Int, callback : TIn -> TOut)\n    return function(value : TIn)\n      return Ints.range(n).map(function(_) return callback(value));\n\n/**\nCreates a function that calls `callback` `n` times and returns an array of results.\n\nCallback takes an additional argument `index`.\n**/\n  public inline static function timesi<TIn, TOut>(n : Int, callback : TIn -> Int -> TOut)\n    return function(value : TIn)\n      return Ints.range(n).map(function(i) return callback(value, i));\n\n/**\nReturns a function that behaves the same as `callback` but has its arguments inverted.\n**/\n  public inline static function swapArguments<T1, T2, TReturn>(callback : T1 -> T2 -> TReturn) : T2 -> T1 -> TReturn\n    return function(a2 : T2, a1 : T1)\n      return callback(a1, a2);\n}\n\n/**\nHelper class for functions that take 2 arguments\n**/\nclass Functions2 {\n/**\n`memoize` wraps `callback` and calls it only once storing the result for future needs.\n\nComputed results are stored in an internal map. The keys to this map are generated by\nthe resolver function that by default directly converts the arguments into a string.\n**/\n  public static function memoize<T1, T2, TOut>(callback : T1 -> T2 -> TOut, ?resolver : T1 -> T2 -> String) : T1 -> T2 -> TOut {\n    if(null == resolver)\n      resolver = function(v1 : T1, v2 : T2) return '$v1:$v2';\n    var map = new Map<String, TOut>();\n    return function(v1 : T1, v2 : T2) {\n      var key = resolver(v1, v2);\n      if(map.exists(key))\n        return map.get(key);\n      var result = callback(v1, v2);\n      map.set(key, result);\n      return result;\n    }\n  }\n\n/**\nWraps `callback` in a function that negates its results.\n**/\n  public inline static function negate<T1, T2>(callback : T1 -> T2 -> Bool)\n    return function(v1 : T1, v2 : T2)\n      return !callback(v1, v2);\n}\n\n/**\nHelper class for functions that take 3 arguments\n**/\nclass Functions3 {\n/**\n`memoize` wraps `callback` and calls it only once storing the result for future needs.\n\nComputed results are stored in an internal map. The keys to this map are generated by\nthe resolver function that by default directly converts the arguments into a string.\n**/\n  public static function memoize<T1, T2, T3, TOut>(callback : T1 -> T2 -> T3 -> TOut, ?resolver : T1 -> T2 -> T3 -> String) : T1 -> T2 -> T3 -> TOut {\n    if(null == resolver)\n      resolver = function(v1 : T1, v2 : T2, v3 : T3) return '$v1:$v2:$v3';\n    var map = new Map<String, TOut>();\n    return function(v1 : T1, v2 : T2, v3 : T3) {\n      var key = resolver(v1, v2, v3);\n      if(map.exists(key))\n        return map.get(key);\n      var result = callback(v1, v2, v3);\n      map.set(key, result);\n      return result;\n    }\n  }\n\n/**\nWraps `callback` in a function that negates its results.\n**/\n  public inline static function negate<T1, T2, T3>(callback : T1 -> T2 -> T3 -> Bool)\n    return function(v1 : T1, v2 : T2, v3 : T3)\n      return !callback(v1, v2, v3);\n}\n\n/**\nGeneric helper for functions.\n**/\nclass Functions {\n/**\n`constant` creates a function that always returns the same value.\n**/\n  public static function constant<T>(v : T)\n    return function() return v;\n\n/**\nIt provides strict equality between the two arguments `a` and `b`.\n**/\n  public static function equality<T>(a : T, b : T) : Bool\n    return a == b;\n\n/**\nThe `identity` function returns the value of its argument.\n**/\n  public static function identity<T>(value : T) : T\n    return value;\n\n/**\n`noop` is a function that has no side effects and doesn't return any value.\n**/\n  public static function noop() : Void {}\n}","package thx;\n\nusing thx.Arrays;\nusing thx.Strings;\nusing StringTools;\n\n/**\nExtension methods for integer values.\n**/\nclass Ints {\n  static var pattern_parse = ~/^[+-]?(\\d+|0x[0-9A-F]+)$/i;\n/**\n`abs` returns the absolute integer value of the passed argument.\n**/\n  inline public static function abs(v : Int) : Int\n    return v < 0 ? -v : v;\n\n/**\n`canParse` takes a string and return a boolean indicating if the argument can be safely transformed\ninto a valid integer value.\n**/\n  public static function canParse(s : String)\n    return pattern_parse.match(s);\n\n/**\n`clamp` restricts a value within the specified range.\n**/\n  public static inline function clamp(v : Int, min : Int, max : Int) : Int\n    return v < min ? min : (v > max ? max : v);\n\n/**\nLike clamp but you only pass one argument (`max`) that is used as the upper limit\nand the opposite (additive inverse or `-max`) as the lower limit.\n**/\n  public static inline function clampSym(v : Int, max : Int) : Int\n    return clamp(v, -max, max);\n\n/**\nReturn a comparison value between `a` and `b`. The number is negative if `a` is\ngreater than `b`, positive if `a` is lesser than `b` or zero if `a` and `b` are\nequals.\n**/\n  inline public static function compare(a : Int, b : Int) : Int\n    return a - b;\n\n/**\nGiven a value `t` between 0 and 1, it interpolates that value in the range between `a` and `b`.\n\nThe returned value is a rounded integer.\n*/\n  public static function interpolate(f : Float, a : Float, b : Float) : Int\n    return Math.round(a + (b - a) * f);\n\n/**\n`isEven` returns `true` if `v` is even, `false` otherwise.\n**/\n  inline public static function isEven(v : Int)\n    return v % 2 == 0;\n\n/**\n`isOdd` returns `true` if `v` is odd, `false` otherwise.\n**/\n  inline public static function isOdd(v : Int)\n    return v % 2 != 0;\n\n/**\nIt returns the maximum value between `a` and `b`.\n**/\n  inline public static function max(a : Int, b : Int) : Int\n    return a > b ? a : b;\n\n/**\nIt returns the minimum value between `a` and `b`.\n**/\n  inline public static function min(a : Int, b : Int) : Int\n    return a < b ? a : b;\n\n/**\nParses a string into an Int value using the provided base. Default base is 16 for strings that begin with\n0x (after optional sign) or 10 otherwise.\n**/\n  public static function parse(s : String, ?base : Int) : Null<Int> {\n    #if js\n    var v : Int = untyped __js__(\"parseInt\")(s, base);\n    return Math.isNaN(v) ? null : v;\n    #elseif flash9\n    if(base == null) base = 0;\n    var v : Int = untyped __global__[\"parseInt\"](s, base);\n    return Math.isNaN(v) ? null : v;\n    #else\n\n    if(base != null && (base < 2 || base > BASE.length))\n      return throw 'invalid base $base, it must be between 2 and ${BASE.length}';\n\n    var negative = if(s.startsWith(\"+\")) {\n      s = s.substring(1);\n      false;\n    } else if(s.startsWith(\"-\")) {\n      s = s.substring(1);\n      true;\n    } else {\n      false;\n    };\n\n    if(s.length == 0)\n      return null;\n\n    s = s.trim().toLowerCase();\n\n    if(s.startsWith('0x')) {\n      if(null != base && 16 != base)\n        return null; // attempting at converting a hex using a different base\n      base = 16;\n      s = s.substring(2);\n    } else if(null == base) {\n      base = 10;\n    }\n\n    return try ((negative ? -1 : 1) * s.toArray().reduce(function(acc : Int, c : String) {\n      var i = BASE.indexOf(c);\n      if(i < 0 || i >= base) throw 'invalid';\n      return (acc * base) + i;\n    }, 0) : Null<Int>) catch(e : Dynamic) null;\n    #end\n  }\n\n/**\nInteger random function that includes both upper and lower limits. A roll on a die with\n6 sides would be the equivalent to the following:\n\n```haxe\nvar d6 = Ints.random(1, 6);\n```\n**/\n  inline public static function random(min = 0, max : Int)\n    return Std.random(max + 1) + min;\n\n/**\n`range` creates an array of integer containing values between  start (included) and stop (excluded)\nwith a progression set by `step`. A negative value for `step` can be used but in that\ncase start will need to be a greater value than stop.\n**/\n  public static function range(start : Int, ?stop : Int, step = 1) : Array<Int> {\n    if(null == stop) {\n      stop = start;\n      start = 0;\n    }\n    if((stop - start) / step == Math.POSITIVE_INFINITY) throw \"infinite range\";\n    var range = [], i = -1, j;\n    if(step < 0)\n      while ((j = start + step * ++i) > stop) range.push(j);\n    else\n      while ((j = start + step * ++i) < stop) range.push(j);\n    return range;\n  }\n\n  // Base used for toString/parseInt conversions. Supporting base 2 to 36 for now as common standard.\n  static var BASE = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n/**\nTransform an `Int` value to a `String` using the specified `base`\n**/\n  #if(js || flash) inline #end\n  public static function toString(value : Int, base : Int) : String {\n    #if(js || flash)\n    return untyped value.toString(base);\n    #else\n\n    if(base < 2 || base > BASE.length)\n      return throw 'invalid base $base, it must be between 2 and ${BASE.length}';\n    if(base == 10 || value == 0)\n      return '$value';\n\n    var buf = \"\",\n        abs = Ints.abs(value);\n    while(abs > 0) {\n      buf = BASE.charAt(abs % base) + buf;\n      abs = Std.int(abs / base);\n    }\n\n    return (value < 0 ? \"-\" : \"\") + buf;\n    #end\n  }\n\n/**\nConverts and integer value into a boolean. Any value different from `0` will evaluate to `true`.\n**/\n  public static inline function toBool(v : Int)\n    return v != 0;\n\n/**\n`sign` returns `-1` if `value` is a negative number, `1` otherwise.\n*/\n  inline public static function sign(value : Int) : Int\n    return value < 0 ? -1 : 1;\n\n/**\nSimilar to `wrap`, it works for numbers between 0 and `max`.\n**/\n  public static function wrapCircular(v : Int, max : Int) : Int {\n    v = v % max;\n    if(v < 0)\n      v += max;\n    return v;\n  }\n}","package thx;\n\n#if macro\nimport haxe.macro.Expr;\n#end\n\n/**\nHelper class for `Iterable`. Implementations usually fallback on `thx.Iterators`.\n\nFor documentation of specific methods refer to the equivalent methods in `thx.Arrays`;\n**/\nclass Iterables {\n/**\nChecks if `predicate` returns true for all elements in the iterable.\n**/\n  public static function all<T>(it : Iterable<T>, predicate : T -> Bool)\n    return Iterators.all(it.iterator(), predicate);\n\n/**\nChecks if `predicate` returns true for at least one element in the iterable.\n**/\n  public static function any<T>(it : Iterable<T>, predicate : T -> Bool)\n    return Iterators.any(it.iterator(), predicate);\n\n/**\nRefer to `thx.Arrays.eachPair`.\n**/\n  public inline static function eachPair<TIn, TOut>(it : Iterable<TIn>, handler : TIn -> TIn -> Bool)\n    return Iterators.eachPair(it.iterator(), handler);\n\n/**\nRefer to `Array.filter`.\n**/\n  public inline static function filter<T>(it : Iterable<T>, predicate : T -> Bool) : Array<T>\n    return Iterators.filter(it.iterator(), predicate);\n\n/**\nRefer to `thx.Arrays.filterPluck`.\n**/\n  macro public static function filterPluck<T>(it : ExprOf<Iterable<T>>, expr : ExprOf<Bool>) : ExprOf<Array<T>>\n    return macro thx.Iterators.filter($e{it}.iterator(), function(_) return $e{expr});\n\n/**\nRefer to `thx.Arrays.find`.\n**/\n  public inline static function find<T, TFind>(it : Iterable<T>, predicate : T -> Bool) : Null<T>\n    return Iterators.find(it.iterator(), predicate);\n\n/**\nRefer to `thx.Arrays.first`.\n**/\n  public inline static function first<T, TFind>(it : Iterable<T>) : Null<T>\n    return Iterators.first(it.iterator());\n\n/**\nRefer to `thx.Arrays.last`.\n**/\n  public inline static function last<T, TFind>(it : Iterable<T>) : Null<T>\n    return Iterators.last(it.iterator());\n\n/**\nRefer to `thx.Arrays.isEmpty`.\n**/\n  public inline static function isEmpty<T>(it : Iterable<T>) : Bool\n    return Iterators.isEmpty(it.iterator());\n\n/**\n`isIterable` checks that the passed argument has all the requirements to be an `Iterable`.\n\nNote that no type checking is performed at runtime, only if a method `iterator` exists regardless\nof its signature.\n**/\n  public static function isIterable(v : Dynamic) {\n    var fields = Types.isAnonymousObject(v) ? Reflect.fields(v) : Type.getInstanceFields(Type.getClass(v));\n    if(!Lambda.has(fields, \"iterator\")) return false;\n    return Reflect.isFunction(Reflect.field(v, \"iterator\"));\n  }\n\n/**\nRefer to `Array.map`.\n**/\n  public inline static function map<T, S>(it : Iterable<T>, f : T -> S) : Array<S>\n    return Iterators.map(it.iterator(), f);\n\n/**\nRefer to `thx.Arrays.mapi`.\n**/\n  public inline static function mapi<T, S>(it : Iterable<T>, f : T -> Int -> S) : Array<S>\n    return Iterators.mapi(it.iterator(), f);\n\n/**\nRefer to `thx.Arrays.order`.\n**/\n  public inline static function order<T>(it : Iterable<T>, sort : T -> T -> Int) : Array<T>\n    return Iterators.order(it.iterator(), sort);\n\n/**\nRefer to `thx.Arrays.pluck`.\n**/\n  macro public static function pluck<T, TOut>(it : ExprOf<Iterable<T>>, expr : ExprOf<TOut>) : ExprOf<Array<TOut>>\n    return macro thx.Iterators.map($e{it}.iterator(), function(_) return ${expr});\n\n/**\nRefer to `thx.Arrays.plucki`.\n**/\n  macro public static function plucki<T, TOut>(it : ExprOf<Iterable<T>>, expr : ExprOf<TOut>) : ExprOf<Array<TOut>>\n    return macro thx.Iterators.mapi($e{it}.iterator(), function(_, i) return ${expr});\n\n/**\nRefer to `thx.Arrays.reduce`.\n**/\n  public inline static function reduce<TItem, TAcc>(it : Iterable<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc\n    return Iterators.reduce(it.iterator(), callback, initial);\n\n/**\nRefer to `thx.Arrays.reducei`.\n**/\n  public inline static function reducei<TItem, TAcc>(it : Iterable<TItem>, callback : TAcc -> TItem -> Int -> TAcc, initial : TAcc) : TAcc\n    return Iterators.reducei(it.iterator(), callback, initial);\n\n/**\n`toArray` transforms an `Iterable<T>` into an `Array<T>`.\n**/\n  public inline static function toArray<T>(it : Iterable<T>) : Array<T>\n    return Iterators.toArray(it.iterator());\n}","package thx;\n\n#if macro\nimport haxe.macro.Expr;\n#end\n\n/**\nHelper class to work with `Iterator`.\n\nFor documentation of specific methods refer to the equivalent methods in `thx.Arrays`;\n**/\nclass Iterators {\n/**\nChecks if `predicate` returns true for all elements in the iterator.\n**/\n  public static function all<T>(it : Iterator<T>, predicate : T -> Bool) {\n    for(item in it)\n      if(!predicate(item))\n        return false;\n    return true;\n  }\n\n/**\nChecks if `predicate` returns true for at least one element in the iterator.\n**/\n  public static function any<T>(it : Iterator<T>, predicate : T -> Bool) {\n    for(item in it)\n      if(predicate(item))\n        return true;\n    return false;\n  }\n\n/**\nRefer to `thx.Arrays.eachPair`.\n**/\n  public static function eachPair<TIn, TOut>(it : Iterator<TIn>, handler : TIn -> TIn -> Bool)\n    Arrays.eachPair(toArray(it), handler);\n\n/**\nRefer to `Array.filter`.\n**/\n  public static function filter<TItem>(it : Iterator<TItem>, predicate : TItem -> Bool) : Array<TItem>\n    return reduce(it, function(acc : Array<TItem>, item) {\n        if(predicate(item))\n          acc.push(item);\n        return acc;\n      }, []);\n\n/**\nRefer to `thx.Arrays.filterPluck`.\n**/\n  macro public static function filterPluck<T>(it : ExprOf<Iterator<T>>, expr : ExprOf<Bool>) : ExprOf<Array<T>>\n    return macro thx.Iterators.filter($e{it}, function(_) return $e{expr});\n\n/**\nRefer to `thx.Arrays.find`.\n**/\n  public static function find<T, TFind>(it : Iterator<T>, f : T -> Bool) : Null<T> {\n    for(item in it)\n      if(f(item))\n        return item;\n    return null;\n  }\n\n/**\nRefer to `thx.Arrays.first`.\n**/\n  public static function first<T, TFind>(it : Iterator<T>) : Null<T>\n    return it.hasNext() ? it.next() : null;\n\n/**\nRefer to `thx.Arrays.isEmpty`.\n**/\n  inline public static function isEmpty<T>(it : Iterator<T>) : Bool\n    return !it.hasNext();\n\n/**\n`isIterator` checks that the passed argument has all the requirements to be an `Iterator`.\n\nNote that no type checking is performed at runtime, the method only checks that the value\nhas two fields `next` and `hasNext` and that they are both functions.\n**/\n  public static function isIterator(v : Dynamic) {\n    var fields = Types.isAnonymousObject(v) ? Reflect.fields(v) : Type.getInstanceFields(Type.getClass(v));\n    if(!Lambda.has(fields, \"next\") || !Lambda.has(fields, \"hasNext\")) return false;\n    return Reflect.isFunction(Reflect.field(v, \"next\")) && Reflect.isFunction(Reflect.field(v, \"hasNext\"));\n  }\n\n/**\nRefer to `thx.Arrays.last`.\n**/\n  public static function last<T, TFind>(it : Iterator<T>) : Null<T> {\n    var buf = null;\n    while(it.hasNext()) buf = it.next();\n    return buf;\n  }\n\n/**\nRefer to `Array.map`.\n**/\n  public static function map<T, S>(it : Iterator<T>, f : T -> S) : Array<S> {\n    var acc = [];\n    for(v in it)\n      acc.push(f(v));\n    return acc;\n  }\n\n/**\nRefer to `thx.Arrays.mapi`.\n**/\n  public static function mapi<T, S>(it : Iterator<T>, f : T -> Int -> S) : Array<S> {\n    var acc = [],\n        i = 0;\n    for(v in it)\n      acc.push(f(v, i++));\n    return acc;\n  }\n\n/**\nRefer to `thx.Arrays.order`.\n**/\n  public static function order<T>(it : Iterator<T>, sort : T -> T -> Int) {\n    var n = Iterators.toArray(it);\n    n.sort(sort);\n    return n;\n  }\n\n/**\nRefer to `thx.Arrays.pluck`.\n**/\n  macro public static function pluck<T, TOut>(it : ExprOf<Iterator<T>>, expr : ExprOf<TOut>) : ExprOf<Array<TOut>>\n    return macro thx.Iterators.map($e{it}, function(_) return ${expr});\n\n/**\nRefer to `thx.Arrays.plucki`.\n**/\n  macro public static function plucki<T, TOut>(it : ExprOf<Iterator<T>>, expr : ExprOf<TOut>) : ExprOf<Array<TOut>>\n    return macro thx.Iterators.mapi($e{it}, function(_, i) return ${expr});\n\n/**\nRefer to `thx.Arrays.reduce`.\n**/\n  public static function reduce<TItem, TAcc>(it : Iterator<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc {\n    map(it, function(v) initial = callback(initial, v));\n    return initial;\n  }\n\n/**\nRefer to `thx.Arrays.reducei`.\n**/\n  public static function reducei<TItem, TAcc>(it : Iterator<TItem>, callback : TAcc -> TItem -> Int -> TAcc, initial : TAcc) : TAcc {\n    mapi(it, function(v, i) initial = callback(initial, v, i));\n    return initial;\n  }\n\n/**\n`toArray` transforms an `Iterator<T>` into an `Array<T>`.\n**/\n  public static function toArray<T>(it : Iterator<T>) : Array<T> {\n    var items = [];\n    for(item in it)\n      items.push(item);\n    return items;\n  }\n\n}","package thx;\n\n#if (haxe_ver >= 3.200)\nimport haxe.Constraints.IMap;\n#else\nimport Map.IMap;\n#end\nimport thx.Tuple;\nusing thx.Iterators;\nusing thx.Arrays;\n\n/**\nExtension methods for Maps\n**/\nclass Maps {\n/**\nConverts a Map<TKey, TValue> into an Array<Tuple2<TKey, TValue>>\n**/\n  public static function tuples<TKey, TValue>(map: IMap<TKey, TValue>): Array<Tuple2<TKey, TValue>>\n    return map.keys().map(function(key)\n      return new Tuple2(key, map.get(key))\n    );\n\n/**\n`mapToObject` transforms a `Map<String, T>` into an anonymous object.\n**/\n  public static function mapToObject<T>(map : Map<String, T>) : {}\n    return tuples(map).reduce(function(o, t) {\n      Reflect.setField(o, t._0, t._1);\n      return o;\n    }, {});\n\n/**\nGiven a `key` returns the associated value from `map`. If the key doesn't exist or the associated value is `null`,\nit returns the provided `alt` value instead.\n**/\n  public static function getAlt<TKey, TValue>(map : Map<TKey, TValue>, key : TKey, alt : TValue) : TValue {\n    var v = map.get(key);\n    return null == v ? alt : v;\n  }\n\n/**\nReturns true if a value is of any type of Map. Equivalent to `Std.is(v, IMap)`.\n**/\n  inline public static function isMap(v : Dynamic)\n    return Std.is(v, IMap);\n}\n","package thx;\n\nimport thx.Dynamics;\nimport thx.Tuple;\nusing thx.Arrays;\n\n/**\nHelper methods for generic objects.\n**/\nclass Objects {\n/**\n`isEmpty` returns `true` if the object doesn't have any field.\n**/\n  inline public static function isEmpty(o : {}) : Bool\n    return size(o) == 0;\n\n/**\n`exists` returns true if `o` contains a field named `name`.\n**/\n  inline public static function exists(o : {}, name : String) : Bool\n    return Reflect.hasField(o, name);\n\n/**\n`fields` returns an array of string containing the field names of the argument object.\n**/\n  inline public static function fields(o : {}) : Array<String>\n    return Reflect.fields(o);\n\n/**\nCopies the values from the fields of `from` to `to`. If `to` already contains those fields, then it replace\nthose values with the return value of the function `replacef`.\n\nIf not set, `replacef` always returns the value from the `from` object.\n**/\n  public static function merge(to : {}, from : {}, ?replacef : String -> Dynamic -> Dynamic -> Dynamic) : {} {\n    if(null == replacef)\n      replacef = function(field : String, oldv : Dynamic, newv : Dynamic) return newv;\n    for(field in Reflect.fields(from)) {\n      var newv = Reflect.field(from, field);\n      if(Reflect.hasField(to, field)) {\n        Reflect.setField(to, field, replacef(field, Reflect.field(to, field), newv));\n      } else {\n        Reflect.setField(to, field, newv);\n      }\n    }\n    return to;\n  }\n\n/**\n`copyTo` copies the fields from `src` to `dst` using `Reflect.setField()` and `Dynamics.clone()`.\nAnonymous objects are entered into and copied recursively.\n**/\n  public static function copyTo(src : { }, dst : { }, cloneInstances = false) : {} {\n    for (field in Reflect.fields(src)) {\n      var sv = Dynamics.clone(Reflect.field(src, field),cloneInstances);\n      var dv = Reflect.field(dst, field);\n      if (Types.isAnonymousObject(sv) && Types.isAnonymousObject(dv)) {\n        copyTo(sv, dv);\n      } else {\n        Reflect.setField(dst, field, sv);\n      }\n    }\n    return dst;\n  }\n\n/**\nClone the current object by creating a new object and using `copyTo` to clone each field.\n**/\n  public static function clone<T:{}>(src : T, cloneInstances = false) : T {\n    return Dynamics.clone(src,cloneInstances);\n  }\n\n\n/**\n`objectToMap` transforms an anonymous object into an instance of `Map<String, Dynamic>`.\n**/\n  public static function objectToMap(o : {}) : Map<String, Dynamic>\n    return tuples(o).reduce(function(map : Map<String, Dynamic>, t) {\n      map.set(t._0, t._1);\n      return map;\n    }, new Map());\n\n/**\n`size` returns how many fields are present in the object.\n**/\n  inline public static function size(o : {}) : Int\n    return Reflect.fields(o).length;\n\n/**\n`values` returns an array of dynamic values containing the values of each field in the argument object.\n**/\n  inline public static function values(o : {}) : Array<Dynamic>\n    return Reflect.fields(o).map(function(key) return Reflect.field(o, key));\n\n/**\nConverts an object into an Array<Tuple2<String, Dynamic>> where the left value (_0) of the\ntuple is the field name and the right value (_1) is the field value.\n**/\n  public static function tuples(o : {}): Array<Tuple2<String, Dynamic>>\n    return Reflect.fields(o).map(function(key)\n        return new Tuple2(key, Reflect.field(o, key))\n    );\n}","package thx;\n\nimport haxe.ds.Option;\n\n/**\nExtension methods for the `haxe.ds.Option` type.\n**/\nclass Options {\n/**\nEquality function to campare two `Option` values of the same type. An optional equality\nfunction can be provided if values inside `Some` should be compared using something\ndifferent than strict equality.\n**/\n  public static function equals<T>(a : Option<T>, b : Option<T>, ?eq : T -> T -> Bool)\n    return switch [a, b] {\n      case [None, None]: true;\n      case [Some(a), Some(b)]:\n        if(null == eq)\n          eq = function(a, b) return a == b;\n        eq(a,b);\n      case [_, _]:\n        false;\n    };\n\n/**\n`equalsValue` compares an `Option<T>` with a value `T`. The logic adopted to compare\nvalues is the same as in `Options.equals()`.\n**/\n  public static function equalsValue<T>(a : Option<T>, b : Null<T>, ?eq : T -> T -> Bool)\n    return equals(a, toOption(b), eq);\n\n/**\n`flatMap` reduces an `Option<T>` value into an `Array<T>` value applying the `callback`\nfunction if `Option` contains a value. If `Option` is `None` an empty array is returned.\n**/\n  public static function flatMap<T, TOut>(option : Option<T>, callback : T -> Array<TOut>) : Array<TOut>\n    return switch option {\n      case None: [];\n      case Some(v): callback(v);\n    };\n\n/**\n`map` transforms a value contained in `Option<T>` to `Option<TOut>` using a `callback`.\n`callback` is used only if `Option` is `Some(value)`.\n**/\n  public static function map<T, TOut>(option : Option<T>, callback : T -> TOut) : Option<TOut>\n    return switch option {\n      case None: None;\n      case Some(v): Some(callback(v));\n    };\n\n/**\n`toArray` transforms an `Option<T>` value into an `Array<T>` value. The result array\nwill be empty if `Option` is `None` or will contain one value otherwise.\n**/\n  public static function toArray<T>(option : Option<T>) : Array<T>\n    return switch option {\n      case None: [];\n      case Some(v) : [v];\n    };\n\n/**\n`toBool` transforms an `Option` value into a boolean: `None` maps to `false`, and\n`Some(_)` to `true`. The value in `Some` has no play in the conversion.\n**/\n  #if java @:generic #end\n  public static function toBool<T>(option : Option<T>) : Bool\n    return switch option {\n      case None: false;\n      case Some(_) : true;\n    };\n\n/**\n`toOption` transforms any type T into `Option<T>`. If the value is null, the result\nis be `None`.\n**/\n  inline public static function toOption<T>(value : Null<T>) : Option<T>\n    return null == value ? None : Some(value);\n\n/**\n`toValue` extracts the value from `Option`. If the `Option` is `None`, `null` is returned.\n**/\n  public static function toValue<T>(option : Option<T>) : Null<T>\n    return switch option {\n      case None: null;\n      case Some(v) : v;\n    };\n}","package thx;\n\nimport haxe.ds.Option;\n\n/**\n`Result` is a wrapper type (abstract) around the `Either` type to semantically represent the state of an operation.\n*/\nabstract Result<TSuccess, TFailure>(Either<TFailure, TSuccess>) from Either<TFailure, TSuccess> to Either<TFailure, TSuccess> {\n/**\nIt is true if `Result` wraps a value.\n*/\n  public var isSuccess(get, never) : Bool;\n\n/**\nIt is true if `Result` wraps an error.\n*/\n  public var isFailure(get, never) : Bool;\n\n/**\nConverts `Result<TSuccess, TFailure>` into `Option<TSuccess>`. The result is `Some(value)` if `Result` contained a value.\nIt is `None` if it contains an error.\n*/\n  @:to public function optionValue() : Option<TSuccess>\n    return switch this {\n      case Right(v): Some(v);\n      case _: None;\n    };\n\n/**\nConverts `Result<TSuccess, TFailure>` into `Option<TFailure>`. The result is `Some(error)` if `Result` contained an error.\nIt is `None` if it contains a value.\n*/\n  @:to public function optionError() : Option<TFailure>\n    return switch this {\n      case Left(v): Some(v);\n      case _: None;\n    };\n\n/**\nConverts `Result` into a nullable value of type TSuccess.\n*/\n  @:to public function value() : Null<TSuccess>\n    return switch this {\n      case Right(v): v;\n      case _: null;\n    };\n\n/**\nConverts `Result` into a nullable value of type TFailure.\n*/\n  @:to public function error() : Null<TFailure>\n    return switch this {\n      case Left(v): v;\n      case _: null;\n    };\n\n  function get_isSuccess()\n    return switch this {\n      case Right(_): true;\n      case _: false;\n    };\n\n  function get_isFailure()\n    return switch this {\n      case Left(_): true;\n      case _: false;\n    };\n}","package thx;\n\n/**\nA set is a list of unique values.\n**/\n@:forward(indexOf, iterator, lastIndexOf, length, map, pop, remove, reverse, shift, sort)\nabstract Set<T>(Array<T>) {\n/**\n`arrayToSet` converts an `Array` into a `Set` removing all duplicated values.\n**/\n  @:from public static function arrayToSet<T>(arr : Array<T>) {\n    var set = new Set([]);\n    for(v in arr)\n      set.push(v);\n    return set;\n  }\n\n/**\nCreates an empty Set if no argument is provided or it fallsback to `arrayToSet` otherwise.\n**/\n  public static function create<T>(?arr : Array<T>)\n    return null == arr ? new Set<T>([]) : arrayToSet(arr);\n\n  inline function new(arr : Array<T>)\n    this = arr;\n\n/**\n`add` pushes a value onto the end of the `Set` if the value was not already present.\n\nIt returns a boolean value indicating if the `Set` was changed by operation or not.\n**/\n  public function add(v : T) : Bool\n    return if(exists(v))\n      false;\n    else {\n      this.push(v);\n      true;\n    }\n\n/**\n`copy` creates a new `Set` with copied elements.\n**/\n  inline public function copy()\n    return new Set(this.copy());\n\n/**\n`difference` creates a new `Set` with elements from the first set excluding the elements\nfrom the second.\n**/\n  @:op(A-B) inline public function difference(set : Set<T>) : Set<T> {\n    var result = this.copy();\n    for(item in set)\n      result.remove(item);\n    return new Set(result);\n  }\n\n/**\n`exists` returns `true` if it contains an element that is equals to `v`.\n**/\n  public function exists(v : T) : Bool {\n    for (t in this)\n      if (t == v)\n        return true;\n    return false;\n  }\n\n/**\n`get` returns the element at the specified position or `null` if the `index` is\noutside the boundaries.\n**/\n  @:arrayAccess\n  inline public function get(index : Int) : Null<T>\n    return this[index];\n\n/**\n`intersection` returns a Set with elements that are presents in both sets\n**/\n  inline public function intersection(set : Set<T>) : Set<T> {\n    var result = [];\n    for(item in this)\n      if(set.exists(item))\n        result.push(item);\n    return new Set(result);\n  }\n\n/**\nLike `add` but doesn't notify if the addition was successful or not.\n**/\n  public function push(v : T) : Void\n    add(v);\n\n/**\nSame operations as `Array.slice()` but it returns a new `Set` instead of an array.\n**/\n  inline public function slice(pos : Int, ?end : Int) : Set<T>\n    return new Set(this.slice(pos, end));\n\n/**\nSame operations as `Array.splice()` but it returns a new `Set` instead of an array.\n**/\n  inline public function splice(pos : Int, len : Int) : Set<T>\n    return new Set(this.splice(pos, len));\n\n/**\nUnion creates a new Set with elements from bots sets.\n**/\n  @:op(A+B) inline public function union(set : Set<T>) : Set<T>\n    return arrayToSet(this.concat(set.setToArray()));\n\n/**\nConverts a `Set<T>` into `Array<T>`. The returned array is a copy of the internal\narray used by `Set`. This ensures that the set is not affected by unsafe operations\nthat might happen on the returned array.\n**/\n  @:to public function setToArray()\n    return this.copy();\n\n/**\nConverts `Set` into `String`. To differentiate from normal `Array`s the output string\nuses curly braces `{}` instead of square brackets `[]`.\n**/\n  @:to public function toString()\n    return \"{\" + this.join(\", \") + \"}\";\n}","package thx;\n\nusing StringTools;\n\n/**\nExtension methods for strings.\n**/\nclass Strings {\n/**\n`after` searches for the first occurrance of `searchFor` and returns the text after that.\n\nIf `searchFor` is not found, an empty string is returned.\n**/\n  public static function after(value : String, searchFor : String) {\n    var pos = value.indexOf(searchFor);\n    if (pos < 0)\n      return \"\";\n    else\n      return value.substring(pos + searchFor.length);\n  }\n\n/**\n`capitalize` returns a string with the first character convert to upper case.\n**/\n  inline public static function capitalize(s : String)\n    return s.substring(0, 1).toUpperCase() + s.substring(1);\n\n/**\nCapitalize the first letter of every word in `value`. If `whiteSpaceOnly` is set to `true`\nthe process is limited to whitespace separated words.\n**/\n  public static function capitalizeWords(value : String, ?whiteSpaceOnly = false) : String {\n    if(whiteSpaceOnly) {\n#if php\n      return untyped __call__(\"ucwords\", value);\n#else\n      return UCWORDSWS.map(capitalize(value), upperMatch);\n#end\n    } else {\n      return UCWORDS.map(capitalize(value), upperMatch);\n    }\n  }\n\n/**\nIt cleans up all the whitespaces in the passed `value`. `collapse` does the following:\n\n  - remove trailing/leading whitespaces\n  - within the string, it collapses seqeunces of whitespaces into a single space character\n\nFor whitespaces in this description, it is intended to be anything that is matched by the regular expression `\\s`.\n**/\n  public static function collapse(value : String)\n    return WSG.replace(StringTools.trim(value), \" \");\n\n/**\nIt compares to string and it returns a negative number if `a` is inferior to `b`, zero if they are the same,\nor otherwise a positive non-sero number.\n**/\n  public static function compare(a : String, b : String)\n    return a < b ? -1 : a > b ? 1 : 0;\n\n/**\n`contains` returns `true` is `s` contains one or more occurrences of `test`.\n**/\n  inline public static function contains(s : String, test : String)\n    return s.indexOf(test) >= 0;\n\n/**\n`dasherize` replaces all the occurrances of `_` with `-`;\n**/\n  public static function dasherize(s : String)\n    return s.replace('_', '-');\n\n/**\n`ellipsis` truncates `s` at len `maxlen` replaces the last characters with the content\nof `symbol`.\n\n```haxe\n'thx is a nice linrary'.ellipsis(7); // returns 'thx is ...'\n```\n**/\n  public static function ellipsis(s : String, maxlen = 20, symbol = \"...\")\n    return if (s.length > maxlen)\n      s.substring(0, symbol.length > maxlen - symbol.length ? symbol.length : maxlen - symbol.length) + symbol;\n    else\n      s;\n\n/**\n`filter` applies `predicate` character by character to `s` and it returns a filtered\nversion of the string.\n**/\n  public static function filter(s : String, predicate : String -> Bool)\n    return toArray(s)\n      .filter(predicate)\n      .join('');\n\n/**\nSame as `filter` but `predicate` operates on integer char codes instead of string characters.\n**/\n  public static function filterCharcode(s : String, predicate : Int -> Bool)\n    return toCharcodeArray(s)\n      .filter(predicate)\n      .map(function(i) return String.fromCharCode(i))\n      .join('');\n\n/**\n`from` searches for the first occurrance of `searchFor` and returns the text from that point on.\n\nIf `searchFor` is not found, an empty string is returned.\n**/\n  public static function from(value : String, searchFor : String) {\n    var pos = value.indexOf(searchFor);\n    if (pos < 0)\n      return \"\";\n    else\n      return value.substring(pos);\n  }\n\n/**\nWorks the same as `underscore` but also replaces underscores with whitespaces.\n**/\n  public static function humanize(s : String)\n    return underscore(s).replace('_', ' ');\n\n/**\n`isAlphaNum` returns `true` if the string only contains alpha-numeric characters.\n**/\n  public static inline function isAlphaNum(value : String) : Bool\n#if php\n    return untyped __call__(\"ctype_alnum\", value);\n#else\n    return ALPHANUM.match(value);\n#end\n\n/**\nReturns `true` if the value string is composed of only lower cased characters\nor case neutral characters.\n**/\n  public static function isLowerCase(value : String) : Bool\n    return value.toLowerCase() == value;\n\n/**\nReturns `true` if the value string is composed of only upper cased characters\nor case neutral characters.\n**/\n  public static function isUpperCase(value : String) : Bool\n    return value.toUpperCase() == value;\n\n/**\n`ifEmpty` returns `value` if it is neither `null` or empty, otherwise it returns `alt`\n**/\n  public static inline function ifEmpty(value : String, alt : String) : String\n    return null != value && \"\" != value ? value : alt;\n\n/**\n`isDigitsOnly` returns `true` if the string only contains digits.\n**/\n  public static inline function isDigitsOnly(value : String) : Bool\n#if php\n    return untyped __call__(\"ctype_digit\", value);\n#else\n    return DIGITS.match(value);\n#end\n\n/**\n`isEmpty` returns true if either `value` is null or is an empty string.\n**/\n  public static function isEmpty(value : String)\n    return value == null || value == '';\n\n/**\nReturns a random substring from the `value` argument. The length of such value is by default `1`.\n**/\n  public static function random(value : String, length = 1)\n    return value.substr(Math.floor((value.length - length + 1) * Math.random()), length);\n\n/**\nIt returns an iterator holding in sequence one character of the string per iteration.\n**/\n  public static function iterator(s : String) : Iterator<String>\n    return s.split('').iterator();\n\n/**\nIt maps a string character by character using `callback`.\n**/\n  public static function map<T>(value : String, callback : String -> T) : Array<T>\n    return toArray(value).map(callback);\n\n/**\nIf present, it removes all the occurrencies of `toremove` from `value`.\n**/\n  inline public static function remove(value : String, toremove : String) : String\n    return StringTools.replace(value, toremove, \"\");\n\n\n/**\nIf present, it removes the `toremove` text from the end of `value`.\n**/\n  public static function removeAfter(value : String, toremove : String) : String\n    return StringTools.endsWith(value, toremove) ? value.substring(0, value.length - toremove.length) : value;\n\n/**\nIf present, it removes the `toremove` text from the beginning of `value`.\n**/\n  public static function removeBefore(value : String, toremove : String) : String\n    return StringTools.startsWith(value, toremove) ? value.substring(toremove.length) : value;\n\n/**\n`repeat` builds a new string by repeating the argument `s`, n `times`.\n\n```haxe\n'Xy'.repeat(3); // generates 'XyXyXy'\n```\n**/\n  public static function repeat(s : String, times : Int)\n    return [for(i in 0...times) s].join('');\n\n/**\nReturns a new string whose characters are in reverse order.\n**/\n  public static function reverse(s : String) {\n    var arr = s.split(\"\");\n    arr.reverse();\n    return arr.join(\"\");\n  }\n\n/**\n`stripTags` removes any HTML/XML markup from the string leaving only the concatenation\nof the existing text nodes.\n**/\n  public static function stripTags(s : String) : String\n#if php\n    return untyped __call__(\"strip_tags\", s);\n#else\n    return STRIPTAGS.replace(s, \"\");\n#end\n\n/**\nSurrounds a string with the contents of `left` and `right`. If `right` is omitted,\n`left` will be used on both sides;\n*/\n  inline public static function surround(s : String, left : String, ?right : String)\n    return '$left$s${null==right?left:right}';\n\n/**\nIt transforms a string into an `Array` of characters.\n**/\n  inline public static function toArray(s : String)\n    return s.split('');\n\n/**\nIt transforms a string into an `Array` of char codes in integer format.\n**/\n  inline public static function toCharcodeArray(s : String) : Array<Int>\n    return map(s, function(s : String)\n        // the cast is required to compile safely to C#\n        return (s.charCodeAt(0) : Int));\n\n/**\nReturns an array of `String` whose elements are equally long (using `len`). If the string `s`\nis not exactly divisible by `len` the last element of the array will be shorter.\n**/\n  public static function toChunks(s : String, len : Int) : Array<String> {\n    var chunks = [];\n    while(s.length > 0) {\n      chunks.push(s.substring(0, len));\n      s = s.substring(len);\n    }\n    return chunks;\n  }\n\n/**\n`trimChars` removes from the beginning and the end of the string any character that is present in `charlist`.\n**/\n  public static inline function trimChars(value : String, charlist : String) : String\n#if php\n    return untyped __call__(\"trim\", value, charlist);\n#else\n    return trimCharsRight(trimCharsLeft(value, charlist), charlist);\n#end\n\n/**\n`trimCharsLeft` removes from the beginning of the string any character that is present in `charlist`.\n**/\n  public static function trimCharsLeft(value : String, charlist : String) : String {\n#if php\n    return untyped __call__(\"ltrim\", value, charlist);\n#else\n    var pos = 0;\n    for(i in 0...value.length)\n      if(contains(charlist, value.charAt(i)))\n        pos++;\n      else\n        break;\n    return value.substring(pos);\n#end\n  }\n\n/**\n`trimCharsRight` removes from the end of the string any character that is present in `charlist`.\n**/\n  public static function trimCharsRight(value : String, charlist : String) : String {\n#if php\n    return untyped __call__(\"rtrim\", value, charlist);\n#else\n    var len = value.length,\n        pos = len,\n        i;\n    for(j in 0...len) {\n      i = len - j - 1;\n      if(contains(charlist, value.charAt(i)))\n        pos = i;\n      else\n        break;\n    }\n    return value.substring(0, pos);\n#end\n  }\n\n/**\n`underscore` finds UpperCase characters and turns them into LowerCase and prepends them with a whtiespace.\nSequences of more than one UpperCase character are left untouched.\n**/\n  public static function underscore(s : String) {\n    s = (~/::/g).replace(s, '/');\n    s = (~/([A-Z]+)([A-Z][a-z])/g).replace(s, '$1_$2');\n    s = (~/([a-z\\d])([A-Z])/g).replace(s, '$1_$2');\n    s = (~/-/g).replace(s, '_');\n    return s.toLowerCase();\n  }\n\n/**\n`upTo` searches for the first occurrance of `searchFor` and returns the text up to that point.\n\nIf `searchFor` is not found, the entire string is returned.\n**/\n  public static function upTo(value : String, searchFor : String) {\n    var pos = value.indexOf(searchFor);\n    if (pos < 0)\n      return value;\n    else\n      return value.substring(0, pos);\n  }\n\n/**\n`wrapColumns` splits a long string into lines that are at most `columns` long.\n\nWords whose length exceeds `columns` are not split.\n**/\n  public static function wrapColumns(s : String, columns = 78, indent = \"\", newline = \"\\n\")\n    return SPLIT_LINES.split(s).map(function(part)\n        return wrapLine(\n            StringTools.trim(WSG.replace(part, \" \")),\n            columns, indent, newline)\n      ).join(newline);\n\n  static function upperMatch(re : EReg)\n    return re.matched(0).toUpperCase();\n\n\n  static function wrapLine(s : String, columns : Int, indent : String, newline : String) {\n    var parts = [],\n      pos = 0,\n      len = s.length,\n      ilen = indent.length;\n    columns -= ilen;\n    while(true) {\n      if(pos + columns >= len - ilen) {\n        parts.push(s.substring(pos));\n        break;\n      }\n\n      var i = 0;\n      while(!StringTools.isSpace(s, pos + columns - i) && i < columns)\n        i++;\n      if(i == columns) {\n        // search ahead\n        i = 0;\n        while(!StringTools.isSpace(s, pos + columns + i) && pos + columns + i < len)\n          i++;\n        parts.push(s.substring(pos, pos + columns + i));\n        pos += columns + i + 1;\n      } else {\n        parts.push(s.substring(pos, pos + columns - i));\n        pos += columns - i + 1;\n      }\n    }\n\n    return indent + parts.join(newline + indent);\n  }\n\n  static var UCWORDS = ~/[^a-zA-Z]([a-z])/g;\n#if !php\n  static var UCWORDSWS = ~/\\s[a-z]/g;\n  static var ALPHANUM = ~/^[a-z0-9]+$/i;\n  static var DIGITS = ~/^[0-9]+$/;\n  static var STRIPTAGS = ~/<\\/?[a-z]+[^>]*?\\/?>/gi;\n#end\n  static var WSG = ~/\\s+/g;\n  static var SPLIT_LINES = ~/\\r\\n|\\n\\r|\\n|\\r/g;\n}\n\n/** Alias of `StringTools`, included so mixins work with `using thx.Strings;` **/\ntypedef HaxeStringTools = StringTools;","package thx;\n\n/**\n`Timer` provides several meaning to delay the execution of code. At the moment it is only\nimplemented for platforms that have a native concept of Timer like Swf and JavaScript or c++/Neko\nwith OpenFL or NME.\n\nAll of the Timer methods return a function with signature Void -> Void that can be used to cancel\nthe timer.\n\n```haxe\n// set the execution delayed by 200ms\nvar cancel = Timer.delay(doSomethingLater, 200);\n\n// cancel immediately (doSomethingLater will never be executed)\ncancel();\n```\n\nNote that calling the cancel function multiple times have no effect after the first execution.\n**/\nclass Timer {\n/**\nCreates a function that delays the execution of `callback` by `delayms` every time it is\ninvoked. If `leading` is set to true, a first execution is guaranteed to happen as soon\nas the returnd function is invoked.\n**/\n  public static function debounce(callback : Void -> Void, delayms : Int, leading = false) {\n    var cancel = Functions.noop;\n    function poll() {\n      cancel();\n      cancel = Timer.delay(callback, delayms);\n    }\n    return function() {\n        if(leading) {\n          leading = false;\n          callback();\n        }\n        poll();\n    }\n  }\n\n/**\nThe returned function executes `callback` at most once every `delayms` regardless of\nhow many times it is invoked in that timespance. Setting `leading` to true ensures\nthat the callback is invoked at the beginning of the cycle.\n**/\n  public static function throttle(callback : Void -> Void, delayms : Int, leading = false) {\n    var waiting = false;\n    function poll() {\n      waiting = true;\n      Timer.delay(callback, delayms);\n    }\n    return function() {\n        if(leading) {\n          leading = false;\n          callback();\n          return;\n        }\n        if(waiting)\n          return;\n        poll();\n    };\n  }\n\n// IMPLEMENTATIONS\n\n#if !(js || flash)\n  static var timers = new Map<Int, haxe.Timer>();\n  static var _id = 0;\n#end\n\n/**\n`Timer.repeat` continues to invoke `callback` until it is cancelled using the returned\ncancel function.\n**/\n  public static function repeat(callback : Void -> Void, delayms : Int) : Void -> Void {\n#if js\n    return clear.bind(untyped __js__('setInterval')(callback, delayms));\n#elseif flash9\n    return clear.bind(untyped __global__[\"flash.utils.setInterval\"](callback, delayms));\n#elseif flash\n    return clear.bind(untyped _global[\"setInterval\"](callback, delayms));\n#elseif java\n    var timer = new java.util.Timer();\n    timer.scheduleAtFixedRate(new TimerTask(callback), haxe.Int64.ofInt(delayms), haxe.Int64.ofInt(delayms));\n    return timer.cancel;\n#elseif !lime\n    return throw \"platform does not support delays (Timer.repeat)\";\n#else\n    var id = _id++,\n        timer = new haxe.Timer(delayms);\n    timer.run = callback;\n    timers.set(id, timer);\n    return clear.bind(id);\n#end\n  }\n\n/**\n`Timer.delay` invokes `callback` after `delayms` milliseconds. The scheduling can be\ncanelled using the returned cancel function.\n**/\n  public static function delay(callback : Void -> Void, delayms : Int) : Void -> Void {\n#if js\n    return clear.bind(untyped __js__('setTimeout')(callback, delayms));\n#elseif flash9\n    return clear.bind(untyped __global__[\"flash.utils.setTimeout\"](callback, delayms));\n#elseif flash\n    return clear.bind(untyped _global[\"setTimeout\"](callback, delayms));\n#elseif java\n    var timer = new java.util.Timer();\n    timer.scheduleAtFixedRate(new TimerTask(function() {\n      timer.cancel();\n      callback();\n    }), haxe.Int64.ofInt(delayms), haxe.Int64.ofInt(delayms));\n    return timer.cancel;\n#elseif !lime\n    return throw \"platform does not support delays (Timer.delay)\";\n#else\n    var id = _id++,\n        timer = haxe.Timer.delay(function() {\n          callback();\n          clear(id);\n        }, delayms);\n    timers.set(id, timer);\n    return clear.bind(id);\n#end\n  }\n\n/**\nInvokes `callback` at every frame using native implementation where available. A delta time\nin milliseconds is passed since the latest time callback was invoked.\n**/\n  public static function frame(callback : Float -> Void) {\n#if js\n    var cancelled = false,\n        f = Functions.noop,\n        current = time(),\n        next;\n    f = function() {\n          if(cancelled) return;\n          next = time();\n          callback(next - current);\n          current = next;\n          untyped __js__(\"requestAnimationFrame\")(f);\n        };\n\n    untyped __js__(\"requestAnimationFrame\")(f);\n    return function() cancelled = true;\n#elseif openfl\n    var current = time(),\n        next,\n        listener = function(_) {\n          next = time();\n          callback(next - current);\n          current = next;\n        };\n    openfl.Lib.current.addEventListener(openfl.events.Event.ENTER_FRAME, listener);\n    return function()\n      openfl.Lib.current.removeEventListener(openfl.events.Event.ENTER_FRAME, listener);\n#elseif flash9\n    var current = time(),\n        next,\n        listener = function(_) {\n          next = time();\n          callback(next - current);\n          current = next;\n        };\n    flash.Lib.current.addEventListener(flash.events.Event.ENTER_FRAME, listener);\n    return function()\n      flash.Lib.current.removeEventListener(flash.events.Event.ENTER_FRAME, listener);\n#else\n    var current = time(),\n        next,\n        listener = function() {\n          next = time();\n          callback(next - current);\n          current = next;\n        };\n    return repeat(listener, FRAME_RATE);\n#end\n  }\n\n/**\nDelays `callback` untile the next frame using native implementation where available.\n**/\n  public static function nextFrame(callback : Void -> Void) {\n#if js\n    var id = untyped __js__(\"requestAnimationFrame\")(callback);\n    return function() untyped __js__(\"cancelAnimationFrame\")(id);\n#elseif openfl\n    var listener = null,\n        cancel = function() openfl.Lib.current.removeEventListener(openfl.events.Event.ENTER_FRAME, listener);\n    listener = function(_) {\n      cancel();\n      callback();\n    };\n    openfl.Lib.current.addEventListener(openfl.events.Event.ENTER_FRAME, listener);\n    return cancel;\n#elseif flash9\n    var listener = null,\n        cancel = function() flash.Lib.current.removeEventListener(flash.events.Event.ENTER_FRAME, listener);\n    listener = function(_) {\n      cancel();\n      callback();\n    };\n    flash.Lib.current.addEventListener(flash.events.Event.ENTER_FRAME, listener);\n    return cancel;\n#else\n  return delay(callback, FRAME_RATE);\n#end\n  }\n\n  static var FRAME_RATE = Math.round(1000 / 60);\n\n/**\n`Timer.immediate` works essentially like `Timer.delay` with the exception that the delay\nwill be the shortest allowed by the platform. How short the delay depends a lot on\nthe target platform.\n**/\n  public static function immediate(callback : Void -> Void) : Void -> Void\n#if js\n    return clear.bind(untyped __js__('setImmediate')(callback));\n#elseif java\n    // not sure why this is needed\n    return delay(callback, 1);\n#else\n    return delay(callback, 0);\n#end\n\n  static #if js inline #end function clear(id) : Void {\n#if js\n    return untyped __js__('clearTimeout')(id);\n#elseif flash9\n    return untyped __global__[\"flash.utils.clearTimeout\"](id);\n#elseif flash\n    return untyped _global[\"clearTimeout\"](id);\n#elseif !lime\n    return throw \"platform does not support delays (Timer.clear)\";\n#else\n    var timer = timers.get(id);\n    if(null != timer) {\n      timers.remove(id);\n      timer.stop();\n    }\n#end\n  }\n\n\n/**\nReturns a time value in milliseconds. Where supported, the decimal value represents microseconds.\n\nNote that the initial value might change from platfomr to platform so only delta measurements make sense.\n**/\n  inline public static function time() : Float\n#if js\n    return untyped __js__(\"performance\").now();\n#elseif openfl\n    return openfl.Lib.getTimer();\n#elseif flash\n    return flash.Lib.getTimer();\n#elseif cpp\n    return untyped __global__.__time_stamp() / 1000;\n#elseif sys\n    return Sys.time() * 1000;\n#else\n    return throw 'Timer.time() is not implemented in this target';\n#end\n\n#if js\n  static function __init__() untyped {\n    // Polyfills\n    // SCOPE\n    var scope : Dynamic = __js__('(\"undefined\" !== typeof window && window) || (\"undefined\" !== typeof global && global) || this');\n\n    // setImmediate\n    if(!scope.setImmediate)\n      scope.setImmediate = function(callback) scope.setTimeout(callback, 0);\n\n    // rAF\n    // based on Paul Irish code: http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n    var lastTime = 0,\n        vendors = ['webkit', 'moz'],\n        x = 0;\n\n    while(x < vendors.length && !scope.requestAnimationFrame) {\n      scope.requestAnimationFrame = scope[vendors[x]+'RequestAnimationFrame'];\n      scope.cancelAnimationFrame = scope[vendors[x]+'CancelAnimationFrame'] || scope[vendors[x]+'CancelRequestAnimationFrame'];\n      x++;\n    }\n\n    if (!scope.requestAnimationFrame)\n      scope.requestAnimationFrame = function(callback) {\n        var currTime = Date.now().getTime(),\n            timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n            id = scope.setTimeout(function() callback(currTime + timeToCall), timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n\n    if (!scope.cancelAnimationFrame)\n      scope.cancelAnimationFrame = function(id) scope.clearTimeout(id);\n\n    // performance.now /  High Resolution Timer\n    if(__js__(\"typeof\")(scope.performance) == \"undefined\")\n      scope.performance = {};\n\n    if(__js__(\"typeof\")(scope.performance.now) == \"undefined\") {\n      var nowOffset = Date.now().getTime();\n\n      if (scope.performance.timing && scope.performance.timing.navigationStart)\n        nowOffset = scope.performance.timing.navigationStart;\n\n      scope.performance.now = function now()\n        return Date.now() - nowOffset;\n    }\n  }\n#end\n}\n\n#if java\n@:nativeGen private class TimerTask extends java.util.TimerTask {\n  var callback : Void -> Void;\n  public function new(callback : Void -> Void) : Void {\n    super();\n    this.callback = callback;\n  }\n\n  @:overload override public function run()\n    callback();\n}\n#end","package thx;\n\n/**\n`Tuple0` is a tuple with no values. It maps directly to `Nil.nil`.\n**/\nabstract Tuple0(Nil) {\n/**\nConstructs an instance of `Tuple0`.\n**/\n  inline public function new()\n    this = nil;\n\n/**\nCreates a new Tuple with the addition of the extra value `v`. The Tuple\nof course increase in size by one.\n**/\n  inline public function with<T0>(v : T0)\n    return new Tuple1(v);\n\n/**\nProvides a string representation of the Tuple\n**/\n  inline public function toString()\n    return 'Tuple0()';\n\n/**\nCast to `Nil`.\n**/\n  @:to inline public function toNil()\n    return this;\n\n/**\nCreates `Tuple0` from `Nil`.\n**/\n  @:from inline static public function nilToTuple(v : Nil)\n    return new Tuple0();\n}\n\n/**\n`Tuple1` is a tuple with one value. It maps directly to its own T0 types.\n**/\nabstract Tuple1<T0>(T0) from T0 to T0 {\n/**\nConstructs an instance of `Tuple1` passing a value T as an argument.\n**/\n  inline public function new(_0 : T0)\n    this = _0;\n  public var _0(get, never) : T0;\n  inline function get__0() return this;\n\n/**\nCreates a new Tuple with the addition of the extra value `v`. The Tuple\nof course increase in size by one.\n**/\n  inline public function with<T1>(v : T1)\n    return new Tuple2(_0, v);\n\n/**\nProvides a string representation of the Tuple\n**/\n  inline public function toString()\n    return 'Tuple1(${this})';\n\n  @:from inline static public function arrayToTuple<T>(v : Array<T>)\n    return new Tuple1(v[0]);\n}\n\n/**\n`Tuple2` is a tuple with two values. It maps to an anonymous object with fields `_0` and `_1`.\n**/\n@:forward(_0, _1)\nabstract Tuple2<T0, T1>({ _0 : T0, _1 : T1 }) from { _0 : T0, _1 : T1 } to { _0 : T0, _1 : T1 } {\n/**\nConstructs an instance of `Tuple2` the 2 required value.\n**/\n  inline public function new(_0 : T0, _1 : T1)\n    this = { _0 : _0, _1 : _1 };\n\n/**\nAlias for `_0`.\n**/\n  public var left(get, never) : T0;\n\n/**\nAlias for `_1`.\n**/\n  public var right(get, never) : T1;\n\n  inline function get_left() return this._0;\n  inline function get_right() return this._1;\n\n/**\n`flip` returns a new Tuple with the values in reverse order.\n**/\n  inline public function flip() : Tuple2<T1, T0>\n    return { _0 : this._1, _1 : this._0 };\n\n/**\n`dropLeft` returns a new Tuple with one less element by dropping the first\non the left.\n**/\n  inline public function dropLeft()\n    return new Tuple1(this._1);\n\n/**\n`dropLeft` returns a new Tuple with one less element by dropping the last\non the right.\n**/\n  inline public function dropRight()\n    return new Tuple1(this._0);\n\n/**\nCreates a new Tuple with the addition of the extra value `v`. The Tuple\nof course increase in size by one.\n**/\n  inline public function with<T2>(v : T2)\n    return new Tuple3(this._0, this._1, v);\n\n/**\nProvides a string representation of the Tuple\n**/\n  inline public function toString()\n    return 'Tuple2(${this._0},${this._1})';\n\n  @:from inline static public function arrayToTuple2<T>(v : Array<T>) : Tuple2<T, T>\n    return new Tuple2(v[0], v[1]);\n}\n\n/**\n`Tuple3` is a tuple with three values. It maps to an anonymous object with fields `_0`, `_1`, and `_2`.\n**/\n@:forward(_0, _1, _2)\nabstract Tuple3<T0, T1, T2>({_0 : T0, _1 : T1, _2 : T2}) from {_0 : T0, _1 : T1, _2 : T2} to {_0 : T0, _1 : T1, _2 : T2} {\n/**\nConstructs an instance of `Tuple3` the 3 required value.\n**/\n  inline public function new(_0 : T0, _1 : T1, _2 : T2)\n    this = { _0 : _0, _1 : _1, _2 : _2 };\n\n/**\n`flip` returns a new Tuple with the values in reverse order.\n**/\n  inline public function flip() : Tuple3<T2, T1, T0>\n    return { _0 : this._2, _1 : this._1, _2 : this._0 };\n\n/**\n`dropLeft` returns a new Tuple with one less element by dropping the first\non the left.\n**/\n  inline public function dropLeft()\n    return new Tuple2(this._1, this._2);\n\n/**\n`dropLeft` returns a new Tuple with one less element by dropping the last\non the right.\n**/\n  inline public function dropRight()\n    return new Tuple2(this._0, this._1);\n\n/**\nCreates a new Tuple with the addition of the extra value `v`. The Tuple\nof course increase in size by one.\n**/\n  inline public function with<T3>(v : T3)\n    return new Tuple4(this._0, this._1, this._2, v);\n\n/**\nProvides a string representation of the Tuple\n**/\n  inline public function toString()\n    return 'Tuple3(${this._0},${this._1},${this._2})';\n\n  @:from inline static public function arrayToTuple3<T>(v : Array<T>) : Tuple3<T, T, T>\n    return new Tuple3(v[0], v[1], v[2]);\n}\n\n/**\n`Tuple4` is a tuple with four values. It maps to an anonymous object with fields `_0`, `_1`, `_2`, and `_3`.\n**/\n@:forward(_0, _1, _2, _3)\nabstract Tuple4<T0, T1, T2, T3>({ _0 : T0, _1 : T1, _2 : T2, _3 : T3}) from { _0 : T0, _1 : T1, _2 : T2, _3 : T3} to { _0 : T0, _1 : T1, _2 : T2, _3 : T3} {\n/**\nConstructs an instance of `Tuple4` the 4 required value.\n**/\n  inline public function new(_0 : T0, _1 : T1, _2 : T2, _3 : T3)\n    this = { _0 : _0, _1 : _1, _2 : _2, _3 : _3 };\n\n/**\n`flip` returns a new Tuple with the values in reverse order.\n**/\n  inline public function flip() : Tuple4<T3, T2, T1, T0>\n    return { _0 : this._3, _1 : this._2, _2 : this._1, _3 : this._0 };\n\n/**\n`dropLeft` returns a new Tuple with one less element by dropping the first\non the left.\n**/\n  inline public function dropLeft()\n    return new Tuple3(this._1, this._2, this._3);\n\n/**\n`dropLeft` returns a new Tuple with one less element by dropping the last\non the right.\n**/\n  inline public function dropRight()\n    return new Tuple3(this._0, this._1, this._2);\n\n/**\nCreates a new Tuple with the addition of the extra value `v`. The Tuple\nof course increase in size by one.\n**/\n  inline public function with<T4>(v : T4)\n    return new Tuple5(this._0, this._1, this._2, this._3, v);\n\n/**\nProvides a string representation of the Tuple\n**/\n  inline public function toString()\n    return 'Tuple4(${this._0},${this._1},${this._2},${this._3})';\n\n  @:from inline static public function arrayToTuple4<T>(v : Array<T>) : Tuple4<T, T, T, T>\n    return new Tuple4(v[0], v[1], v[2], v[3]);\n}\n\n/**\n`Tuple5` is a tuple with five values. It maps to an anonymous object with fields `_0`, `_1`, `_2`, `_4`, and `_5`.\n**/\n@:forward(_0, _1, _2, _3, _4)\nabstract Tuple5<T0, T1, T2, T3, T4>({ _0: T0, _1 : T1, _2 : T2, _3 : T3, _4 : T4}) from { _0: T0, _1 : T1, _2 : T2, _3 : T3, _4 : T4} to { _0: T0, _1 : T1, _2 : T2, _3 : T3, _4 : T4} {\n/**\nConstructs an instance of `Tuple5` the 5 required value.\n**/\n  inline public function new(_0 : T0, _1 : T1, _2 : T2, _3 : T3, _4 : T4)\n    this = { _0 : _0, _1 : _1, _2 : _2, _3 : _3, _4 : _4 };\n\n/**\n`flip` returns a new Tuple with the values in reverse order.\n**/\n  inline public function flip() : Tuple5<T4, T3, T2, T1, T0>\n    return { _0 : this._4, _1 : this._3, _2 : this._2, _3 : this._1, _4 : this._0 };\n\n/**\n`dropLeft` returns a new Tuple with one less element by dropping the first\non the left.\n**/\n  inline public function dropLeft()\n    return new Tuple4(this._1, this._2, this._3, this._4);\n\n/**\n`dropLeft` returns a new Tuple with one less element by dropping the last\non the right.\n**/\n  inline public function dropRight()\n    return new Tuple4(this._0, this._1, this._2, this._3);\n\n/**\nCreates a new Tuple with the addition of the extra value `v`. The Tuple\nof course increase in size by one.\n**/\n  inline public function with<T5>(v : T5)\n    return new Tuple6(this._0, this._1, this._2, this._3, this._4, v);\n\n/**\nProvides a string representation of the Tuple\n**/\n  inline public function toString()\n    return 'Tuple5(${this._0},${this._1},${this._2},${this._3},${this._4})';\n\n  @:from inline static public function arrayToTuple5<T>(v : Array<T>) : Tuple5<T, T, T, T, T>\n    return new Tuple5(v[0], v[1], v[2], v[3], v[4]);\n}\n\n/**\n`Tuple6` is a tuple with size values. It maps to an anonymous object with fields `_0`, `_1`, `_2`, `_4`, `_5`, and `_6`.\n**/\n@:forward(_0, _1, _2, _3, _4, _5)\nabstract Tuple6<T0, T1, T2, T3, T4, T5>({ _0 : T0, _1 : T1, _2 : T2, _3 : T3, _4 : T4, _5 : T5 }) from { _0 : T0, _1 : T1, _2 : T2, _3 : T3, _4 : T4, _5 : T5 } to { _0 : T0, _1 : T1, _2 : T2, _3 : T3, _4 : T4, _5 : T5 } {\n/**\nConstructs an instance of `Tuple6` the 6 required value.\n**/\n  inline public function new(_0 : T0, _1 : T1, _2 : T2, _3 : T3, _4 : T4, _5 : T5)\n    this = { _0 : _0, _1 : _1, _2 : _2, _3 : _3, _4 : _4, _5 : _5 };\n\n/**\n`flip` returns a new Tuple with the values in reverse order.\n**/\n  inline public function flip() : Tuple6<T5, T4, T3, T2, T1, T0>\n    return { _0 : this._5, _1 : this._4, _2 : this._3, _3 : this._2, _4 : this._1, _5 : this._0 };\n\n/**\n`dropLeft` returns a new Tuple with one less element by dropping the first\non the left.\n**/\n  inline public function dropLeft()\n    return new Tuple5(this._1, this._2, this._3, this._4, this._5);\n\n/**\n`dropLeft` returns a new Tuple with one less element by dropping the last\non the right.\n**/\n  inline public function dropRight()\n    return new Tuple5(this._0, this._1, this._2, this._3, this._4);\n\n/**\nProvides a string representation of the Tuple\n**/\n  inline public function toString()\n    return 'Tuple6(${this._0},${this._1},${this._2},${this._3},${this._4},${this._5})';\n\n  @:from inline static public function arrayToTuple6<T>(v : Array<T>) : Tuple6<T, T, T, T, T, T>\n    return new Tuple6(v[0], v[1], v[2], v[3], v[4], v[5]);\n}","package thx;\n\n/**\nHelper methods to use on values, types and classes.\n**/\nclass Types {\n/**\n`isAnonymousObject` returns true if `v` is an object and it is not an instance of any custom class.\n**/\n  public static inline function isAnonymousObject(v : Dynamic) : Bool\n    return Reflect.isObject(v) && null == Type.getClass(v);\n\n/**\nReturn `true` if v is any of the following types: Int, Float, Bool or String.\n**/\n  public static function isPrimitive(v : Dynamic)\n    return switch Type.typeof(v) {\n      case TInt, TFloat, TBool: true;\n      case TNull, TFunction, TEnum(_), TObject, TUnknown : false;\n      case TClass(c): Type.getClassName(c) == \"String\";\n    };\n\n/**\nReturns `true` if `cls` extends `sup` or one of its children.\n\nIt also returns `true` if `cls` and `sup` are the same.\n**/\n  public static function hasSuperClass(cls : Class<Dynamic>, sup : Class<Dynamic>) {\n    while(null != cls) {\n      if(cls == sup)\n        return true;\n      cls = Type.getSuperClass(cls);\n    }\n    return false;\n  }\n\n/**\n`sameType` returns true if the arguments `a` and `b` share exactly the same type.\n**/\n  public static function sameType<A, B>(a : A, b : B) : Bool\n    return valueTypeToString(a) == valueTypeToString(b);\n\n/**\n`typeInheritance` returns an array of string describing the entire inheritance\nchain of the passed `ValueType`.\n**/\n  public static function typeInheritance(type : Type.ValueType) : Array<String> {\n    return switch type {\n      case TInt:      [\"Int\"];\n      case TFloat:    [\"Float\"];\n      case TBool:     [\"Bool\"];\n      case TObject:   [\"{}\"];\n      case TFunction: [\"Function\"];\n      case TClass(c):\n        var classes = [];\n        while (null != c) {\n          classes.push(c);\n          c = Type.getSuperClass(c);\n        }\n        classes.map(Type.getClassName);\n      case TEnum(e):  [Type.getEnumName(e)];\n      case _:         throw 'invalid type $type';\n    }\n  }\n\n/**\nReturns a string representation of a `ValueType`.\n**/\n  public static function typeToString(type : Type.ValueType) {\n    return switch type {\n      case TNull:     \"Null\";\n      case TInt:      \"Int\";\n      case TFloat:    \"Float\";\n      case TBool:     \"Bool\";\n      case TObject:   \"{}\";\n      case TFunction: \"Function\";\n      case TClass(c): Type.getClassName(c);\n      case TEnum(e):  Type.getEnumName(e);\n      case _:         throw 'invalid type $type';\n    }\n  }\n\n/**\n`valueTypeInheritance` returns an array of string describing the entire inheritance\nchain of the passed `value`.\n**/\n  inline public static function valueTypeInheritance<T>(value : T) : Array<String>\n    return typeInheritance(Type.typeof(value));\n\n/**\nReturns a string describing the type of any `value`.\n**/\n  inline public static function valueTypeToString<T>(value : T)\n    return typeToString(Type.typeof(value));\n}","package thx;\n\n/**\nHelper class to generate [UUID](http://en.wikipedia.org/wiki/Universally_unique_identifier)\nstrings (version 4).\n**/\nclass Uuid {\n  static inline function random()\n    return Math.floor(Math.random()*0x10);\n\n  static inline function srandom()\n    return '${random()}';\n\n/**\n`Uuid.create()` returns a string value representing a UUID value.\n**/\n  public static function create() {\n    var s = [];\n    for(i in 0...8)\n      s[i] = srandom();\n    s[8]  = '-';\n    for(i in 9...13)\n      s[i] = srandom();\n    s[13] = '-';\n    s[14] = '4';\n    for(i in 15...18)\n      s[i] = srandom();\n    s[18] = '-';\n    s[19] = '' + ((random() & 0x3) | 0x8);\n    for(i in 20...23)\n      s[i] = srandom();\n    s[23] = '-';\n    for(i in 24...36)\n      s[i] = srandom();\n    return s.join('');\n  }\n}\n","package thx.error;\n\nimport haxe.PosInfos;\nimport haxe.CallStack;\n\nclass ErrorWrapper extends thx.Error {\n  public var innerError : Dynamic;\n  public function new(message : String, innerError : Dynamic, ?stack : Array<StackItem>, ?pos : PosInfos) {\n    super(message, stack, pos);\n\n    this.innerError = innerError;\n  }\n}\n","package thx.promise;\n\nimport haxe.ds.Option;\nusing thx.Arrays;\nimport thx.Error;\nimport thx.Nil;\nusing thx.Options;\nimport thx.Tuple;\n\nclass Future<T> {\n  public static function sequence(arr : Array<Future<Dynamic>>) : Future<Nil>\n    return Future.create(function(callback : Dynamic -> Void) {\n        function poll(_ : Dynamic) {\n          if(arr.length == 0) {\n            callback(nil);\n          } else {\n            arr.shift().then(poll);\n          }\n        }\n        poll(null);\n      });\n\n  public static function afterAll(arr : Array<Future<Dynamic>>) : Future<Nil>\n    return Future.create(function(callback)\n      all(arr).then(function(_) callback(Nil.nil)));\n\n  public static function all<T>(arr : Array<Future<T>>) : Future<Array<T>>\n    return Future.create(function(callback) {\n      var results = [],\n          counter = 0;\n      arr.mapi(function(p, i) {\n        p.then(function(value) {\n          results[i] = value;\n          counter++;\n          if(counter == arr.length)\n            callback(results);\n        });\n      });\n    });\n\n  public static function create<T>(handler : (T -> Void) -> Void) {\n    var future = new Future<T>();\n    handler(future.setState);\n    return future;\n  }\n\n  // inline makes Java behave .... groovy\n  inline public static function flatMap<T>(future : Future<Future<T>>) : Future<T>\n    return Future.create(function(callback) {\n      future.then(function(future) future.then(callback));\n    });\n\n  public static function value<T>(v : T)\n    return create(function(callback) callback(v));\n\n  var handlers : Array<T -> Void>;\n  public var state(default, null) : Option<T>;\n  private function new() {\n    handlers = [];\n    state = None;\n  }\n\n#if (js || flash || java)\n  inline public function delay(?delayms : Int) {\n    if(null == delayms)\n      return mapFuture(function(value) return Timer.immediateValue(value));\n    else\n      return mapFuture(function(value) return Timer.delayValue(value, delayms));\n  }\n#end\n\n  inline public function hasValue()\n    return state.toBool();\n\n  public function map<TOut>(handler : T -> TOut) : Future<TOut>\n    return Future.create(function(callback)\n      then(function(value)\n        callback(handler(value))));\n\n  public function mapAsync<TOut>(handler : T -> (TOut -> Void) -> Void) : Future<TOut>\n    return Future.create(function(callback)\n      then(function(result : T )\n        handler(result, callback)));\n\n  public function mapPromise<TOut>(handler : T -> Promise<TOut>) : Promise<TOut>\n    return Promise.create(function(resolve, reject)\n      then(function(result : T)\n        handler(result)\n          .success(resolve)\n          .failure(reject)));\n\n  inline public function mapFuture<TOut>(handler : T -> Future<TOut>) : Future<TOut>\n    return flatMap(map(handler));\n\n  public function then(handler : T -> Void) {\n    handlers.push(handler);\n    update();\n    return this;\n  }\n\n  public function toString() return 'Future';\n\n  function setState(newstate : T) {\n    switch state {\n      case None:\n        state = Some(newstate);\n      case Some(r):\n        throw new Error('future was already \"$r\", can\\'t apply the new state \"$newstate\"');\n    }\n    update();\n    return this;\n  }\n\n  function update()\n    switch state {\n      case None:\n      case Some(result): {\n        var index = -1;\n        while(++index < handlers.length)\n          handlers[index](result);\n        handlers = [];\n      }\n    };\n}\n\nclass Futures {\n  public static function join<T1,T2>(p1 : Future<T1>, p2 : Future<T2>) : Future<Tuple2<T1,T2>> {\n    return Future.create(function(callback) {\n      var counter = 0,\n          v1 : Null<T1> = null,\n          v2 : Null<T2> = null;\n\n      function complete() {\n        if(counter < 2)\n          return;\n        callback(new Tuple2(v1, v2));\n      }\n\n      p1.then(function(v) {\n        counter++;\n        v1 = v;\n        complete();\n      });\n\n      p2.then(function(v) {\n        counter++;\n        v2 = v;\n        complete();\n      });\n    });\n  }\n\n  public static function log<T>(future : Future<T>, ?prefix : String = '')\n    return future.then(\n      function(r) trace('$prefix VALUE: $r')\n    );\n}\n\nclass FutureTuple6 {\n  public static function mapTuple<T1,T2,T3,T4,T5,T6,TOut>(future : Future<Tuple6<T1,T2,T3,T4,T5,T6>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> TOut) : Future<TOut>\n    return future.map(function(t)\n      return callback(t._0, t._1, t._2, t._3, t._4, t._5)\n    );\n\n  public static function mapTupleAsync<T1,T2,T3,T4,T5,T6,TOut>(future : Future<Tuple6<T1,T2,T3,T4,T5,T6>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, t._2, t._3, t._4, t._5, cb));\n\n  public static function mapTupleFuture<T1,T2,T3,T4,T5,T6,TOut>(future : Future<Tuple6<T1,T2,T3,T4,T5,T6>>, callback : T1 -> T2 -> T3  -> T4 -> T5 -> T6 -> Future<TOut>) : Future<TOut>\n    return future.mapFuture(function(t) return callback(t._0, t._1, t._2, t._3, t._4, t._5));\n\n  public static function tuple<T1,T2,T3,T4,T5,T6>(future : Future<Tuple6<T1,T2,T3,T4,T5,T6>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> Void)\n    return future.then(function(t) callback(t._0, t._1, t._2, t._3, t._4, t._5));\n}\n\nclass FutureTuple5 {\n  public static function join<T1,T2,T3,T4,T5,T6>(p1 : Future<Tuple5<T1,T2,T3,T4,T5>>, p2 : Future<T6>) : Future<Tuple6<T1,T2,T3,T4,T5,T6>>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(\n          function(t) callback(t._0.with(t._1))));\n\n  public static function mapTuple<T1,T2,T3,T4,T5,TOut>(future : Future<Tuple5<T1,T2,T3,T4,T5>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> TOut) : Future<TOut>\n    return future.map(function(t)\n      return callback(t._0, t._1, t._2, t._3, t._4)\n    );\n\n  public static function mapTupleAsync<T1,T2,T3,T4,T5,TOut>(future : Future<Tuple5<T1,T2,T3,T4,T5>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, t._2, t._3, t._4, cb));\n\n  public static function mapTupleFuture<T1,T2,T3,T4,T5,TOut>(future : Future<Tuple5<T1,T2,T3,T4,T5>>, callback : T1 -> T2 -> T3  -> T4 -> T5 -> Future<TOut>) : Future<TOut>\n    return future.mapFuture(function(t) return callback(t._0, t._1, t._2, t._3, t._4));\n\n  public static function tuple<T1,T2,T3,T4,T5>(future : Future<Tuple5<T1,T2,T3,T4,T5>>, callback : T1 -> T2 -> T3 -> T4 -> T5 -> Void)\n    return future.then(function(t) callback(t._0, t._1, t._2, t._3, t._4));\n}\n\nclass FutureTuple4 {\n  public static function join<T1,T2,T3,T4,T5>(p1 : Future<Tuple4<T1,T2,T3,T4>>, p2 : Future<T5>) : Future<Tuple5<T1,T2,T3,T4,T5>>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(\n          function(t) callback(t._0.with(t._1))));\n\n  public static function mapTuple<T1,T2,T3,T4,TOut>(future : Future<Tuple4<T1,T2,T3,T4>>, callback : T1 -> T2 -> T3 -> T4 -> TOut) : Future<TOut>\n    return future.map(function(t)\n      return callback(t._0, t._1, t._2, t._3)\n    );\n\n  public static function mapTupleAsync<T1,T2,T3,T4,TOut>(future : Future<Tuple4<T1,T2,T3,T4>>, callback : T1 -> T2 -> T3 -> T4 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, t._2, t._3, cb));\n\n  public static function mapTupleFuture<T1,T2,T3,T4,TOut>(future : Future<Tuple4<T1,T2,T3,T4>>, callback : T1 -> T2 -> T3  -> T4 -> Future<TOut>) : Future<TOut>\n    return future.mapFuture(function(t) return callback(t._0, t._1, t._2, t._3));\n\n  public static function tuple<T1,T2,T3,T4>(future : Future<Tuple4<T1,T2,T3,T4>>, callback : T1 -> T2 -> T3 -> T4 -> Void)\n    return future.then(function(t) callback(t._0, t._1, t._2, t._3));\n}\n\nclass FutureTuple3 {\n  public static function join<T1,T2,T3,T4>(p1 : Future<Tuple3<T1,T2,T3>>, p2 : Future<T4>) : Future<Tuple4<T1,T2,T3,T4>>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(\n          function(t) callback(t._0.with(t._1))));\n\n  public static function mapTuple<T1,T2,T3,TOut>(future : Future<Tuple3<T1,T2,T3>>, callback : T1 -> T2 -> T3 -> TOut) : Future<TOut>\n    return future.map(function(t)\n      return callback(t._0, t._1, t._2)\n    );\n\n  public static function mapTupleAsync<T1,T2,T3,TOut>(future : Future<Tuple3<T1,T2,T3>>, callback : T1 -> T2 -> T3 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, t._2, cb));\n\n  public static function mapTupleFuture<T1,T2,T3,TOut>(future : Future<Tuple3<T1,T2,T3>>, callback : T1 -> T2 -> T3  -> Future<TOut>) : Future<TOut>\n    return future.mapFuture(function(t) return callback(t._0, t._1, t._2));\n\n  public static function tuple<T1,T2,T3>(future : Future<Tuple3<T1,T2,T3>>, callback : T1 -> T2 -> T3 -> Void)\n    return future.then(function(t) callback(t._0, t._1, t._2));\n}\n\nclass FutureTuple2 {\n  public static function join<T1,T2,T3>(p1 : Future<Tuple2<T1,T2>>, p2 : Future<T3>) : Future<Tuple3<T1,T2,T3>>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(function(t) callback(t._0.with(t._1))));\n\n  public static function mapTuple<T1,T2,TOut>(future : Future<Tuple2<T1,T2>>, callback : T1 -> T2 -> TOut) : Future<TOut>\n    return future.map(function(t) return callback(t._0, t._1));\n\n  public static function mapTupleAsync<T1,T2,TOut>(future : Future<Tuple2<T1,T2>>, callback : T1 -> T2 -> (TOut -> Void) -> Void) : Future<TOut>\n    return future.mapAsync(function(t, cb) return callback(t._0, t._1, cb));\n\n  public static function mapTupleFuture<T1,T2,TOut>(future : Future<Tuple2<T1,T2>>, callback : T1 -> T2 -> Future<TOut>) : Future<TOut>\n    return future.mapFuture(function(t) return callback(t._0, t._1));\n\n  public static function tuple<T1,T2>(future : Future<Tuple2<T1,T2>>, callback : T1 -> T2 -> Void)\n    return future.then(function(t) callback(t._0, t._1));\n}\n\nclass FutureNil {\n  public static function join<T2>(p1 : Future<Nil>, p2 : Future<T2>) : Future<T2>\n    return Future.create(function(callback)\n      Futures.join(p1, p2)\n        .then(function(t) callback(t._1)));\n\n  public static function nil(p : Future<Dynamic>) : Future<Nil>\n    return Future.create(function(callback : Nil -> Void)\n      p.then(function(_) callback(Nil.nil)));\n}","package thx.promise;\n\nimport haxe.ds.Option;\nimport thx.Error;\nimport thx.Tuple;\nimport thx.Nil;\nusing thx.Options;\nusing thx.Arrays;\nimport thx.Result;\nimport thx.Either;\n\ntypedef PromiseValue<T> = Result<T, Error>;\n\n@:forward(hasValue, map, mapAsync, mapFuture, state, then)\nabstract Promise<T>(Future<Result<T, Error>>) from Future<Result<T, Error>> to Future<Result<T, Error>> {\n  @:from public static function futureToPromise<T>(future : Future<T>) : Promise<T>\n    return future.map(function(v) return (Right(v) : PromiseValue<T>));\n\n  public static var nil(default, null) : Promise<Nil> = Promise.value(Nil.nil);\n\n  public static function sequence(arr : Array<Promise<Dynamic>>) : Promise<Nil>\n    return Promise.create(function(resolve : Dynamic -> Void, reject) {\n        function poll(_ : Dynamic) {\n          if(arr.length == 0) {\n            resolve(nil);\n          } else {\n            arr.shift()\n              .mapSuccess(poll)\n              .mapFailure(reject);\n          }\n        }\n        poll(null);\n      });\n\n  public static function afterAll(arr : Array<Promise<Dynamic>>) : Promise<Nil>\n    return Promise.create(function(resolve, reject) {\n      all(arr).either(\n        function(_) resolve(Nil.nil),\n        reject\n      );\n    });\n\n  public static function all<T>(arr : Array<Promise<T>>) : Promise<Array<T>> {\n    if(arr.length == 0)\n      return Promise.value([]);\n    return Promise.create(function(resolve, reject) {\n      var results  = [],\n          counter  = 0,\n          hasError = false;\n      arr.mapi(function(p, i) {\n        p.either(function(value) {\n          if(hasError) return;\n          results[i] = value;\n          counter++;\n          if(counter == arr.length)\n            resolve(results);\n        }, function(err) {\n          if(hasError) return;\n          hasError = true;\n          reject(err);\n        });\n      });\n    });\n  }\n\n  public static function create<T>(callback : (T -> Void) -> (Error -> Void) -> Void) : Promise<T>\n    return Future.create(function(cb : PromiseValue<T> -> Void) {\n      callback(\n        function(value : T) cb((Right(value) : Result<T, Error>)),\n        // cast required by C#\n        function(error : Error) cb((Left(error) : Result<T, Error>))\n      );\n    });\n\n  public static function createFulfill<T>(callback : (PromiseValue<T> -> Void) -> Void) : Promise<T>\n    return Future.create(callback);\n\n  public static function error<T>(err : Error) : Promise<T>\n    return Promise.create(function(_, reject) reject(err));\n\n  public static function value<T>(v : T) : Promise<T>\n    return Promise.create(function(resolve, _) resolve(v));\n\n  public function always(handler : Void -> Void)\n    this.then(function(_) handler());\n\n  public function either(success : T -> Void, failure : Error -> Void) : Promise<T> {\n    this.then(function(r) switch r {\n      case Right(value): success(value);\n      case Left(error): failure(error);\n    });\n    return this;\n  }\n\n#if (js || flash || java)\n  public function delay(?delayms : Int) : Promise<T>\n    return this.delay(delayms);\n#end\n\n  public function isFailure() : Bool\n    return switch this.state {\n      case None, Some(Right(_)): false;\n      case _: true;\n    };\n\n  public function isResolved() : Bool\n    return switch this.state {\n      case None, Some(Left(_)): false;\n      case _: true;\n    };\n\n  public function failure(failure : Error -> Void) : Promise<T>\n    return either(function(_){}, failure);\n\n  inline public function mapAlways<TOut>(handler : Void -> TOut) : Future<TOut>\n    return this.map(function(_) return handler());\n\n  inline public function mapAlwaysAsync<TOut>(handler : (TOut -> Void) -> Void) : Future<TOut>\n    return this.mapAsync(function(_, cb) return handler(cb));\n\n  inline public function mapAlwaysFuture<TOut>(handler : Void -> Future<TOut>) : Future<TOut>\n    return this.mapFuture(function(_) return handler());\n\n  public function mapEither<TOut>(success : T -> TOut, failure : Error -> TOut) : Future<TOut>\n    return this.map(function(result)\n      return switch result {\n        case Right(value): success(value);\n        case Left(error):  failure(error);\n      });\n\n  public function mapEitherFuture<TOut>(success : T -> Future<TOut>, failure : Error -> Future<TOut>) : Future<TOut>\n    return this.mapFuture(function(result)\n      return switch result {\n        case Right(value): success(value);\n        case Left(error):  failure(error);\n      });\n\n  public function mapFailure(failure : Error -> T) : Future<T>\n    return mapEither(function(value : T) return value, failure);\n\n  public function mapFailureFuture(failure : Error -> Future<T>) : Future<T>\n    return mapEitherFuture(function(value : T) return Future.value(value), failure);\n\n  public function mapFailurePromise(failure : Error -> Promise<T>) : Promise<T>\n    return mapEitherFuture(function(value) return Promise.value(value), failure);\n\n  public function mapSuccess<TOut>(success : T -> TOut) : Promise<TOut>\n    return mapEitherFuture(\n      function(v)   return Promise.value(success(v)),\n      function(err) return Promise.error(err));\n\n  public function mapSuccessPromise<TOut>(success : T -> Promise<TOut>) : Promise<TOut>\n    return mapEitherFuture(success, function(err) return Promise.error(err));\n\n  public function success(success : T -> Void) : Promise<T>\n    return either(success, function(_){});\n\n  public function throwFailure() : Promise<T>\n    return failure(function(err) throw err);\n\n  public function toString() return 'Promise';\n}\n\nclass Promises {\n  public static function join<T1,T2>(p1 : Promise<T1>, p2 : Promise<T2>) : Promise<Tuple2<T1,T2>> {\n    return Promise.create(function(resolve, reject) {\n      var hasError = false,\n          counter = 0,\n          v1 : Null<T1> = null,\n          v2 : Null<T2> = null;\n\n      function complete() {\n        if(counter < 2)\n          return;\n        resolve(new Tuple2(v1, v2));\n      }\n\n      function handleError(error) {\n        if(hasError) return;\n        hasError = true;\n        reject(error);\n      }\n\n      p1.either(function(v) {\n        if(hasError) return;\n        counter++;\n        v1 = v;\n        complete();\n      }, handleError);\n\n      p2.either(function(v) {\n        if(hasError) return;\n        counter++;\n        v2 = v;\n        complete();\n      }, handleError);\n    });\n  }\n\n  public static function log<T>(promise : Promise<T>, ?prefix : String = '')\n    return promise.either(\n      function(r) trace('$prefix SUCCESS: $r'),\n      function(e) trace('$prefix ERROR: ${e.toString()}')\n    );\n}\n\nclass PromiseTuple6 {\n  public static function mapTuplePromise<T1,T2,T3,T4,T5,T6,TOut>(promise : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> Promise<TOut>) : Promise<TOut>\n    return promise.mapSuccessPromise(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4, t._5)\n    );\n\n  public static function mapTuple<T1,T2,T3,T4,T5,T6,TOut>(promise : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> TOut) : Promise<TOut>\n    return promise.mapSuccess(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4, t._5)\n    );\n\n  public static function tuple<T1,T2,T3,T4,T5,T6>(promise : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2, t._3, t._4, t._5),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple5 {\n  public static function join<T1,T2,T3,T4,T5,T6>(p1 : Promise<Tuple5<T1,T2,T3,T4,T5>>, p2 : Promise<T6>) : Promise<Tuple6<T1,T2,T3,T4,T5,T6>> {\n    return Promise.create(function(resolve, reject) {\n      Promises.join(p1, p2)\n        .either(\n          function(t) resolve(t._0.with(t._1)),\n          function(e) reject(e));\n    });\n  }\n\n  public static function mapTuplePromise<T1,T2,T3,T4,T5,TOut>(promise : Promise<Tuple5<T1,T2,T3,T4,T5>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> Promise<TOut>) : Promise<TOut>\n    return promise.mapSuccessPromise(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4)\n    );\n\n  public static function mapTuple<T1,T2,T3,T4,T5,TOut>(promise : Promise<Tuple5<T1,T2,T3,T4,T5>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> TOut) : Promise<TOut>\n    return promise.mapSuccess(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4)\n    );\n\n  public static function tuple<T1,T2,T3,T4,T5>(promise : Promise<Tuple5<T1,T2,T3,T4,T5>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2, t._3, t._4),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple4 {\n  public static function join<T1,T2,T3,T4,T5>(p1 : Promise<Tuple4<T1,T2,T3,T4>>, p2 : Promise<T5>) : Promise<Tuple5<T1,T2,T3,T4,T5>> {\n    return Promise.create(function(resolve, reject) {\n      Promises.join(p1, p2)\n        .either(\n          function(t) resolve(t._0.with(t._1)),\n          function(e) reject(e));\n    });\n  }\n\n  public static function mapTuplePromise<T1,T2,T3,T4,TOut>(promise : Promise<Tuple4<T1,T2,T3,T4>>, success : T1 -> T2 -> T3 -> T4 -> Promise<TOut>) : Promise<TOut>\n    return promise.mapSuccessPromise(function(t)\n      return success(t._0, t._1, t._2, t._3)\n    );\n\n  public static function mapTuple<T1,T2,T3,T4,TOut>(promise : Promise<Tuple4<T1,T2,T3,T4>>, success : T1 -> T2 -> T3 -> T4 -> TOut) : Promise<TOut>\n    return promise.mapSuccess(function(t)\n      return success(t._0, t._1, t._2, t._3)\n    );\n\n  public static function tuple<T1,T2,T3,T4>(promise : Promise<Tuple4<T1,T2,T3,T4>>, success : T1 -> T2 -> T3 -> T4 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2, t._3),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple3 {\n  public static function join<T1,T2,T3,T4>(p1 : Promise<Tuple3<T1,T2,T3>>, p2 : Promise<T4>) : Promise<Tuple4<T1,T2,T3,T4>> {\n    return Promise.create(function(resolve, reject) {\n      Promises.join(p1, p2)\n        .either(\n          function(t) resolve(t._0.with(t._1)),\n          function(e) reject(e));\n    });\n  }\n\n  public static function mapTuplePromise<T1,T2,T3,TOut>(promise : Promise<Tuple3<T1,T2,T3>>, success : T1 -> T2 -> T3 -> Promise<TOut>) : Promise<TOut>\n    return promise.mapSuccessPromise(function(t)\n      return success(t._0, t._1, t._2)\n    );\n\n  public static function mapTuple<T1,T2,T3,TOut>(promise : Promise<Tuple3<T1,T2,T3>>, success : T1 -> T2 -> T3 -> TOut) : Promise<TOut>\n    return promise.mapSuccess(function(t)\n      return success(t._0, t._1, t._2)\n    );\n\n  public static function tuple<T1,T2,T3>(promise : Promise<Tuple3<T1,T2,T3>>, success : T1 -> T2 -> T3 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple2 {\n  public static function join<T1,T2,T3>(p1 : Promise<Tuple2<T1,T2>>, p2 : Promise<T3>) : Promise<Tuple3<T1,T2,T3>> {\n    return Promise.create(function(resolve, reject) {\n      Promises.join(p1, p2)\n        .either(\n          function(t) resolve(t._0.with(t._1)),\n          function(e) reject(e));\n    });\n  }\n\n  public static function mapTuplePromise<T1,T2,TOut>(promise : Promise<Tuple2<T1,T2>>, success : T1 -> T2 -> Promise<TOut>) : Promise<TOut>\n    return promise.mapSuccessPromise(function(t)\n      return success(t._0, t._1)\n    );\n\n  public static function mapTuple<T1,T2,TOut>(promise : Promise<Tuple2<T1,T2>>, success : T1 -> T2 -> TOut) : Promise<TOut>\n    return promise.mapSuccess(function(t)\n      return success(t._0, t._1)\n    );\n\n  public static function tuple<T1,T2>(promise : Promise<Tuple2<T1,T2>>, success : T1 -> T2 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseNil {\n  public static function join<T2>(p1 : Promise<Nil>, p2 : Promise<T2>) : Promise<T2>\n    return Promise.create(function(resolve, reject) {\n      Promises.join(p1, p2)\n        .either(\n          function(t) resolve(t._1),\n          function(e) reject(e));\n    });\n\n  public static function nil(p : Promise<Dynamic>) : Promise<Nil>\n    return Promise.create(function(resolve : Nil -> Void, reject)\n      p.success(function(_) resolve(Nil.nil))\n       .failure(reject));\n}\n\n#if js\nclass PromiseAPlus {\n  public static function promise<T>(p : js.Promise<T>) : Promise<T>\n    return Promise.create(function(resolve, reject) {\n      p.then(resolve, function(e) reject(Error.fromDynamic(e)));\n    });\n\n  public static function aPlus<T>(p : Promise<T>) : js.Promise<T>\n    return new js.Promise(function(resolve, reject) {\n        p.success(resolve).failure(reject);\n      });\n}\n\nclass PromiseAPlusVoid {\n  public static function promise(p : js.Promise<Void>) : Promise<Nil>\n    return Promise.create(function(resolve, reject) {\n      p.then(cast function() resolve(nil), function(e) reject(Error.fromDynamic(e)));\n    });\n\n  public static function aPlus(p : Promise<Void>) : js.Promise<Nil>\n    return new js.Promise(function(resolve, reject) {\n        p.success(cast function() resolve(nil)).failure(reject);\n      });\n}\n#end\n","package thx.promise;\n\nimport thx.Nil;\n\nclass Timer {\n  public static function delay(delayms : Int) : Future<Nil>\n    return delayValue(nil, delayms);\n\n  public static function delayValue<T>(value : T, delayms : Int) : Future<T>\n    return Future.create(function(callback : T -> Void)\n      thx.Timer.delay(callback.bind(value), delayms));\n\n  public static function immediate() : Future<Nil>\n    return immediateValue(nil);\n\n  public static function immediateValue<T>(value : T) : Future<T>\n    return Future.create(function(callback : T -> Void)\n      thx.Timer.immediate(callback.bind(value)));\n}","package thx.stream;\n\nimport haxe.ds.Option;\nusing thx.Arrays;\nimport thx.Nil;\nusing thx.Options;\nusing thx.Tuple;\nimport thx.promise.Future;\n\nclass Emitter<T> {\n  var init : Stream<T> -> Void;\n  public function new(init : Stream<T> -> Void)\n    this.init = init;\n\n  // TRIGGER METHODS\n  @:access(thx.stream.Value)\n  @:access(thx.stream.Stream)\n  public function feed(value : Value<T>) : IStream {\n    var stream : Stream<T> = new Stream(null);\n    stream.subscriber = function(r) switch r {\n      case Pulse(v): value.set(v);\n      case End(c): if(c) stream.cancel() else stream.end();\n    };\n    value.upStreams.push(stream);\n    stream.addCleanUp(function() value.upStreams.remove(stream));\n    init(stream);\n    return stream;\n  }\n\n  @:access(thx.stream.Bus)\n  @:access(thx.stream.Stream)\n  public function plug(bus : Bus<T>) : IStream {\n    var stream : Stream<T> = new Stream(null);\n    stream.subscriber = bus.emit;\n    bus.upStreams.push(stream);\n    stream.addCleanUp(function() bus.upStreams.remove(stream));\n    init(stream);\n    return stream;\n  }\n\n  public function sign(subscriber : StreamValue<T> -> Void) : IStream {\n    var stream = new Stream(subscriber);\n    init(stream);\n    return stream;\n  }\n\n  public function subscribe(?pulse : T -> Void, ?end : Bool -> Void) : IStream {\n    pulse = null != pulse ? pulse : function(_) {};\n    end   = null != end   ? end   : function(_) {};\n    var stream = new Stream(function(r) switch r {\n      case Pulse(v):   pulse(v);\n      case End(c):     end(c);\n    });\n    init(stream);\n    return stream;\n  }\n\n  // TRANSFORM STREAM\n  public function concat(other : Emitter<T>) : Emitter<T>\n    return new Emitter(function(stream) {\n      init(new Stream(function(r) switch r {\n        case Pulse(v):    stream.pulse(v);\n        case End(true):   stream.cancel();\n        case End(false):  other.init(stream);\n      }));\n    });\n\n  public function count()\n    return map((function(){\n        var c = 0;\n        return function(_) return ++c;\n      })());\n#if (js || swf || java)\n  public function debounce(delay : Int)\n    return new Emitter(function(stream) {\n      var cancel = function() {};\n      stream.addCleanUp(function() cancel());\n      init(new Stream(function(r : StreamValue<T>) {\n        switch r {\n          case Pulse(v):\n            cancel();\n            cancel = thx.Timer.delay(stream.pulse.bind(v), delay);\n          case End(true):  stream.cancel();\n          case End(false): thx.Timer.delay(stream.end, delay);\n        }\n      }));\n    });\n\n  public function delay(time : Int)\n    return new Emitter(function(stream) {\n      var cancel = thx.Timer.delay(function() init(stream), time);\n      stream.addCleanUp(cancel);\n    });\n#end\n\n  public function diff<TOut>(?init : Null<T>, f : T -> T -> TOut) : Emitter<TOut>\n    return window(2, null != init).map(function(a) {\n        return if(a.length == 1)\n          f(init, a[0]);\n        else\n          f(a[0], a[1]);\n      });\n\n  public function merge(other : Emitter<T>) : Emitter<T>\n    return new Emitter(function(stream : Stream<T>) {\n      init(stream);\n      other.init(stream);\n    });\n\n  public function previous() : Emitter<T>\n    return new Emitter(function(stream : Stream<T>) {\n      var value : Null<T> = null,\n          first = true;\n      function pulse() {\n        if(first) {\n          first = false;\n          return;\n        }\n        stream.pulse(value);\n      }\n\n      init(new Stream(function(r) switch r {\n        case Pulse(v):\n          pulse();\n          value = v;\n        case End(true):   stream.cancel();\n        case End(false):  stream.end();\n      }));\n    });\n\n  public function reduce<TOut>(acc : TOut, f : TOut -> T -> TOut) : Emitter<TOut>\n    return new Emitter(function(stream) {\n      init(new Stream(function(r) switch r {\n        case Pulse(v):\n          acc = f(acc, v);\n          stream.pulse(acc);\n        case End(true):   stream.cancel();\n        case End(false):  stream.end();\n      }));\n    });\n\n  public function window(size : Int, ?emitWithLess = false) : Emitter<Array<T>>\n    return new Emitter(function(stream) {\n      var buf = [];\n      function pulse() {\n        if(buf.length > size)\n          buf.shift();\n        if(buf.length == size || emitWithLess)\n          stream.pulse(buf.copy());\n      }\n\n      init(new Stream(function(r) switch r {\n        case Pulse(v):\n          buf.push(v);\n          pulse();\n        case End(true):   stream.cancel();\n        case End(false):  stream.end();\n      }));\n    });\n\n\n  // TRANSFORM VALUES\n  public function map<TOut>(f : T -> TOut) : Emitter<TOut>\n    return mapFuture(function(v) return Future.value(f(v)));\n\n  public function mapFuture<TOut>(f : T -> Future<TOut>) : Emitter<TOut>\n    return new Emitter(function(stream)\n      init(new Stream(function(r) switch r {\n        case Pulse(v):   f(v).then(stream.pulse);\n        case End(true):  stream.cancel();\n        case End(false): stream.end();\n      })));\n\n  macro public function pluck<T>(emitter : haxe.macro.Expr.ExprOf<Emitter<T>>, expr : haxe.macro.Expr)\n    return macro $e{emitter}.map(function(_) return ${expr});\n\n  public function toOption() : Emitter<Option<T>>\n    return map(function(v) return null == v ? None : Some(v));\n  public function toNil() : Emitter<Nil>\n    return map(function(_) return nil);\n  public function toTrue() : Emitter<Bool>\n    return map(function(_) return true);\n  public function toFalse() : Emitter<Bool>\n    return map(function(_) return false);\n  public function toValue<T>(value : T) : Emitter<T>\n    return map(function(_) return value);\n\n  // FILTER STREAM\n  public function filter(f : T -> Bool) : Emitter<T>\n    return filterFuture(function(v) return Future.value(f(v)));\n\n  public function filterFuture(f : T -> Future<Bool>) : Emitter<T>\n    return new Emitter(function(stream) {\n      init(new Stream(function(r) switch r {\n        case Pulse(v):   f(v).then(function(c) if(c) stream.pulse(v));\n        case End(true):  stream.cancel();\n        case End(false): stream.end();\n      }));\n    });\n\n  macro public function filterPluck<T>(emitter : haxe.macro.Expr.ExprOf<Emitter<T>>, expr : haxe.macro.Expr)\n    return macro $e{emitter}.filter(function(_) return $e{expr});\n\n  public function first()\n    return take(1);\n\n  public function distinct(?equals : T -> T -> Bool) : Emitter<T> {\n    if(null == equals)\n        equals = function(a, b) return a == b;\n      var last : T = null;\n    return filter(function(v) {\n      return if(equals(v, last))\n        false;\n      else {\n        last = v;\n        true;\n      }\n    });\n  }\n\n  public function last()\n    return new Emitter(function(stream) {\n      var last : Null<T> = null;\n      init(new Stream(function(r) {\n        switch r {\n        case Pulse(v):   last = v;\n        case End(true):  stream.cancel();\n        case End(false):\n          stream.pulse(last);\n          stream.end();\n      }}));\n    });\n\n  public function memberOf(arr : Array<T>, ?equality : T -> T -> Bool)\n    return filter(function(v) return arr.contains(v, equality));\n\n  public function notNull()\n    return filter(function(v) return v != null);\n\n  public function skip(n : Int)\n    return skipUntil((function() {\n      var count = 0;\n      return function(_) return count++ < n;\n    })());\n\n  public function skipUntil(predicate : T -> Bool)\n    return filter((function() {\n      var flag = false;\n      return function(v) {\n        if(flag)\n          return true;\n        if(predicate(v))\n          return false;\n        return flag = true;\n      };\n    }()));\n\n  public function take(count : Int) : Emitter<T>\n    return takeUntil((function(counter : Int) : T -> Bool {\n        return function(_ : T) : Bool return counter++ < count;\n      })(0));\n\n  public function takeAt(index : Int) : Emitter<T>\n    // cast is required by C#\n    return cast take(index + 1).last();\n\n  public function takeLast(n : Int) : Emitter<T>\n    return EmitterArrays.flatten(window(n).last());\n\n  // TODO: ... have a look at those nasty instream\n  public function takeUntil(f : T -> Bool) : Emitter<T>\n    return new Emitter(function(stream : Stream<T>) {\n      var instream : Stream<T> = null;\n      instream = new Stream(function(r : StreamValue<T>) switch r {\n        case Pulse(v):\n          if(f(v)) {\n              stream.pulse(v);\n          } else {\n            instream.end();\n            stream.end();\n          }\n        case End(true):\n          instream.cancel();\n          stream.cancel();\n        case End(false):\n          instream.end();\n          stream.end();\n      });\n      this.init(instream);\n    });\n  public function withValue(expected : T) : Emitter<T>\n    return filter(function(v : T) return v == expected);\n\n  // AGGREGATE\n  public function pair<TOther>(other : Emitter<TOther>) : Emitter<Tuple2<T, TOther>>\n    return new Emitter(function(stream) {\n      var _0 : Null<T> = null,\n          _1 : Null<TOther> = null;\n      stream.addCleanUp(function() {\n        _0 = null;\n        _1 = null;\n      });\n      function pulse() {\n        if(null == _0 || null == _1)\n          return;\n        stream.pulse(new Tuple2(_0, _1));\n      }\n      init(new Stream(function(r) switch r {\n        case Pulse(v):\n          _0 = v;\n          pulse();\n        case End(true):   stream.cancel();\n        case End(false):  stream.end();\n      }));\n      other.init(new Stream(function(r) switch r {\n        case Pulse(v):\n          _1 = v;\n          pulse();\n        case End(true):   stream.cancel();\n        case End(false):  stream.end();\n      }));\n    });\n\n  // throttle(wait) at most once every per wait use sampleBy(Timer.repeat(Nil, wait)).left()\n  public function sampleBy<TOther>(sampler : Emitter<TOther>) : Emitter<Tuple2<T, TOther>>\n    return new Emitter(function(stream) {\n      var _0 : Null<T> = null,\n          _1 : Null<TOther> = null;\n      stream.addCleanUp(function() {\n        _0 = null;\n        _1 = null;\n      });\n      function pulse() {\n        if(null == _0 || null == _1)\n          return;\n        stream.pulse(new Tuple2(_0, _1));\n      }\n      init(new Stream(function(r) switch r {\n        case Pulse(v):\n          _0 = v;\n        case End(true):   stream.cancel();\n        case End(false):  stream.end();\n      }));\n      sampler.init(new Stream(function(r) switch r {\n        case Pulse(v):\n          _1 = v;\n          pulse();\n        case End(true):   stream.cancel();\n        case End(false):  stream.end();\n      }));\n    });\n\n  public function samplerOf<TOther>(sampled : Emitter<TOther>) : Emitter<Tuple2<T, TOther>>\n    return sampled.sampleBy(this).map(function(t) return t.flip());\n\n  public function zip<TOther>(other : Emitter<TOther>) : Emitter<Tuple2<T, TOther>>\n    return new Emitter(function(stream) {\n      var _0 : Array<T> = [],\n          _1 : Array<TOther> = [];\n      stream.addCleanUp(function() {\n        _0 = null;\n        _1 = null;\n      });\n      function pulse() {\n        if(_0.length == 0 || _1.length == 0)\n          return;\n        stream.pulse(new Tuple2(_0.shift(), _1.shift()));\n      }\n      init(new Stream(function(r) switch r {\n        case Pulse(v):\n          _0.push(v);\n          pulse();\n        case End(true):   stream.cancel();\n        case End(false):  stream.end();\n      }));\n      other.init(new Stream(function(r) switch r {\n        case Pulse(v):\n          _1.push(v);\n          pulse();\n        case End(true):   stream.cancel();\n        case End(false):  stream.end();\n      }));\n    });\n\n  // UTILITY\n  public function audit(handler : T -> Void) : Emitter<T>\n    return map(function(v) {\n      handler(v);\n      return v;\n    });\n\n  public function log(?prefix : String, ?posInfo : haxe.PosInfos) {\n    prefix = prefix == null ? '': '${prefix}: ';\n    return map(function(v) {\n      haxe.Log.trace('$prefix$v', posInfo);\n      return v;\n    });\n  }\n\n#if (js || swf || java)\n  public function split() : Tuple2<Emitter<T>, Emitter<T>> {\n    var inited  = false,\n        streams = [];\n    function init(stream) {\n      streams.push(stream);\n      if(!inited) {\n        inited = true;\n        // the delay ensures that the second stream has the time to be implemented\n        thx.Timer.immediate(function() {\n          this.init(new Stream(function(r) {\n            switch r {\n              case Pulse(v):   for(s in streams) s.pulse(v);\n              case End(true):  for(s in streams) s.cancel();\n              case End(false): for(s in streams) s.end();\n            };\n          }));\n        });\n      }\n    }\n    return new Tuple2(new Emitter(init), new Emitter(init));\n  }\n#end\n}\n\nclass Emitters {\n  public static function skipNull<T>(emitter : Emitter<Null<T>>) : Emitter<T>\n    // cast is required by C#\n    return cast emitter\n      .filter(function(value) return null != value);\n\n  public static function unique<T>(emitter : Emitter<T>) : Emitter<T>\n    return emitter.filter((function() {\n      var buf = [];\n      return function(v) {\n        return if(buf.indexOf(v) >= 0)\n          false;\n        else {\n          buf.push(v);\n          true;\n        }\n      };\n    })());\n}\n\nclass EmitterStrings {\n  public static function match(emitter : Emitter<String>, pattern : EReg) : Emitter<String>\n    return emitter.filter(function(s) return pattern.match(s));\n\n  public static function toBool(emitter : Emitter<String>) : Emitter<Bool>\n    return emitter.map(function(s) return s != null && s != \"\");\n\n  public static function truthy(emitter : Emitter<String>) : Emitter<String>\n    return emitter.filter(function(s) return s != null && s != \"\");\n\n  public static function unique(emitter : Emitter<String>) : Emitter<String>\n    return emitter.filter((function() {\n      var buf = new Map<String, Bool>();\n      return function(v) {\n        return if(buf.exists(v))\n          false;\n        else {\n          buf.set(v, true);\n          true;\n        }\n      };\n    })());\n}\n\nclass EmitterInts {\n  public static function average(emitter : Emitter<Int>) : Emitter<Float>\n    return emitter\n      .map((function(){\n        var sum = 0.0,\n            count = 0;\n        return function(v) return (sum += v) / (++count);\n      })());\n\n  public static function greaterThan(emitter : Emitter<Int>, x : Int) : Emitter<Int>\n    return emitter.filter(function(v) return v > x);\n\n  public static function greaterThanOrEqualTo(emitter : Emitter<Int>, x : Int) : Emitter<Int>\n    return emitter.filter(function(v) return v >= x);\n\n  public static function inRange(emitter : Emitter<Int>, min : Int, max : Int) : Emitter<Int>\n    return emitter.filter(function(v) return v <= max && v >= min);\n\n  public static function insideRange(emitter : Emitter<Int>, min : Int, max : Int) : Emitter<Int>\n    return emitter.filter(function(v) return v < max && v > min);\n\n  public static function lessThan(emitter : Emitter<Int>, x : Int) : Emitter<Int>\n    return emitter.filter(function(v) return v < x);\n\n  public static function lessThanOrEqualTo(emitter : Emitter<Int>, x : Int) : Emitter<Int>\n    return emitter.filter(function(v) return v <= x);\n\n  public static function max(emitter : Emitter<Int>) : Emitter<Int>\n    return emitter\n      .filter((function() {\n        var max : Null<Int> = null;\n        return function(v)\n          return if(null == max || v > max) {\n            max = v;\n            true;\n          } else {\n            false;\n          }\n        })());\n\n  public static function min(emitter : Emitter<Int>) : Emitter<Int>\n    return emitter\n      .filter((function() {\n        var min : Null<Int> = null;\n        return function(v)\n          return if(null == min || v < min) {\n            min = v;\n            true;\n          } else {\n            false;\n          }\n        })());\n\n  public static function sum(emitter : Emitter<Int>) : Emitter<Int>\n    return emitter\n      .map((function(){\n        var value = 0;\n        return function(v) return value += v;\n      })());\n\n  public static function toBool(emitter : Emitter<Int>) : Emitter<Bool>\n    return emitter\n      .map(function(i) return i != 0);\n\n  public static function unique(emitter : Emitter<Int>) : Emitter<Int>\n    return emitter.filter((function() {\n      var buf = new Map<Int, Bool>();\n      return function(v) {\n        return if(buf.exists(v))\n          false;\n        else {\n          buf.set(v, true);\n          true;\n        }\n      };\n    })());\n}\n\nclass EmitterFloats {\n  public static function average(emitter : Emitter<Float>) : Emitter<Float>\n    return emitter\n      .map((function(){\n        var sum = 0.0,\n            count = 0;\n        return function(v) return (sum += v) / (++count);\n      })());\n\n  public static function greaterThan(emitter : Emitter<Float>, x : Float) : Emitter<Float>\n    return emitter.filter(function(v) return v > x);\n\n  public static function greaterThanOrEqualTo(emitter : Emitter<Float>, x : Float) : Emitter<Float>\n    return emitter.filter(function(v) return v >= x);\n\n  public static function inRange(emitter : Emitter<Float>, min : Float, max : Float) : Emitter<Float>\n    return emitter.filter(function(v) return v <= max && v >= min);\n\n  public static function insideRange(emitter : Emitter<Float>, min : Float, max : Float) : Emitter<Float>\n    return emitter.filter(function(v) return v < max && v > min);\n\n  public static function lessThan(emitter : Emitter<Float>, x : Float) : Emitter<Float>\n    return emitter.filter(function(v) return v < x);\n\n  public static function lessThanOrEqualTo(emitter : Emitter<Float>, x : Float) : Emitter<Float>\n    return emitter.filter(function(v) return v <= x);\n\n  public static function max(emitter : Emitter<Float>) : Emitter<Float>\n    return emitter\n      .filter((function() {\n        var max : Float = Math.NEGATIVE_INFINITY;\n        return function(v)\n          return if(v > max) {\n            max = v;\n            true;\n          } else {\n            false;\n          }\n        })());\n\n  public static function min(emitter : Emitter<Float>) : Emitter<Float>\n    return emitter\n      .filter((function() {\n        var min : Float = Math.POSITIVE_INFINITY;\n        return function(v)\n          return if(v < min) {\n            min = v;\n            true;\n          } else {\n            false;\n          }\n        })());\n\n  public static function sum(emitter : Emitter<Float>) : Emitter<Float>\n    return emitter\n      .map((function(){\n        var sum = 0.0;\n        return function(v) return sum += v;\n      })());\n}\n\nclass EmitterOptions {\n  public static function either<T>(emitter : Emitter<Option<T>>, ?some : T -> Void, ?none : Void -> Void, ?end : Bool -> Void) {\n    if(null == some) some = function(_) {};\n    if(null == none) none = function() {};\n    return emitter.subscribe(\n        function(o : Option<T>) switch o {\n          case Some(v) : some(v);\n          case None: none();\n        },\n        end\n      );\n  }\n\n  public static function filterOption<T>(emitter : Emitter<Option<T>>) : Emitter<T>\n    return emitter\n      .filter(function(opt) return opt.toBool())\n      // cast is required by C#\n      .map(function(opt) return (opt.toValue() : T));\n\n  public static function toBool<T>(emitter : Emitter<Option<T>>) : Emitter<Bool>\n    return emitter\n      .map(function(opt) return opt.toBool());\n\n  public static function toValue<T>(emitter : Emitter<Option<T>>) : Emitter<Null<T>>\n    return emitter\n      .map(function(opt) return opt.toValue());\n}\n\nclass EmitterBools {\n  public static function negate(emitter : Emitter<Bool>)\n    return emitter.map(function(v) return !v);\n}\n\n@:access(thx.stream.Emitter)\nclass EmitterEmitters {\n  // TODO: is flatMap the right name here?\n  public static function flatMap<T>(emitter : Emitter<Emitter<T>>) : Emitter<T>\n    return new Emitter(function(stream) {\n      emitter.init(new Stream(function(r : StreamValue<Emitter<T>>) {\n        switch r {\n          case Pulse(em):  em.init(stream);\n          case End(true):  stream.cancel();\n          case End(false): stream.end();\n        }}));\n    });\n}\n\n@:access(thx.stream.Emitter)\nclass EmitterArrays {\n  public static function containerOf<T>(emitter : Emitter<Array<T>>, value : T) : Emitter<Array<T>>\n    return emitter.filter(function(arr) return arr.indexOf(value) >= 0);\n\n  public static function flatten<T>(emitter : Emitter<Array<T>>) : Emitter<T>\n    return new Emitter(function(stream) {\n      emitter.init(new Stream(function(r : StreamValue<Array<T>>) {\n        switch r {\n          case Pulse(arr): arr.map(stream.pulse);\n          case End(true):  stream.cancel();\n          case End(false): stream.end();\n        }}));\n    });\n}\n\nclass EmitterValues {\n  public static function left<TLeft, TRight>(emitter : Emitter<Tuple2<TLeft, TRight>>) : Emitter<TLeft>\n    return emitter.map(function(v) return v._0);\n\n  public static function right<TLeft, TRight>(emitter : Emitter<Tuple2<TLeft, TRight>>) : Emitter<TRight>\n    return emitter.map(function(v) return v._1);\n}","package thx.stream;\n\nimport thx.Error;\n\nclass Bus<T> extends Emitter<T> {\n  var downStreams : Array<Stream<T>>;\n  var upStreams : Array<Stream<T>>;\n  var distinctValuesOnly : Bool;\n  var equal : T -> T -> Bool;\n  var value : Null<T>;\n  public function new(distinctValuesOnly = false, ?equal : T -> T -> Bool) {\n    this.distinctValuesOnly = distinctValuesOnly;\n    this.equal = null == equal ? function(a, b) return a == b : equal;\n    this.downStreams = [];\n    this.upStreams = [];\n    super(function(stream : Stream<T>) {\n      this.downStreams.push(stream);\n      stream.addCleanUp(function() this.downStreams.remove(stream));\n    });\n  }\n\n  inline public function cancel()\n    emit(End(true));\n\n  public function clear() {\n    clearEmitters();\n    clearStreams();\n  }\n\n  public function clearStreams()\n    for(stream in downStreams.copy())\n      stream.end();\n\n  public function clearEmitters()\n    for(stream in upStreams.copy())\n      stream.cancel();\n\n  public function emit(value : StreamValue<T>) switch value {\n    case Pulse(v):\n      if(distinctValuesOnly) {\n        if(equal(v, this.value))\n          return;\n        this.value = v;\n      }\n      for(stream in downStreams.copy())\n        stream.pulse(v);\n    case End(true):\n      for(stream in downStreams.copy())\n        stream.cancel();\n    case End(false):\n      for(stream in downStreams.copy())\n        stream.end();\n  }\n\n  inline public function end()\n    emit(End(false));\n\n  inline public function pulse(value : T)\n    emit(Pulse(value));\n}","package thx.stream;\n\nclass Stream<T> implements IStream {\n\n  var subscriber : StreamValue<T> -> Void;\n  var cleanUps : Array<Void -> Void>;\n  var finalized : Bool;\n  public var canceled(default, null) : Bool;\n  public function new(subscriber : StreamValue<T> -> Void) {\n    this.subscriber = subscriber;\n    this.cleanUps   = [];\n    this.finalized  = false;\n    this.canceled   = false;\n  }\n\n  public function addCleanUp(f : Void -> Void)\n    cleanUps.push(f);\n\n  public function cancel() {\n    canceled = true;\n    finalize(End(true));\n  }\n\n  public function end()\n    finalize(End(false));\n\n  public function pulse(v : T)\n    subscriber(Pulse(v));\n\n  function finalize(signal : StreamValue<T>) {\n    if(finalized) return;\n    finalized = true;\n    while(cleanUps.length > 0)\n      cleanUps.shift()();\n    subscriber(signal);\n    subscriber = function(_) {};\n  }\n}","package thx.stream;\n\nimport haxe.ds.Option;\nimport thx.Options;\nimport thx.Functions;\n\n// TODO: value lens\nclass Value<T> extends Emitter<T> {\n  #if java @:generic #end\n  public static function createOption<T>(?value : T, ?equals : T -> T -> Bool) {\n    var def = Options.toOption(value);\n    return new Value<Option<T>>(def, function(a, b) return Options.equals(a, b, equals));\n  }\n\n  var value : T;\n  var downStreams : Array<Stream<T>>;\n  var upStreams : Array<Stream<T>>;\n  var equals : T -> T -> Bool;\n  public function new(value : T, ?equals : T -> T -> Bool) {\n    this.equals = null == equals ? Functions.equality : equals;\n    this.value = value;\n    this.downStreams = [];\n    this.upStreams = [];\n    super(function(stream : Stream<T>) {\n      this.downStreams.push(stream);\n      stream.addCleanUp(function() this.downStreams.remove(stream));\n      stream.pulse(this.value);\n    });\n  }\n\n  public function get() : T\n    return value;\n\n  public function clear() {\n    clearEmitters();\n    clearStreams();\n  }\n\n  public function clearStreams()\n    for(stream in downStreams.copy())\n      stream.end();\n\n  public function clearEmitters()\n    for(stream in upStreams.copy())\n      stream.cancel();\n\n  public function set(value : T) {\n    if(equals(this.value, value))\n      return;\n    this.value = value;\n    update();\n  }\n\n  function update()\n    for(stream in downStreams.copy())\n      stream.pulse(value);\n}","package thx.stream.dom;\n\nusing StringTools;\nimport js.html.DOMElement as Element;\nimport js.html.MouseEvent;\nimport js.html.KeyboardEvent;\nimport js.html.InputElement;\nimport js.html.Event;\nusing thx.Nil;\nusing thx.stream.Emitter;\nusing thx.promise.Promise;\n\nclass Dom {\n  public static function ready() : Promise<Nil>\n    return Promise.create(function(resolve, _) {\n      js.Browser.document.addEventListener(\"DOMContentLoaded\", function(_) {\n        resolve(nil);\n      }, false);\n    });\n\n  public inline static function streamClick(el : Element, capture = false) : Emitter<MouseEvent>\n    return streamMouseEvent(el, 'click', capture);\n\n  public static function streamEvent<TEvent : Event>(el : Element, name : String, capture = false) : Emitter<TEvent>\n    return new Emitter(function(stream) {\n      el.addEventListener(name, stream.pulse, capture);\n      stream.addCleanUp(function() el.removeEventListener(name, stream.pulse, capture));\n    });\n\n  public static function streamFocus(el : Element, capture = false) : Emitter<Bool>\n    return streamEvent(el, 'focus', capture).toTrue().merge(streamEvent(el, 'blur', capture).toFalse());\n\n  public static function streamKey(el : Element, name : String, capture = false) : Emitter<KeyboardEvent>\n    return new Emitter({\n      if(!name.startsWith('key'))\n        name = 'key$name';\n      function(stream) {\n        el.addEventListener(name, stream.pulse, capture);\n        stream.addCleanUp(function() el.removeEventListener(name, stream.pulse, capture));\n      }\n    });\n\n  public inline static function streamChecked(el : InputElement, capture = false) : Emitter<Bool>\n    return streamEvent(el, 'change', capture).map(function(_) return el.checked);\n\n  public inline static function streamChange(el : InputElement, capture = false) : Emitter<String>\n    return streamEvent(el, 'change', capture).map(function(_) return el.value);\n\n  public inline static function streamInput(el : InputElement, capture = false) : Emitter<String>\n    return streamMouseEvent(el, 'input', capture).map(function(_) return el.value);\n\n  public inline static function streamMouseDown(el : Element, capture = false) : Emitter<MouseEvent>\n    return streamEvent(el, \"mousedown\", capture);\n\n  public inline static function streamMouseEvent(el : Element, name : String, capture = false) : Emitter<MouseEvent>\n    return streamEvent(el, name, capture);\n\n  public inline static function streamMouseMove(el : Element, capture = false) : Emitter<MouseEvent>\n    return streamEvent(el, \"mousemove\", capture);\n\n  public inline static function streamMouseUp(el : Element, capture = false) : Emitter<MouseEvent>\n    return streamEvent(el, \"mouseup\", capture);\n\n  public static function subscribeAttribute<T>(el : Element, name : String) : T -> Void\n    return function(value : T) if(null == value) el.removeAttribute(name) else el.setAttribute(name, cast value);\n\n  public static function subscribeFocus(el : Element) : Bool -> Void\n    return function(focus : Bool) if(focus) el.focus() else el.blur();\n\n  public static function subscribeHTML(el : Element) : String -> Void\n    return function(html : String) el.innerHTML = html;\n\n  public static function subscribeText(el : Element, force = false) : String -> Void\n    return function(text : String) if(el.textContent != text || force) el.textContent = text;\n\n  public static function subscribeToggleAttribute<T>(el : Element, name : String, ?value : T) : Bool -> Void {\n    if(null == value)\n      value = cast el.getAttribute(name);\n    return function(on) if(on) el.setAttribute(name, cast value) else el.removeAttribute(name);\n  }\n\n  public static function subscribeToggleClass(el : Element, name : String) : Bool -> Void\n    return function(on) if(on) el.classList.add(name) else el.classList.remove(name);\n\n  public static function subscribeSwapClass(el : Element, nameOn : String, nameOff : String) : Bool -> Void\n    return function(on) if(on) {\n        el.classList.add(nameOn);\n        el.classList.remove(nameOff);\n      } else {\n        el.classList.add(nameOff);\n        el.classList.remove(nameOn);\n      };\n\n  public static function subscribeToggleVisibility(el : Element) : Bool -> Void {\n    var originalDisplay = el.style.display;\n    if(originalDisplay == 'none')\n      originalDisplay = '';\n    return function(on) if(on) el.style.display = originalDisplay else el.style.display = 'none';\n  }\n}","package udom;\n\nusing StringTools;\nimport js.html.DOMElement as Element;\nimport js.html.NodeList;\nimport thx.Nil;\nimport thx.promise.Promise;\n\nclass Html {\n  public static function parseList(html : String) : NodeList {\n    var el = js.Browser.document.createElement('div');\n    el.innerHTML = html;\n    return el.childNodes;\n  }\n\n  public inline static function parseAll(html : String) : Array<Element> {\n    return H.toArray(parseList(html.trim()));\n  }\n\n  // TODO: unsafe cast\n  public inline static function parse(html : String) : Element {\n    return cast parseList(html.ltrim())[0];\n  }\n}\n\nclass Query {\n  static var doc : Element = untyped __js__('document');\n  public static function first(selector : String, ?ctx : Element) : Element {\n    return (ctx != null ? ctx : doc).querySelector(selector);\n  }\n\n  public static function list(selector : String, ?ctx : Element) : NodeList {\n    return (ctx != null ? ctx : doc).querySelectorAll(selector);\n  }\n\n  public inline static function all(selector : String, ?ctx : Element) : Array<Element> {\n    return H.toArray(list(selector, ctx));\n  }\n\n  public static function getElementIndex(el : Element) {\n    var index = 0;\n    while(null != (el = el.previousElementSibling))\n      index++;\n    return index;\n  }\n\n  public static function childOf(child : Element, parent : Element)\n    return null != child && child.parentElement == parent ? child : null;\n\n  public static function childrenOf(children : Array<Element>, parent : Element) : Array<Element>\n    return children.filter(function(child) return child.parentElement == parent);\n}\n\nprivate class H {\n  public inline static function toArray(list : js.html.NodeList) : Array<Element>\n    return untyped __js__('Array.prototype.slice.call')(list, 0);\n}\n","class Config {\n  public static var icons(default, null) = {\n    add : 'plus-circle',\n    addMenu : 'plus-square',\n    remove : 'ban',\n    dropdown : 'reorder',\n    checked : 'toggle-on',\n    unchecked : 'toggle-off',\n    switchtype : 'bolt',\n    code : 'bolt',\n    value : 'pencil',\n    reference : 'link',\n\n    bool : 'check-circle',\n    text : 'pencil',\n    number : 'superscript',\n    date : 'calendar',\n    array : 'list',\n    object : 'table',\n  };\n\n  public static var selectors(default, null) = {\n    app : '.card'\n  };\n}"],
"names":[],
"mappings":"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"
}