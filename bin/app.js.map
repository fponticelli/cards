{
"version":3,
"file":"app.js",
"sourceRoot":"file://",
"sources":["/usr/lib/haxe/std/js/_std/EReg.hx","/usr/lib/haxe/std/js/_std/HxOverrides.hx","/usr/lib/haxe/std/Lambda.hx","/Users/francoponticelli/projects/cards/src/Main.hx","/Users/francoponticelli/projects/cards/src/PropertyFeeder.hx","/usr/lib/haxe/std/js/_std/Reflect.hx","/usr/lib/haxe/std/js/_std/Std.hx","/usr/lib/haxe/std/StringBuf.hx","/usr/lib/haxe/std/StringTools.hx","/usr/lib/haxe/std/js/_std/Type.hx","/Users/francoponticelli/projects/cards/src/dom/Dom.hx","/usr/lib/haxe/std/haxe/CallStack.hx","/usr/lib/haxe/std/haxe/Log.hx","/usr/lib/haxe/std/js/_std/haxe/ds/IntMap.hx","/usr/lib/haxe/std/js/_std/haxe/ds/ObjectMap.hx","/usr/lib/haxe/std/js/_std/haxe/ds/StringMap.hx","/usr/lib/haxe/std/haxe/io/Eof.hx","/usr/lib/haxe/std/js/Boot.hx","/Users/francoponticelli/projects/steamer/src/steamer/Consumer.hx","/Users/francoponticelli/projects/steamer/src/steamer/Producer.hx","/Users/francoponticelli/projects/steamer/src/steamer/Feeder.hx","/Users/francoponticelli/projects/steamer/src/steamer/MultiProducer.hx","/Users/francoponticelli/projects/steamer/src/steamer/Pulse.hx","/Users/francoponticelli/projects/steamer/src/steamer/Value.hx","/Users/francoponticelli/projects/steamer/src/steamer/dom/Dom.hx","/Users/francoponticelli/projects/steamer/src/steamer/producers/Interval.hx","/Users/francoponticelli/projects/cards/src/sui/components/Component.hx","/Users/francoponticelli/projects/cards/src/sui/components/Properties.hx","/Users/francoponticelli/projects/cards/src/sui/properties/Property.hx","/Users/francoponticelli/projects/cards/src/sui/properties/ValueProperty.hx","/Users/francoponticelli/projects/cards/src/sui/properties/BoolProperty.hx","/Users/francoponticelli/projects/cards/src/sui/properties/PropertyName.hx","/Users/francoponticelli/projects/cards/src/sui/properties/StringProperty.hx","/Users/francoponticelli/projects/cards/src/sui/properties/Text.hx","/Users/francoponticelli/projects/cards/src/sui/properties/ToggleClass.hx","/Users/francoponticelli/projects/cards/src/sui/properties/ValueProperties.hx","/Users/francoponticelli/projects/cards/src/sui/properties/Visible.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Error.hx","/Users/francoponticelli/projects/thx.core/src/thx/Assert.hx","/Users/francoponticelli/projects/steamer/src/thx/Timer.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Arrays.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Functions.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Ints.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Iterables.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Iterators.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Objects.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Options.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Set.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Strings.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Timer.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Tuple.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Types.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/UUID.hx","/Users/francoponticelli/projects/thx.promise/src/thx/promise/Deferred.hx","/Users/francoponticelli/projects/thx.promise/src/thx/promise/Promise.hx","/Users/francoponticelli/projects/cards/src/thx/ref/BaseRef.hx","/Users/francoponticelli/projects/cards/src/thx/ref/ArrayRef.hx","/Users/francoponticelli/projects/cards/src/thx/ref/ObjectRef.hx","/Users/francoponticelli/projects/cards/src/thx/ref/Ref.hx","/Users/francoponticelli/projects/cards/src/thx/ref/UnknownRef.hx","/Users/francoponticelli/projects/cards/src/thx/ref/ValueRef.hx","/Users/francoponticelli/projects/thx.stream/src/thx/stream/Emitter.hx","/Users/francoponticelli/projects/thx.stream/src/thx/stream/Stream.hx","/Users/francoponticelli/projects/thx.stream/src/thx/stream/Value.hx","/Users/francoponticelli/projects/thx.stream.dom/src/thx/stream/dom/Dom.hx","/Users/francoponticelli/projects/cards/src/types/ArrayTransform.hx","/Users/francoponticelli/projects/cards/src/types/BoolTransform.hx","/Users/francoponticelli/projects/cards/src/types/CodeTransform.hx","/Users/francoponticelli/projects/cards/src/types/DateTransform.hx","/Users/francoponticelli/projects/cards/src/types/DynamicTransform.hx","/Users/francoponticelli/projects/cards/src/types/FloatTransform.hx","/Users/francoponticelli/projects/cards/src/types/ObjectTransform.hx","/Users/francoponticelli/projects/cards/src/types/ReferenceTransform.hx","/Users/francoponticelli/projects/cards/src/types/StringTransform.hx","/Users/francoponticelli/projects/cards/src/types/TypeTransform.hx","/Users/francoponticelli/projects/cards/src/ui/Article.hx","/Users/francoponticelli/projects/cards/src/ui/Card.hx","/Users/francoponticelli/projects/cards/src/ui/widgets/FrameOverlay.hx","/Users/francoponticelli/projects/cards/src/ui/widgets/Tooltip.hx","/Users/francoponticelli/projects/cards/src/ui/ContextField.hx","/Users/francoponticelli/projects/cards/src/ui/ContextView.hx","/Users/francoponticelli/projects/cards/src/ui/Data.hx","/Users/francoponticelli/projects/cards/src/ui/Document.hx","/Users/francoponticelli/projects/cards/src/ui/Expression.hx","/Users/francoponticelli/projects/cards/src/ui/FieldValue.hx","/Users/francoponticelli/projects/cards/src/ui/Model.hx","/Users/francoponticelli/projects/cards/src/ui/ModelView.hx","/Users/francoponticelli/projects/cards/src/ui/ModelViewField.hx","/Users/francoponticelli/projects/cards/src/ui/Runtime.hx","/Users/francoponticelli/projects/cards/src/ui/Schema.hx","/Users/francoponticelli/projects/cards/src/ui/Scope.hx","/Users/francoponticelli/projects/cards/src/ui/editors/BoolEditor.hx","/Users/francoponticelli/projects/cards/src/ui/editors/TextEditor.hx","/Users/francoponticelli/projects/cards/src/ui/editors/CodeEditor.hx","/Users/francoponticelli/projects/cards/src/ui/editors/DateEditor.hx","/Users/francoponticelli/projects/cards/src/ui/editors/EditorPicker.hx","/Users/francoponticelli/projects/cards/src/ui/editors/FloatEditor.hx","/Users/francoponticelli/projects/cards/src/ui/editors/ReferenceEditor.hx","/Users/francoponticelli/projects/cards/src/ui/fragments/Block.hx","/Users/francoponticelli/projects/cards/src/ui/fragments/FragmentMapper.hx","/Users/francoponticelli/projects/cards/src/ui/fragments/FragmentName.hx","/Users/francoponticelli/projects/cards/src/ui/fragments/FragmentProperties.hx","/Users/francoponticelli/projects/cards/src/ui/fragments/ReadonlyBlock.hx","/Users/francoponticelli/projects/cards/src/ui/widgets/Button.hx","/Users/francoponticelli/projects/cards/src/ui/widgets/Menu.hx","/Users/francoponticelli/projects/cards/src/ui/widgets/Statusbar.hx","/Users/francoponticelli/projects/cards/src/ui/widgets/Toolbar.hx","/Users/francoponticelli/projects/cards/src/Config.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\n\tvar r : Dynamic;\n\n\tpublic function new( r : String, opt : String ) : Void {\n\t\topt = opt.split(\"u\").join(\"\"); // 'u' (utf8) depends on page encoding\n\t\tthis.r = untyped __new__(\"RegExp\",r,opt);\n\t}\n\n\tpublic function match( s : String ) : Bool {\n\t\tif( r.global ) r.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched( n : Int ) : String {\n\t\treturn if( r.m != null && n >= 0 && n < r.m.length ) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn r.s.substr(0,r.m.index);\n\t}\n\n\tpublic function matchedRight() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\tvar sz = r.m.index+r.m[0].length;\n\t\treturn r.s.substr(sz,r.s.length-sz);\n\t}\n\n\tpublic function matchedPos() : { pos : Int, len : Int } {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn { pos : r.m.index, len : r.m[0].length };\n\t}\n\n\tpublic function matchSub( s : String, pos : Int, len : Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match( len < 0 ? s.substr(pos) : s.substr(pos,len) );\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split( s : String ) : Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn untyped s.replace(r,d).split(d);\n\t}\n\n\tpublic function replace( s : String, by : String ) : String {\n\t\treturn untyped s.replace(r,by);\n\t}\n\n\tpublic function map( s : String, f : EReg -> String ) : String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\t#if mt\n\t\tvar x = (cast s).cca(index);\n\t\t#else\n\t\tvar x = (cast s).charCodeAt(index);\n\t\t#end\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn untyped undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif( pos != null && pos != 0 && len != null && len < 0 ) return \"\";\n\t\tif( len == null ) len = s.length;\n\t\tif( pos < 0 ){\n\t\t\tpos = s.length + pos;\n\t\t\tif( pos < 0 ) pos = 0;\n\t\t}else if( len < 0 ){\n\t\t\tlen = s.length + len - pos;\n\t\t}\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if !js_es5\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\n#if mt\n\t\tif( String.prototype.cca == null ) String.prototype.cca = String.prototype.charCodeAt;\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tThe `Lambda` class is a collection of methods to support functional\n\tprogramming. It is ideally used with 'using Lambda' and then acts as an\n\textension to Iterable types.\n\n\tOn static platforms, working with the Iterable structure might be slower\n\tthan performing the operations directly on known types, such as Array and\n\tList.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\nclass Lambda {\n\n\t/**\n\t\tCreates an Array from Iterable `it`.\n\n\t\tIf `it` is an Array, this function returns a copy of it.\n\t**/\n\tpublic static function array<A>( it : Iterable<A> ) : Array<A> {\n\t\tvar a = new Array<A>();\n\t\tfor(i in it)\n\t\t\ta.push(i);\n\t\treturn a;\n\t}\n\n\t/**\n\t\tCreates a List form Iterable `it`.\n\n\t\tIf `it` is a List, this function returns a copy of it.\n\t**/\n\tpublic static function list<A>( it : Iterable<A> ) : List<A> {\n\t\tvar l = new List<A>();\n\t\tfor(i in it)\n\t\t\tl.add(i);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tCreates a new List by applying function `f` to all elements of `it`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function map<A,B>( it : Iterable<A>, f : A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tfor( x in it )\n\t\t\tl.add(f(x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tSimilar to map, but also passes the index of each element to `f`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function mapi<A,B>( it : Iterable<A>, f : Int -> A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tvar i = 0;\n\t\tfor( x in it )\n\t\t\tl.add(f(i++,x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tTells if `it` contains `elt`.\n\n\t\tThis function returns true as soon as an element is found which is equal\n\t\tto `elt` according to the `==` operator.\n\n\t\tIf no such element is found, the result is false.\n\t**/\n\tpublic static function has<A>( it : Iterable<A>, elt : A ) : Bool {\n\t\tfor( x in it )\n\t\t\tif( x == elt )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `it` contains an element for which `f` is true.\n\n\t\tThis function returns true as soon as an element is found for which a\n\t\tcall to `f` returns true.\n\n\t\tIf no such element is found, the result is false.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function exists<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `f` is true for all elements of `it`.\n\n\t\tThis function returns false as soon as an element is found for which a\n\t\tcall to `f` returns false.\n\n\t\tIf no such element is found, the result is true.\n\n\t\tIn particular, this function always returns true if `it` is empty.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function foreach<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( !f(x) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tCalls `f` on all elements of `it`, in order.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function iter<A>( it : Iterable<A>, f : A -> Void ) {\n\t\tfor( x in it )\n\t\t\tf(x);\n\t}\n\n\t/**\n\t\tReturns a List containing those elements of `it` for which `f` returned\n\t\ttrue.\n\n\t\tIf `it` is empty, the result is the empty List even if `f` is null.\n\n\t\tOtherwise if `f` is null, the result is unspecified.\n\t**/\n\tpublic static function filter<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tvar l = new List<A>();\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tFunctional fold on Iterable `it`, using function `f` with start argument\n\t\t`first`.\n\n\t\tIf `it` has no elements, the result is `first`.\n\n\t\tOtherwise the first element of `it` is passed to `f` alongside `first`.\n\t\tThe result of that call is then passed to `f` with the next element of\n\t\t`it`, and so on until `it` has no more elements.\n\n\t\tIf `it` or `f` are null, the result is unspecified.\n\t**/\n\tpublic static function fold<A,B>( it : Iterable<A>, f : A -> B -> B, first : B ) : B {\n\t\tfor( x in it )\n\t\t\tfirst = f(x,first);\n\t\treturn first;\n\t}\n\n\t/**\n\t\tReturns the number of elements in `it` for which `pred` is true, or the\n\t\ttotal number of elements in `it` if `pred` is null.\n\n\t\tThis function traverses all elements.\n\t**/\n\tpublic static function count<A>( it : Iterable<A>, ?pred : A -> Bool ) {\n\t\tvar n = 0;\n\t\tif( pred == null )\n\t\t\tfor( _ in it )\n\t\t\t\tn++;\n\t\telse\n\t\t\tfor( x in it )\n\t\t\t\tif( pred(x) )\n\t\t\t\t\tn++;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tTells if Iterable `it` does not contain any element.\n\t**/\n\tpublic static function empty<T>( it : Iterable<T> ) : Bool {\n\t\treturn !it.iterator().hasNext();\n\t}\n\n\t/**\n\t\tReturns the index of the first element `v` within Iterable `it`.\n\n\t\tThis function uses operator `==` to check for equality.\n\n\t\tIf `v` does not exist in `it`, the result is -1.\n\t**/\n\tpublic static function indexOf<T>( it : Iterable<T>, v : T ) : Int {\n\t\tvar i = 0;\n\t\tfor( v2 in it ) {\n\t\t\tif( v == v2 )\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t\tReturns the first element of `it` for which `f` is true.\n\n\t\tThis function returns as soon as an element is found for which a call to\n\t\t`f` returns true.\n\n\t\tIf no such element is found, the result is null.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function find<T>( it : Iterable<T>, f : T -> Bool ) : Null<T> {\n\t\tfor( v in it ) {\n\t\t\tif(f(v)) return v;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tReturns a new List containing all elements of Iterable `a` followed by\n\t\tall elements of Iterable `b`.\n\n\t\tIf `a` or `b` are null, the result is unspecified.\n\t**/\n\tpublic static function concat<T>( a : Iterable<T>, b : Iterable<T> ) : List<T> {\n\t\tvar l = new List();\n\t\tfor( x in a )\n\t\t\tl.add(x);\n\t\tfor( x in b )\n\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n}\n","import thx.stream.dom.Dom;\nimport sui.properties.ValueProperties;\nimport ui.fragments.FragmentMapper;\nimport ui.fragments.FragmentProperties;\nimport ui.*;\nimport dom.Dom;\n\nclass Main {\n  public static function main() {\n    Dom.ready().success(function(_) {\n      var values    = new ValueProperties(),\n          fragments = new FragmentProperties(),\n          mapper    = new FragmentMapper(fragments, values);\n\n      PropertyFeeder.feedProperties(values);\n      PropertyFeeder.feedFragments(fragments);\n\n      var container = Query.first('.container'),\n        data      = new Data({}),\n        model     = new Model(data);\n\n      // Card\n      Card.create(model, container, mapper);\n    });\n  }\n}","import sui.components.Component;\nimport sui.properties.Text;\nimport sui.properties.ToggleClass;\nimport sui.properties.ValueProperties;\nimport ui.fragments.FragmentProperties;\nimport ui.SchemaType;\n\nclass PropertyFeeder {\n  static var classes = [\n    { display : 'bold', name : 'strong'},\n    { display : 'italic', name : 'emphasis'}\n  ];\n\n  public static function feedProperties(properties : ValueProperties) {\n    classes.map(function(p) properties.add(p.name, createToggleClass(p.display, p.name)));\n    properties.add('text', createText());\n  }\n\n  public static function feedFragments(fragments : FragmentProperties) {\n    fragments.associateMany('block', ['strong', 'emphasis', 'text']);\n    fragments.associateMany('readonly', ['strong', 'emphasis', 'text']);\n  }\n\n  static function createToggleClass(display : String, name : String) : ValuePropertyInfo<Bool> {\n    return {\n      name    : name,\n      display : display,\n      type    : BoolType,\n      create  : function(component : Component) {\n        var cls = new ToggleClass(component, name, name);\n        cls.stream.value = true;\n        return cls;\n      }\n    };\n  }\n\n  static function createText() : ValuePropertyInfo<String> {\n    return {\n      name    : 'text',\n      display : 'content',\n      type    : StringType,\n      create  : function(component : Component) return new Text(component, null) // null means that the text will be taken from the HTML\n    };\n  }\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\n\tpublic inline static function hasField( o : Dynamic, field : String ) : Bool {\n\t\treturn untyped __js__('Object').prototype.hasOwnProperty.call(o, field);\n\t}\n\n\tpublic static function field( o : Dynamic, field : String ) : Dynamic untyped {\n\t\treturn try o[field] catch( e : Dynamic ) null;\n\t}\n\n\tpublic inline static function setField( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\to[field] = value;\n\t}\n\n\tpublic static inline function getProperty( o : Dynamic, field : String ) : Dynamic untyped {\n\t\tvar tmp;\n\t\treturn if( o == null ) __define_feature__(\"Reflect.getProperty\",null) else if( o.__properties__ && (tmp=o.__properties__[\"get_\"+field]) ) o[tmp]() else o[field];\n\t}\n\n\tpublic static inline function setProperty( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\tvar tmp;\n\t\tif( o.__properties__ && (tmp=o.__properties__[\"set_\"+field]) ) o[tmp](value) else o[field] = __define_feature__(\"Reflect.setProperty\",value);\n\t}\n\n\tpublic inline static function callMethod( o : Dynamic, func : Dynamic, args : Array<Dynamic> ) : Dynamic untyped {\n\t\treturn func.apply(o,args);\n\t}\n\n\tpublic static function fields( o : Dynamic ) : Array<String> {\n\t\tvar a = [];\n\t\tif (o != null) untyped {\n\t\t\tvar hasOwnProperty = __js__('Object').prototype.hasOwnProperty;\n\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\tif( f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f) ) a.push(f);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static function isFunction( f : Dynamic ) : Bool untyped {\n\t\treturn __js__(\"typeof(f)\") == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>( a : T, b : T ) : Int {\n\t\treturn ( a == b ) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods( f1 : Dynamic, f2 : Dynamic ) : Bool {\n\t\tif( f1 == f2 )\n\t\t\treturn true;\n\t\tif( !isFunction(f1) || !isFunction(f2) )\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\tpublic static function isObject( v : Dynamic ) : Bool untyped {\n\t\tif( v == null )\n\t\t\treturn false;\n\t\tvar t = __js__(\"typeof(v)\");\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null)) || (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue( v : Dynamic ) : Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField( o : Dynamic, field : String ) : Bool untyped {\n\t\tif( !hasField(o,field) ) return false;\n\t\t__js__(\"delete\")(o[field]);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>( o : T ) : T {\n\t\tvar o2 : Dynamic = {};\n\t\tfor( f in Reflect.fields(o) )\n\t\t\tReflect.setField(o2,f,Reflect.field(o,f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function( f : Array<Dynamic> -> Void ) : Dynamic {})\n\tpublic static function makeVarArgs( f : Array<Dynamic> -> Dynamic ) : Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn cast(x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tIts cross-platform implementation uses String concatenation internally, but\n\tStringBuf may be optimized for different targets.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues. However, the internal buffer cannot be modified.\n**/\nclass StringBuf {\n\n\tvar b:String = \"\";\n\n\t/**\n\t\tThe length of `this` StringBuf in characters.\n\t**/\n\tpublic var length(get,never) : Int;\n\n\t/**\n\t\tCreates a new StringBuf instance.\n\n\t\tThis may involve initialization of the internal buffer.\n\t**/\n\tpublic function new() {}\n\n\tinline function get_length() : Int {\n\t\treturn b.length;\n\t}\n\n\t/**\n\t\tAppends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.\n\t**/\n\tpublic inline function add<T>( x : T ) : Void {\n\t\tb += x;\n\t}\n\n\t/**\n\t\tAppends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.\n\t**/\n\tpublic inline function addChar( c : Int ) : Void {\n\t\tb += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tAppends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.\n\t**/\n\tpublic inline function addSub( s : String, pos : Int, ?len : Int) : Void {\n\t\tb += (len == null ? s.substr(pos) : s.substr(pos, len));\n\t}\n\n\t/**\n\t\tReturns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation.\n\t**/\n\tpublic inline function toString() : String {\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t'using StringTools' and then acts as an extension to the String class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\n#if cs\n@:keep\n#end\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlEncode( s : String ) : String {\n\t\t#if flash9\n\t\t\treturn untyped __global__[\"encodeURIComponent\"](s);\n\t\t#elseif flash\n\t\t\treturn untyped _global[\"escape\"](s);\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped encodeURIComponent(s);\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLEncode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLEncoder.encode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.EscapeUriString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.quote(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlDecode( s : String ) : String {\n\t\t#if flash9\n\t\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif flash\n\t\t\treturn untyped _global[\"unescape\"](s);\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLDecode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLDecoder.decode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.unquote(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape( s : String, ?quotes : Bool ) : String {\n\t\ts = s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t\treturn quotes ? s.split('\"').join(\"&quot;\").split(\"'\").join(\"&#039;\") : s;\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: htmlUnescape(htmlEscape(s)) == s\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape( s : String ) : String {\n\t\treturn s.split(\"&gt;\").join(\">\").split(\"&lt;\").join(\"<\").split(\"&quot;\").join('\"').split(\"&#039;\").join(\"'\").split(\"&amp;\").join(\"&\");\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is null, the result is unspecified.\n\n\t\tIf `start` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function startsWith( s : String, start : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#else\n\t\treturn( s.length >= start.length && s.substr(0, start.length) == start );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is null, the result is unspecified.\n\n\t\tIf `end` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function endsWith( s : String, end : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn( slen >= elen && s.substr(slen - elen, elen) == end );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String \"\", or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace( s : String, pos : Int ) : Bool {\n\t\t#if python\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length) return false;\n\t\t#end\n\t\tvar c = s.charCodeAt( pos );\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function ltrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,r) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 )\n\t\t\treturn s.substr(r, l-r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function rtrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,l-r-1) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 ){\n\t\t\treturn s.substr(0, l-r);\n\t\t}else{\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for ltrim(rtrim(s)).\n\t**/\n\tpublic #if (cs || java) inline #end static function trim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn untyped s.trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = c + s;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = s + c;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReplace all occurences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String \"\", `by` is inserted after each character\n\t\tof `s`. If `by` is also the empty String \"\", `s` remains unchanged.\n\n\t\tThis is a convenience function for `s.split(sub).join(by)`.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace( s : String, sub : String, by : String ) : String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits length equals `digits`.\n\t**/\n\tpublic static function hex( n : Int, ?digits : Int ) {\n\t\t#if flash9\n\t\t\tvar n : UInt = n;\n\t\t\tvar s : String = untyped n.toString(16);\n\t\t\ts = s.toUpperCase();\n\t\t#else\n\t\t\tvar s = \"\";\n\t\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\t\tdo {\n\t\t\t\ts = hexChars.charAt(n&15) + s;\n\t\t\t\tn >>>= 4;\n\t\t\t} while( n > 0 );\n\t\t#end\n\t\t#if python\n\t\tif (digits != null && s.length < digits) {\n\t\t\tvar diff = digits - s.length;\n\t\t\tfor (_ in 0...diff) {\n\t\t\t\ts = \"0\" + s;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tif( digits != null )\n\t\t\twhile( s.length < digits )\n\t\t\t\ts = \"0\"+s;\n\t\t#end\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than String.charCodeAt() on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the \\0\n\t\tcharacter.\n\t**/\n\tpublic static inline function fastCodeAt( s : String, index : Int ) : Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash9\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s[\"cca\"](index);\n\t\t#elseif java\n\t\treturn ( index < s.length ) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn ( cast(index, UInt) < s.length ) ? cast(s[index], Int) : -1;\n\t\t#elseif js\n\t\treturn (untyped s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.lib.Builtin.ord(python.Syntax.arrayAccess(s, index));\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/*\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t*/\n\t@:noUsing public static inline function isEof( c : Int ) : Bool {\n\t\t#if (flash9 || cpp)\n\t\treturn c == 0;\n\t\t#elseif flash8\n\t\treturn c <= 0; // fast NaN\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif neko\n\t\treturn c == null;\n\t\t#elseif cs\n\t\treturn c == -1;\n\t\t#elseif java\n\t\treturn c == -1;\n\t\t#elseif python\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16 return untyped str._charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\",\"url_encode\",1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\",\"url_decode\",1);\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass( c : Class<Dynamic> );\n\tTEnum( e : Enum<Dynamic> );\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\n\tpublic static function getClass<T>( o : T ) : Class<T> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum( o : EnumValue ) : Enum<Dynamic> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn o.__enum__;\n\t}\n\n\tpublic static function getSuperClass( c : Class<Dynamic> ) : Class<Dynamic> untyped {\n\t\treturn c.__super__;\n\t}\n\n\n\tpublic static function getClassName( c : Class<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped c.__name__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function getEnumName( e : Enum<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped e.__ename__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function resolveClass( name : String ) : Class<Dynamic> untyped {\n\t\tvar cl : Class<Dynamic> = $hxClasses[name];\n\t\t// ensure that this is a class\n\t\tif( cl == null || !js.Boot.isClass(cl) )\n\t\t\treturn null;\n\t\treturn cl;\n\t}\n\n\tpublic static function resolveEnum( name : String ) : Enum<Dynamic> untyped {\n\t\tvar e : Dynamic = $hxClasses[name];\n\t\t// ensure that this is an enum\n\t\tif( e == null || !js.Boot.isEnum(e) )\n\t\t\treturn null;\n\t\treturn e;\n\t}\n\n\tpublic static function createInstance<T>( cl : Class<T>, args : Array<Dynamic> ) : T untyped {\n\t\tswitch( args.length ) {\n\t\tcase 0:\n\t\t\treturn __new__(cl);\n\t\tcase 1:\n\t\t\treturn __new__(cl,args[0]);\n\t\tcase 2:\n\t\t\treturn __new__(cl,args[0],args[1]);\n\t\tcase 3:\n\t\t\treturn __new__(cl,args[0],args[1],args[2]);\n\t\tcase 4:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3]);\n\t\tcase 5:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4]);\n\t\tcase 6:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5]);\n\t\tcase 7:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);\n\t\tcase 8:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);\n\t\tdefault:\n\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static function createEmptyInstance<T>( cl : Class<T> ) : T untyped {\n\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\treturn __js__(\"new empty()\");\n\t}\n\n\tpublic static function createEnum<T>( e : Enum<T>, constr : String, ?params : Array<Dynamic> ) : T {\n\t\tvar f = Reflect.field(e,constr);\n\t\tif( f == null ) throw \"No such constructor \"+constr;\n\t\tif( Reflect.isFunction(f) ) {\n\t\t\tif( params == null ) throw \"Constructor \"+constr+\" need parameters\";\n\t\t\treturn Reflect.callMethod(e,f,params);\n\t\t}\n\t\tif( params != null && params.length != 0 )\n\t\t\tthrow \"Constructor \"+constr+\" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>( e : Enum<T>, index : Int, ?params : Array<Dynamic> ) : T {\n\t\tvar c : String = (untyped e.__constructs__)[index];\n\t\tif( c == null ) throw index+\" is not a valid enum constructor index\";\n\t\treturn createEnum(e,c,params);\n\t}\n\n\tpublic static function getInstanceFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\n\tpublic static function getEnumConstructs( e : Enum<Dynamic> ) : Array<String> {\n\t\tvar a : Array<String> = untyped e.__constructs__;\n\t\treturn a.copy();\n\t}\n\n\tpublic static function typeof( v : Dynamic ) : ValueType untyped {\n\t\tswitch( __js__(\"typeof\")(v) ) {\n\t\tcase \"boolean\": return TBool;\n\t\tcase \"string\": return TClass(String);\n\t\tcase \"number\":\n\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\tif( Math.ceil(v) == v%2147483648.0 )\n\t\t\t\treturn TInt;\n\t\t\treturn TFloat;\n\t\tcase \"object\":\n\t\t\tif( v == null )\n\t\t\t\treturn TNull;\n\t\t\tvar e = v.__enum__;\n\t\t\tif( e != null )\n\t\t\t\treturn TEnum(e);\n\t\t\tvar c = js.Boot.getClass(v);\n\t\t\tif( c != null )\n\t\t\t\treturn TClass(c);\n\t\t\treturn TObject;\n\t\tcase \"function\":\n\t\t\tif( js.Boot.isClass(v) || js.Boot.isEnum(v) )\n\t\t\t\treturn TObject;\n\t\t\treturn TFunction;\n\t\tcase \"undefined\":\n\t\t\treturn TNull;\n\t\tdefault:\n\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T>( a : T, b : T ) : Bool untyped {\n\t\tif( a == b )\n\t\t\treturn true;\n\t\ttry {\n\t\t\tif( a[0] != b[0] )\n\t\t\t\treturn false;\n\t\t\tfor( i in 2...a.length )\n\t\t\t\tif( !enumEq(a[i],b[i]) )\n\t\t\t\t\treturn false;\n\t\t\tvar e = a.__enum__;\n\t\t\tif( e != b.__enum__ || e == null )\n\t\t\t\treturn false;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic inline static function enumConstructor( e : EnumValue ) : String {\n\t\treturn untyped e[0];\n\t}\n\n\tpublic inline static function enumParameters( e : EnumValue ) : Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\n\tpublic inline static function enumIndex( e : EnumValue ) : Int {\n\t\treturn untyped e[1];\n\t}\n\n\tpublic static function allEnums<T>( e : Enum<T> ) : Array<T> {\n\t\treturn untyped e.__empty_constructs__;\n\t}\n\n}\n\n","package dom;\n\nimport js.html.Element;\nimport thx.core.Nil;\nimport thx.promise.Promise;\n\nclass Html {\n  public static function parseList(html : String) {\n    var el = js.Browser.document.createElement('div');\n    el.innerHTML = html;\n    return el.childNodes;\n  }\n\n  public inline static function parseAll(html : String) {\n    return H.toArray(parseList(html));\n  }\n\n  // TODO unsafe cast\n  public inline static function parse(html : String) : Element {\n    return cast parseList(html)[0];\n  }\n}\n\nclass Query {\n  static var doc : Element = untyped __js__('document');\n  public static function first(selector : String, ?ctx : js.html.Element) {\n    return (ctx != null ? ctx : doc).querySelector(selector);\n  }\n\n  public static function list(selector : String, ?ctx : js.html.Element) {\n    return (ctx != null ? ctx : doc).querySelectorAll(selector);\n  }\n\n  public inline static function all(selector : String, ?ctx : js.html.Element) : Array<Element> {\n    return H.toArray(list(selector, ctx));\n  }\n}\n\nprivate class H {\n  public inline static function toArray(list : js.html.NodeList) : Array<Element>\n    return untyped __js__('Array.prototype.slice.call')(list, 0);\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule( m : String );\n\tFilePos( s : Null<StackItem>, file : String, line : Int );\n\tMethod( classname : String, method : String );\n\tLocalFunction( v : Int );\n}\n\n/**\n\tGet informations about the call stack.\n**/\nclass CallStack {\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\tvar a = makeStack(untyped __dollar__callstack());\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif flash9\n\t\t\tvar a = makeStack( new flash.errors.Error().getStackTrace() );\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\treturn makeStack(\"$s\");\n\t\t#elseif php\n\t\t\treturn makeStack(\"%s\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_call_stack(true);\n\t\t\treturn makeStack(s);\n\t\t#elseif js\n\t\t\t// https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\t\tvar oldValue = (untyped Error).prepareStackTrace;\n\t\t\t(untyped Error).prepareStackTrace = function (error, callsites :Array<Dynamic>) {\n\t\t\t\tvar stack = [];\n\t\t\t\tfor (site in callsites) {\n\t\t\t\t\tvar method = null;\n\t\t\t\t\tvar fullName :String = site.getFunctionName();\n\t\t\t\t\tif (fullName != null) {\n\t\t\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tvar className = fullName.substr(0, idx);\n\t\t\t\t\t\t\tvar methodName = fullName.substr(idx+1);\n\t\t\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(FilePos(method, site.getFileName(), site.getLineNumber()));\n\t\t\t\t}\n\t\t\t\treturn stack;\n\t\t\t}\n\t\t\tvar a = makeStack(untyped __new__(\"Error\").stack);\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\t(untyped Error).prepareStackTrace = oldValue;\n\t\t\treturn a;\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.lang.Thread.currentThread().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(1, true));\n\t\t#elseif python\n\t\t\tvar stack = [];\n\t\t\tvar infos = python.lib.Traceback.extract_stack();\n\t\t\tinfos.pop();\n\t\t\tinfos.reverse();\n\t\t\tfor (elem in infos)\n\t\t\t\tstack.push(FilePos(null, elem._1, elem._2));\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t**/\n\t#if cpp @:noStack #end /* Do not mess up the exception stack */\n\tpublic static function exceptionStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\treturn makeStack(untyped __dollar__excstack());\n\t\t#elseif as3\n\t\t\treturn new Array();\n\t\t#elseif flash9\n\t\t\tvar err : flash.errors.Error = untyped flash.Boot.lastError;\n\t\t\tif( err == null ) return new Array();\n\t\t\tvar a = makeStack( err.getStackTrace() );\n\t\t\tvar c = callStack();\n\t\t\tvar i = c.length - 1;\n\t\t\twhile( i > 0 ) {\n\t\t\t\tif( Std.string(a[a.length-1]) == Std.string(c[i]) )\n\t\t\t\t\ta.pop();\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\treturn makeStack(\"$e\");\n\t\t#elseif php\n\t\t\treturn makeStack(\"%e\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_exception_stack();\n\t\t\treturn makeStack(s);\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.internal.Exceptions.currentException().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// stack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(cs.internal.Exceptions.exception, true));\n\t\t#elseif python\n\t\t\tvar stack = [];\n\t\t\tvar exc = python.lib.Sys.exc_info();\n\t\t\tif (exc._3 != null)\n\t\t\t{\n\t\t\t\tvar infos = python.lib.Traceback.extract_tb(exc._3);\n\t\t\t\tinfos.reverse();\n\t\t\t\tfor (elem in infos)\n\t\t\t\t\tstack.push(FilePos(null, elem._1, elem._2));\n\t\t\t}\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tpublic static function toString( stack : Array<StackItem> ) {\n\t\tvar b = new StringBuf();\n\t\tfor( s in stack ) {\n\t\t\tb.add(\"\\nCalled from \");\n\t\t\titemToString(b,s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tprivate static function itemToString( b : StringBuf, s ) {\n\t\tswitch( s ) {\n\t\tcase CFunction:\n\t\t\tb.add(\"a C function\");\n\t\tcase Module(m):\n\t\t\tb.add(\"module \");\n\t\t\tb.add(m);\n\t\tcase FilePos(s,file,line):\n\t\t\tif( s != null ) {\n\t\t\t\titemToString(b,s);\n\t\t\t\tb.add(\" (\");\n\t\t\t}\n\t\t\tb.add(file);\n\t\t\tb.add(\" line \");\n\t\t\tb.add(line);\n\t\t\tif( s != null ) b.add(\")\");\n\t\tcase Method(cname,meth):\n\t\t\tb.add(cname);\n\t\t\tb.add(\".\");\n\t\t\tb.add(meth);\n\t\tcase LocalFunction(n):\n\t\t\tb.add(\"local function #\");\n\t\t\tb.add(n);\n\t\t}\n\t}\n\n\t#if cpp @:noStack #end /* Do not mess up the exception stack */\n\tprivate static function makeStack(s #if cs : cs.system.diagnostics.StackTrace #end) {\n\t\t#if neko\n\t\t\tvar a = new Array();\n\t\t\tvar l = untyped __dollar__asize(s);\n\t\t\tvar i = 0;\n\t\t\twhile( i < l ) {\n\t\t\t\tvar x = s[i++];\n\t\t\t\tif( x == null )\n\t\t\t\t\ta.unshift(CFunction);\n\t\t\t\telse if( untyped __dollar__typeof(x) == __dollar__tstring )\n\t\t\t\t\ta.unshift(Module(new String(x)));\n\t\t\t\telse\n\t\t\t\t\ta.unshift(FilePos(null,new String(untyped x[0]),untyped x[1]));\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash9\n\t\t\tvar a = new Array();\n\t\t\tvar r = ~/at ([^\\/]+?)\\$?(\\/[^\\(]+)?\\(\\)(\\[(.*?):([0-9]+)\\])?/;\n\t\t\tvar rlambda = ~/^MethodInfo-([0-9]+)$/g;\n\t\t\twhile( r.match(s) ) {\n\t\t\t\tvar cl = r.matched(1).split(\"::\").join(\".\");\n\t\t\t\tvar meth = r.matched(2);\n\t\t\t\tvar item;\n\t\t\t\tif( meth == null ) {\n\t\t\t\t\tif( rlambda.match(cl) )\n\t\t\t\t\t\titem = LocalFunction(Std.parseInt(rlambda.matched(1)));\n\t\t\t\t\telse\n\t\t\t\t\t\titem = Method(cl,\"new\");\n\t\t\t\t} else\n\t\t\t\t\titem = Method(cl,meth.substr(1));\n\t\t\t\tif( r.matched(3) != null )\n\t\t\t\t\titem = FilePos( item, r.matched(4), Std.parseInt(r.matched(5)) );\n\t\t\t\ta.push(item);\n\t\t\t\ts = r.matchedRight();\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\tvar a : Array<String> = untyped __eval__(s);\n\t\t\tvar m = new Array();\n\t\t\tfor( i in 0...a.length - if(s == \"$s\") 2 else 0 ) {\n\t\t\t\tvar d = a[i].split(\"::\");\n\t\t\t\tm.unshift(Method(d[0],d[1]));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif php\n\t\t\tif (!untyped __call__(\"isset\", __var__(\"GLOBALS\", s)))\n\t\t\t\treturn [];\n\t\t\tvar a : Array<String> = untyped __var__(\"GLOBALS\", s);\n\t\t\tvar m = [];\n\t\t\tfor( i in 0...a.length - ((s == \"%s\") ? 2 : 0)) {\n\t\t\t\tvar d = a[i].split(\"::\");\n\t\t\t\tm.unshift(Method(d[0],d[1]));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif cpp\n\t\t\tvar stack : Array<String> = s;\n\t\t\tvar m = new Array<StackItem>();\n\t\t\tfor(func in stack) {\n\t\t\t\tvar words = func.split(\"::\");\n\t\t\t\tif (words.length==0)\n\t\t\t\t\tm.unshift(CFunction)\n\t\t\t\telse if (words.length==2)\n\t\t\t\t\tm.unshift(Method(words[0],words[1]));\n\t\t\t\telse if (words.length==4)\n\t\t\t\t\tm.unshift(FilePos( Method(words[0],words[1]),words[2],Std.parseInt(words[3])));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif js\n\t\t\tif ((untyped __js__(\"typeof\"))(s) == \"string\") {\n\t\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\t\tvar stack : Array<String> = s.split(\"\\n\");\n\t\t\t\tvar m = [];\n\t\t\t\tfor( line in stack ) {\n\t\t\t\t\tm.push(Module(line)); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t\treturn m;\n\t\t\t} else {\n\t\t\t\treturn cast s;\n\t\t\t}\n\t\t#elseif cs\n\t\t\tvar stack = [];\n\t\t\tfor (i in 0...s.FrameCount)\n\t\t\t{\n\t\t\t\tvar frame = s.GetFrame(i);\n\t\t\t\tvar m = frame.GetMethod();\n\n\t\t\t\tvar method = StackItem.Method(m.ReflectedType.ToString(), m.Name);\n\n\t\t\t\tvar fileName = frame.GetFileName();\n\t\t\t\tvar lineNumber = frame.GetFileLineNumber();\n\n\t\t\t\tif (fileName != null || lineNumber >= 0)\n\t\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t\telse\n\t\t\t\t\tstack.push(method);\n\t\t\t}\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tLog primarily provides the trace() method, which is invoked upon a call to\n\ttrace() in haxe code.\n**/\nclass Log {\n\n\t/**\n\t\tOutputs `v` in a platform-dependent way.\n\n\t\tThe second parameter `infos` is injected by the compiler and contains\n\t\tinformation about the position where the trace() call was made.\n\n\t\tThis method can be rebound to a custom function:\n\t\t\tvar oldTrace = haxe.Log.trace; // store old function\n\t\t\thaxe.Log.trace = function(v,infos) { // handle trace }\n\t\t\t...\n\t\t\thaxe.Log.trace = oldTrace;\n\n\t\tIf it is bound to null, subsequent calls to trace() will cause an\n\t\texception.\n\t**/\n\tpublic static dynamic function trace( v : Dynamic, ?infos : PosInfos ) : Void {\n\t\t#if flash\n\t\t\t#if (fdb || native_trace)\n\t\t\t\tvar pstr = infos == null ? \"(null)\" : infos.fileName + \":\" + infos.lineNumber;\n\t\t\t\tvar str = flash.Boot.__string_rec(v, \"\");\n\t\t\t\tif( infos != null && infos.customParams != null ) for( v in infos.customParams ) str += \",\" + flash.Boot.__string_rec(v, \"\");\n\t\t\t\tuntyped #if flash9 __global__[\"trace\"] #else __trace__ #end(pstr+\": \"+str);\n\t\t\t#else\n\t\t\t\tuntyped flash.Boot.__trace(v,infos);\n\t\t\t#end\n\t\t#elseif neko\n\t\t\tuntyped {\n\t\t\t\t$print(infos.fileName + \":\" + infos.lineNumber + \": \", v);\n\t\t\t\tif( infos.customParams != null ) for( v in infos.customParams ) $print(\",\", v);\n\t\t\t\t$print(\"\\n\");\n\t\t\t}\n\t\t#elseif js\n\t\t\tuntyped js.Boot.__trace(v,infos);\n\t\t#elseif php\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __call__('_hx_trace', v + extra, infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __call__('_hx_trace', v, infos);\n\t\t#elseif cpp\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __trace(v + extra,infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __trace(v,infos);\n\t\t#elseif (cs || java)\n\t\t\tvar str:String = null;\n\t\t\tif (infos != null) {\n\t\t\t\tstr = infos.fileName + \":\" + infos.lineNumber + \": \" + v;\n\t\t\t\tif (infos.customParams != null)\n\t\t\t\t{\n\t\t\t\t\tstr += \",\" + infos.customParams.join(\",\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = v;\n\t\t\t}\n\t\t\t#if cs\n\t\t\tcs.system.Console.WriteLine(str);\n\t\t\t#elseif java\n\t\t\tuntyped __java__(\"java.lang.System.out.println(str)\");\n\t\t\t#end\n\t\t#elseif (python)\n\t\t\tvar str:String = null;\n\t\t\tif (infos != null) {\n\t\t\t\tstr = infos.fileName + \":\" + Std.string(infos.lineNumber) + \": \" + v;\n\t\t\t\tif (infos.customParams != null) {\n\t\t\t\t\tstr += \",\" + infos.customParams.join(\",\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = v;\n\t\t\t}\n\t\t\tpython.Lib.println(str);\n\t\t#end\n\t}\n\n\t#if (flash || js)\n\t/**\n\t\tClears the trace output.\n\t**/\n\tpublic static dynamic function clear() : Void {\n\t\t#if flash\n\t\tuntyped flash.Boot.__clear_trace();\n\t\t#elseif js\n\t\tuntyped js.Boot.__clear_trace();\n\t\t#end\n\t}\n\t#end\n\n\t#if flash\n\t/**\n\t\tSets the color of the trace output to `rgb`.\n\t**/\n\tpublic static dynamic function setColor( rgb : Int ) {\n\t\tuntyped flash.Boot.__set_trace_color(rgb);\n\t}\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\n@:coreApi class IntMap<T> implements Map.IMap<Int,T> {\n\n\tprivate var h : Dynamic;\n\n\tpublic function new() : Void {\n\t\th = {};\n\t}\n\n\tpublic function set( key : Int, value : T ) : Void {\n\t\tuntyped h[key] = value;\n\t}\n\n\tpublic function get( key : Int ) : Null<T> {\n\t\treturn untyped h[key];\n\t}\n\n\tpublic function exists( key : Int ) : Bool {\n\t\treturn untyped h.hasOwnProperty(key);\n\t}\n\n\tpublic function remove( key : Int ) : Bool {\n\t\tif( untyped !h.hasOwnProperty(key) ) return false;\n\t\tuntyped  __js__(\"delete\")(h[key]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<Int> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(key|0);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<T> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[i]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(i);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of h software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and h permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n@:coreApi\nclass ObjectMap<K:{ }, V> implements Map.IMap<K,V> {\n\n\tstatic var count = 0;\n\n\tstatic inline function assignId(obj: { } ):Int {\n\t\treturn untyped obj.__id__ = ++count;\n\t}\n\n\tstatic inline function getId(obj: { } ):Int {\n\t\treturn untyped obj.__id__;\n\t}\n\n\tvar h : { };\n\n\tpublic function new() : Void {\n\t\th = { };\n\t\tuntyped h.__keys__ = { };\n\t}\n\n\tpublic function set(key:K, value:V):Void untyped {\n\t\tvar id : Int = untyped key.__id__ || assignId(key);\n\t\th[id] = value;\n\t\th.__keys__[id] = key;\n\t}\n\n\tpublic inline function get(key:K):Null<V> {\n\t\treturn untyped h[getId(key)];\n\t}\n\n\tpublic inline function exists(key:K):Bool {\n\t\treturn untyped h.__keys__[getId(key)] != null;\n\t}\n\n\tpublic function remove( key : K ) : Bool {\n\t\tvar id = getId(key);\n\t\tif ( untyped h.__keys__[id] == null ) return false;\n\t\tuntyped  __js__(\"delete\")(h[id]);\n\t\tuntyped  __js__(\"delete\")(h.__keys__[id]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<K> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h.__keys__ ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(h.__keys__[key]);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<V> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[getId(i)]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(Std.string(i));\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\n@:coreApi class StringMap<T> implements Map.IMap<String,T> {\n\n\tprivate var h : Dynamic;\n\n\tpublic function new() : Void {\n\t\th = {};\n\t}\n\n\tpublic function set( key : String, value : T ) : Void {\n\t\tuntyped h[\"$\"+key] = value;\n\t}\n\n\tpublic function get( key : String ) : Null<T> {\n\t\treturn untyped h[\"$\"+key];\n\t}\n\n\tpublic function exists( key : String ) : Bool {\n\t\treturn untyped h.hasOwnProperty(\"$\"+key);\n\t}\n\n\tpublic function remove( key : String ) : Bool {\n\t\tkey = \"$\"+key;\n\t\tif( untyped !h.hasOwnProperty(key) ) return false;\n\t\tuntyped __js__(\"delete\")(h[key]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<String> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(key.substr(1));\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<T> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[\"$\"+i]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(i);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n/**\n\tThis exception is raised when reading while data is no longer available in the [Input].\n**/\nclass Eof {\n\tpublic function new() {\n\t}\n\t@:keep function toString() {\n\t\treturn \"Eof\";\n\t}\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic inline function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse\n\t\t\treturn untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t}\n\n\t@:ifFeature(\"may_print_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n}\n","package steamer;\n\nimport thx.core.Error;\nimport steamer.Pulse;\nimport haxe.ds.Option;\n\ntypedef ConsumerType<T> = {\n\tfunction onPulse(pulse : Pulse<T>) : Void;\n}\n\nabstract Consumer<T>(ConsumerType<T>) {\n\tpublic inline function new(consumer : ConsumerType<T>)\n\t\tthis = consumer;\n\n\t@:from public inline static function fromConsumer(consumer : ConsumerType<T>) : Consumer<T>\n\t\treturn new Consumer(consumer);\n\n\t@:from public inline static function fromFunction(f : T -> Void) : Consumer<T>\n\t\treturn new Consumer({\n\t\t\tonPulse : function(pulse) {\n\t\t\t\tswitch pulse {\n\t\t\t\t\tcase Emit(v): f(v);\n\t\t\t\t\tcase _:\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t@:from public static function fromObject<T>(o : { ?emit : T -> Void, ?end : Void -> Void, ?error : Error -> Void }) : Consumer<T> {\n\t\tif(null == o.emit) o.emit = function(_) {};\n\t\tif(null == o.end) o.end = function() {};\n\t\tif(null == o.error) o.error = function(e) { throw e; };\n\t\treturn new Consumer({\n\t\t\tonPulse : function(pulse) {\n\t\t\t\tswitch pulse {\n\t\t\t\t\tcase Emit(v): o.emit(v);\n\t\t\t\t\tcase End: o.end();\n\t\t\t\t\tcase Fail(e): o.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t@:from public static function fromOption<T>(o : { ?some : T -> Void, ?none : Void -> Void, ?end : Void -> Void, ?error : Error -> Void }) : Consumer<Option<T>> {\n\t\tif(null == o.some)  o.some  = function(_) {};\n\t\tif(null == o.none)  o.none  = function()  {};\n\t\tif(null == o.end)   o.end   = function()  {};\n\t\tif(null == o.error) o.error = function(e) { throw e; };\n\t\treturn new Consumer({\n\t\t\tonPulse : function(pulse) {\n\t\t\t\tswitch pulse {\n\t\t\t\t\tcase Emit(opt): switch opt {\n\t\t\t\t\t\t\tcase Some(v):\n\t\t\t\t\t\t\t\to.some(v);\n\t\t\t\t\t\t\tcase None :\n\t\t\t\t\t\t\t\to.none();\n\t\t\t\t\t\t}\n\t\t\t\t\tcase End: o.end();\n\t\t\t\t\tcase Fail(e): o.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t@:to public inline function toImplementation() : ConsumerType<T>\n\t\treturn this;\n}","package steamer;\n\nimport steamer.producers.Interval;\nimport steamer.Pulse;\nimport thx.core.Error;\nimport thx.core.Nil;\nimport thx.Timer;\nimport thx.core.Tuple;\nimport haxe.ds.Option;\n\nclass Producer<T> {\n\tvar handler : ProducerHandler<T>;\n\tvar endOnError : Bool;\n\tpublic function new(handler : ProducerHandler<T>, endOnError = true) {\n\t\tthis.handler = handler;\n\t\tthis.endOnError = endOnError;\n\t}\n\n\tpublic function feed(consumer : Consumer<T>) : Producer<T> {\n\t\tvar ended = false;\n\t\tfunction sendPulse(v : Pulse<T>) {\n\t\t\tswitch(v) {\n\t\t\t\tcase _ if(ended):\n\t\t\t\t\tthrow new Error(\"Feed already reached end but still receiving pulses: ${v}\");\n\t\t\t\tcase Fail(_) if(endOnError):\n\t\t\t\t\tTimer.setImmediate(consumer.toImplementation().onPulse.bind(v));\n\t\t\t\t\tTimer.setImmediate(consumer.toImplementation().onPulse.bind(End));\n\t\t\t\tcase End:\n\t\t\t\t\tended = true;\n\t\t\t\t\tTimer.setImmediate(consumer.toImplementation().onPulse.bind(End));\n\t\t\t\tcase _:\n\t\t\t\t\tTimer.setImmediate(consumer.toImplementation().onPulse.bind(v));\n\t\t\t}\n\t\t}\n\t\thandler(sendPulse);\n\t\treturn this;\n\t}\n\n\tpublic function toOption() : Producer<Option<T>> {\n\t\treturn map(function(v) return null == v ? None : Some(v));\n\t}\n\n\tpublic function map<TOut>(transform : T -> TOut) : Producer<TOut> {\n\t\treturn mapAsync(function(v, t) t(transform(v)));\n\t}\n\n\tpublic function mapAsync<TOut>(transform : T -> (TOut -> Void) -> Void) : Producer<TOut> {\n\t\treturn new Producer(function(forward : Pulse<TOut> -> Void) {\n\t\t\tthis.feed(Bus.passOn(\n\t\t\t\tfunction(value : T) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfunction t(v : TOut) forward(Emit(v));\n\t\t\t\t\t\ttransform(value, t);\n\t\t\t\t\t} catch(e : Error) {\n\t\t\t\t\t\tforward(Fail(e));\n\t\t\t\t\t} catch(e : Dynamic) {\n\t\t\t\t\t\tforward(Fail(new Error(Std.string(e))));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic function toNil() : Producer<Nil> {\n\t\treturn map(function(_) return nil);\n\t}\n\n\tpublic function toTrue() : Producer<Bool> {\n\t\treturn map(function(_) return true);\n\t}\n\n\tpublic function toFalse() : Producer<Bool> {\n\t\treturn map(function(_) return false);\n\t}\n\n\tpublic function log(?prefix : String, ?posInfo : haxe.PosInfos) {\n\t\tprefix = prefix == null ? '': '${prefix}: ';\n\t\treturn map(function(v) {\n\t\t\thaxe.Log.trace('$prefix$v', posInfo);\n\t\t\treturn v;\n\t\t});\n\t}\n\n\tpublic function filterMap<TOut>(transform : T -> Option<TOut>) : Producer<TOut>\n\t\treturn filterMapAsync(function(v, t) t(transform(v)));\n\n\tpublic function filterMapAsync<TOut>(transform : T -> (Option<TOut> -> Void) -> Void) : Producer<TOut>\n\t\treturn Producer.filterOption(mapAsync(transform));\n\n\tpublic function filter(f : T -> Bool) : Producer<T>\n\t\treturn filterAsync(function(v, t) t(f(v)));\n\n\tpublic function filterValue(value : T) : Producer<T>\n\t\treturn filterAsync(function(v, t) t(v == value));\n\n\tpublic function filterAsync(f : T -> (Bool -> Void) -> Void) : Producer<T> {\n\t\treturn new Producer(function(forward : Pulse<T> -> Void) {\n\t\t\tthis.feed(Bus.passOn(\n\t\t\t\tfunction(value : T) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfunction t(v : Bool) if(v) forward(Emit(value));\n\t\t\t\t\t\tf(value, t);\n\t\t\t\t\t} catch(e : Error) {\n\t\t\t\t\t\tforward(Fail(e));\n\t\t\t\t\t} catch(e : Dynamic) {\n\t\t\t\t\t\tforward(Fail(new Error(Std.string(e))));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic function withValue() : Producer<T>\n\t\treturn filter(function(v : T) return v != null);\n\n\tpublic function merge(other : Producer<T>) : Producer<T> {\n\t\treturn new Producer(function(forward : Pulse<T> -> Void) {\n\t\t\tvar ended  = false;\n\t\t\tfunction emit(v) {\n\t\t\t\tforward(Emit(v));\n\t\t\t}\n\t\t\tfunction end() {\n\t\t\t\tif(ended)\n\t\t\t\t\tforward(End);\n\t\t\t\telse\n\t\t\t\t\tended = true;\n\t\t\t}\n\t\t\tfunction fail(error) {\n\t\t\t\tforward(Fail(error));\n\t\t\t}\n\n\t\t\tthis.feed(new Bus(emit, end, fail));\n\t\t\tother.feed(new Bus(emit, end, fail));\n\t\t}, endOnError);\n\t}\n\n\tpublic function concat(other : Producer<T>) : Producer<T> {\n\t\treturn new Producer(function(forward : Pulse<T> -> Void) {\n\t\t\tfunction emit(v) {\n\t\t\t\tforward(Emit(v));\n\t\t\t}\n\t\t\tfunction fail(error) {\n\t\t\t\tforward(Fail(error));\n\t\t\t}\n\n\t\t\tthis.feed(new Bus(\n\t\t\t\temit,\n\t\t\t\tfunction() other.feed(Bus.passOn(emit, forward)),\n\t\t\t\tfail\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic function zip<TOther>(other : Producer<TOther>) : Producer<Tuple2<T, TOther>> {\n\t\treturn new Producer(function(forward : Pulse<Tuple2<T, TOther>> -> Void) {\n\t\t\tvar ended = false,\n\t\t\t\tendA  = false,\n\t\t\t\tendB  = false,\n\t\t\t\tbuffA : Array<T> = [],\n\t\t\t\tbuffB : Array<TOther> = [];\n\n\t\t\tfunction produce() {\n\t\t\t\tif(((buffA.length == 0 && endA) || (buffB.length == 0 && endB)) && !ended) {\n\t\t\t\t\tbuffA = null;\n\t\t\t\t\tbuffB = null;\n\t\t\t\t\tended = true;\n\t\t\t\t\treturn forward(End);\n\t\t\t\t}\n\t\t\t\tif(buffA.length == 0 || buffB.length == 0) return;\n\t\t\t\tforward(Emit(new Tuple2(buffA.shift(), buffB.shift())));\n\t\t\t}\n\n\t\t\tthis.feed(new Bus(\n\t\t\t\tfunction(value : T) {\n\t\t\t\t\tif(ended) return;\n\t\t\t\t\tbuffA.push(value);\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\tendA = true;\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction(error) {\n\t\t\t\t\tforward(Fail(error));\n\t\t\t\t}\n\t\t\t));\n\n\t\t\tother.feed(new Bus(\n\t\t\t\tfunction(value : TOther) {\n\t\t\t\t\tif(ended) return;\n\t\t\t\t\tbuffB.push(value);\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\tendB = true;\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction(error) {\n\t\t\t\t\tforward(Fail(error));\n\t\t\t\t}\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic function blend<TOther, TOut>(other : Producer<TOther>, f : T -> TOther -> TOut) : Producer<TOut> {\n\t\treturn this.zip(other).map(function(tuple) {\n\t\t\treturn f(tuple._0, tuple._1);\n\t\t});\n\t}\n\n\tpublic function pair<TOther>(other : Producer<TOther>) : Producer<Tuple2<T, TOther>> {\n\t\treturn new Producer(function(forward : Pulse<Tuple2<T, TOther>> -> Void) {\n\t\t\tvar endA  = false,\n\t\t\t\tendB  = false,\n\t\t\t\tbuffA : T = null,\n\t\t\t\tbuffB : TOther = null;\n\n\t\t\tfunction produce() {\n\t\t\t\tif(endA && endB) {\n\t\t\t\t\tbuffA = null;\n\t\t\t\t\tbuffB = null;\n\t\t\t\t\treturn forward(End);\n\t\t\t\t}\n\t\t\t\tif(buffA == null || buffB == null) return;\n\t\t\t\tforward(Emit(new Tuple2(buffA, buffB)));\n\t\t\t}\n\n\t\t\tthis.feed(new Bus(\n\t\t\t\tfunction(value : T) {\n\t\t\t\t\tbuffA = value;\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\tendA = true;\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction(error) {\n\t\t\t\t\tforward(Fail(error));\n\t\t\t\t}\n\t\t\t));\n\n\t\t\tother.feed(new Bus(\n\t\t\t\tfunction(value : TOther) {\n\t\t\t\t\tbuffB = value;\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\tendB = true;\n\t\t\t\t\tproduce();\n\t\t\t\t},\n\t\t\t\tfunction(error) {\n\t\t\t\t\tforward(Fail(error));\n\t\t\t\t}\n\t\t\t));\n\n\t\t}, endOnError);\n\t}\n\n\tpublic function distinct(?equals : T -> T -> Bool) : Producer<T> {\n\t\tif(null == equals)\n\t\t\tequals = function(a, b) return a == b;\n\t\treturn new Producer(function(forward) {\n\t\t\tvar last : T = null;\n\t\t\tthis.feed(Bus.passOn(\n\t\t\t\tfunction(v) {\n\t\t\t\t\tif(equals(v, last)) return;\n\t\t\t\t\tlast = v;\n\t\t\t\t\tforward(Emit(v));\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic  function debounce(delay : Int) : Producer<T> {\n\t\treturn new Producer(function(forward) {\n\t\t\tvar id : TimerID = null;\n\t\t\tthis.feed(Bus.passOn(\n\t\t\t\tfunction(v : T) {\n\t\t\t\t\tTimer.clearTimer(id);\n\t\t\t\t\tid = Timer.setTimeout(forward.bind(Emit(v)), delay);\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic function sampleBy<TSampler>(sampler : Producer<TSampler>) : Producer<Tuple2<T, TSampler>> {\n\t\treturn new Producer(function(forward : Pulse<Tuple2<T, TSampler>> -> Void) {\n\t\t\tvar latest : T = null;\n\t\t\tthis.feed(Bus.passOn(\n\t\t\t\tfunction(v) latest = v,\n\t\t\t\tforward\n\t\t\t));\n\t\t\tsampler.feed(Bus.passOn(\n\t\t\t\tfunction(v) {\n\t\t\t\t\t// skip if this hasn't produced anything yet or has been cleared\n\t\t\t\t\tif(null == latest) return;\n\t\t\t\t\tforward(Emit(new Tuple2(latest, v)));\n\t\t\t\t\tlatest = null;\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic function keep(n : Int) : Producer<Array<T>> {\n\t\treturn new Producer(function(forward) {\n\t\t\tvar acc = [];\n\t\t\tthis.feed(Bus.passOn(\n\t\t\t\tfunction(v) {\n\t\t\t\t\tacc.push(v);\n\t\t\t\t\tif(acc.length > n)\n\t\t\t\t\t\tacc.shift();\n\t\t\t\t\tforward(Emit(acc));\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\tpublic function previous() : Producer<T> {\n\t\treturn new Producer(function(forward) {\n\t\t\tvar isFirst   = true,\n\t\t\t\tstate : T = null;\n\t\t\tthis.feed(Bus.passOn(\n\t\t\t\tfunction(v) {\n\t\t\t\t\tif(isFirst) {\n\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tforward(Emit(state));\n\t\t\t\t\t}\n\t\t\t\t\tstate = v;\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, endOnError);\n\t}\n\n\t// public function window(length : Int, fillBeforeEmit = false) : Producer<T> // or unique\n\t// public function reduce(acc : TOut, TOut -> T) : Producer<TOut>\n\t// public function debounce(delay : Int) : Producer<T>\n\t// exact pair\n\t// public function zip<TOther>(other : Producer<TOther>) : Producer<Tuple<T, TOther>> // or sync\n\n\tpublic static function filterOption<T>(producer : Producer<Option<T>>) : Producer<T>\n\t\treturn producer\n\t\t\t.filter(function(opt) return switch opt { case Some(_): true; case None: false; })\n\t\t\t.map(function(opt) return switch opt { case Some(v) : v; case None: throw 'filterOption failed'; });\n\n\tpublic static function toValue<T>(producer : Producer<Option<T>>) : Producer<Null<T>>\n\t\treturn producer\n\t\t\t.map(function(opt) return switch opt { case Some(v) : v; case None: null; });\n\n\tpublic static function toBool<T>(producer : Producer<Option<T>>) : Producer<Bool>\n\t\treturn producer\n\t\t\t.map(function(opt) return switch opt { case Some(_) : true; case None: false; });\n\n\tpublic static function skipNull<T>(producer : Producer<Null<T>>) : Producer<T>\n\t\treturn producer\n\t\t\t.filter(function(value) return null != value);\n\n\tpublic static function left<TLeft, TRight>(producer : Producer<Tuple2<TLeft, TRight>>) : Producer<TLeft>\n\t\treturn producer.map(function(v) return v._0);\n\n\tpublic static function right<TLeft, TRight>(producer : Producer<Tuple2<TLeft, TRight>>) : Producer<TRight>\n\t\treturn producer.map(function(v) return v._1);\n\n\tpublic static function negate(producer : Producer<Bool>)\n\t\treturn producer.map(function(v) return !v);\n\n\tpublic static function flatMap<T>(producer : Producer<Array<T>>) : Producer<T> {\n\t\treturn new Producer(function(forward : Pulse<T> -> Void) {\n\t\t\tproducer.feed(Bus.passOn(\n\t\t\t\tfunction(arr : Array<T>) arr.map(function(value) forward(Emit(value))),\n\t\t\t\tforward\n\t\t\t));\n\t\t}, producer.endOnError);\n\t}\n\n\tpublic static function ofArray<T>(values : Array<T>) : Producer<T> {\n\t\treturn new Producer(function(forward) {\n\t\t\tvalues.map(function(v) forward(Emit(v)));\n\t\t\tforward(End);\n\t\t});\n\t}\n\n\tpublic static function ofTimedArray<T>(values : Array<T>, delay : Int) : Producer<T> {\n\t\treturn left(ofArray(values).zip(new Interval(delay, values.length)));\n\t}\n\n\tpublic static function delayed<T>(producer : Producer<T>, delay : Int) : Producer<T> {\n\t\treturn new Producer(function(forward) {\n\t\t\tproducer.feed(new Bus(\n\t\t\t\tfunction(v)\n\t\t\t\t\tTimer.setTimeout(function() forward(Emit(v)), delay),\n\t\t\t\tfunction()\n\t\t\t\t\tTimer.setTimeout(function() forward(End), delay),\n\t\t\t\tfunction(error)\n\t\t\t\t\tTimer.setTimeout(function() forward(Fail(error)), delay)\n\t\t\t));\n\t\t}, producer.endOnError);\n\t}\n}\n\n@:access(steamer.Producer)\nclass ProducerProducer {\n\tpublic static function flatMap<T>(producer : Producer<Producer<T>>) : Producer<T> {\n\t\treturn new Producer(function(forward : Pulse<T> -> Void) {\n\t\t\tproducer.feed(Bus.passOn(\n\t\t\t\tfunction(prod : Producer<T>) {\n\t\t\t\t\tprod.feed(Bus.passOn(\n\t\t\t\t\t\tfunction(value : T) forward(Emit(value)),\n\t\t\t\t\t\tforward\n\t\t\t\t\t));\n\t\t\t\t},\n\t\t\t\tforward\n\t\t\t));\n\t\t}, producer.endOnError);\n\t}\n}\n\nclass StringProducer {\n\tpublic static function toBool(producer : Producer<String>) : Producer<Bool>\n\t\treturn producer\n\t\t\t.map(function(s) return s != null && s != \"\");\n}\n\nclass Bus<T> {\n\tpublic static function feed<T>(forward : Pulse<T> -> Void) {\n\t\treturn new Bus(\n\t\t\tfunction(v) forward(Emit(v)),\n\t\t\tfunction() forward(End),\n\t\t\tfunction(error) forward(Fail(error))\n\t\t);\n\t}\n\n\tpublic static function passOn<TIn, TOut>(emit : TIn -> Void, forward : Pulse<TOut> -> Void) {\n\t\treturn new Bus(\n\t\t\temit,\n\t\t\tfunction() forward(End),\n\t\t\tfunction(error) forward(Fail(error))\n\t\t);\n\t}\n\n\tvar emit : T -> Void;\n\tvar end : Void -> Void;\n\tvar fail : Error -> Void;\n\tpublic function new(emit : T -> Void, end : Void -> Void, fail : Error -> Void) {\n\t\tthis.emit = emit;\n\t\tthis.end = end;\n\t\tthis.fail = fail;\n\t}\n\n\tpublic function onPulse(pulse : Pulse<T>) {\n\t\tswitch (pulse) {\n\t\t\tcase Emit(value):\n\t\t\t\temit(value);\n\t\t\tcase End:\n\t\t\t\tend();\n\t\t\tcase Fail(error):\n\t\t\t\tfail(error);\n\t\t}\n\t}\n}\n\ntypedef ProducerHandler<T> = (Pulse<T> -> Void) -> Void;","package steamer;\n\nimport steamer.Consumer;\nimport steamer.Producer;\n\nclass Feeder<T> extends Producer<T> {\n\tvar forwards : Array<Pulse<T> -> Void>;\n\n\tpublic function new() {\n\t\tforwards = [];\n\t\tsuper(function(forward) {\n\t\t\tthis.forwards.push(forward);\n\t\t}, false);\n\t}\n\n\tpublic function forward(pulse : Pulse<T>) {\n\t\tfor(f in forwards)\n\t\t\tf(pulse);\n\t\tswitch pulse {\n\t\t\tcase End: cancel();\n\t\t\tcase _:\n\t\t}\n\t}\n\n\tpublic function onPulse(pulse : Pulse<T>) {\n\t\tswitch pulse {\n\t\t\tcase Emit(v): forward(Emit(v));\n\t\t\tcase Fail(e): forward(Fail(e));\n\t\t\tcase End:     forward(End);\n\t\t}\n\t}\n\n\tpublic function cancel() {\n\t\tforwards = [];\n\t}\n}","package steamer;\n\nimport steamer.Consumer;\nimport steamer.Producer;\n\nclass MultiProducer<T> extends Producer<T> {\n\tvar producers : Array<Producer<T>>;\n\tvar consumers : Array<Consumer<T>>;\n\tpublic function new(endOnError = true) {\n\t\tproducers = [];\n\t\tconsumers = [];\n\t\tsuper(function(pulse) {}, endOnError);\n\t}\n\n\tpublic function add(producer : Producer<T>) {\n\t\tproducers.push(producer);\n\t\tfor(consumer in consumers)\n\t\t\tproducer.feed(consumer);\n\t}\n\n\tpublic function remove(producer : Producer<T>) {\n\t\tproducers.remove(producer);\n\t}\n\n\toverride function feed(consumer : Consumer<T>) {\n\t\tfor(producer in producers)\n\t\t\tproducer.feed(consumer);\n\t\tconsumers.push(consumer);\n\t\treturn this;\n\t}\n}","package steamer;\n\nimport thx.core.Error;\nimport thx.core.Nil;\n\nenum Pulse<T> {\n\tEmit(value : T);\n\tEnd;\n\tFail(error : Error);\n}\n\nclass Pulses {\n\tpublic static var nil(default, null) : Pulse<Nil> = Emit(thx.core.Nil.nil);\n\n\tpublic static function times<T>(n : Int, pulse : Pulse<T>) {\n\t\treturn [for(i in 0...n) pulse].concat([End]);\n\t}\n}","package steamer;\n\nimport steamer.Consumer;\nimport steamer.Producer;\nimport steamer.Pulse;\n\nclass Value<T> extends Feeder<T> {\n\tpublic static function string(value = \"\", ?defaultValue)\n\t\treturn new Value(value, defaultValue);\n\n\tpublic static function number(value = 0.0, ?defaultValue)\n\t\treturn new Value(value, defaultValue);\n\n\tpublic static function bool(value = false, ?defaultValue)\n\t\treturn new Value(value, defaultValue);\n\n\t@:isVar public var value(get, set) : T;\n\n\tpublic var defaultValue(default, null) : T;\n\n\tpublic function new(initialValue : T, ?defaultValue : T) {\n\t\tsuper();\n\t\tthis.defaultValue = null == defaultValue ? initialValue : defaultValue;\n\t\tthis.value = initialValue;\n\t}\n\n\tfunction get_value() : T\n\t\treturn value;\n\n\tfunction set_value(v : T) : T {\n\t\tif(v == value)\n\t\t\treturn v;\n\t\tvalue = v;\n\t\tforward(Emit(v));\n\t\treturn v;\n\t}\n\n\tpublic function end() {\n\t\tforward(End);\n\t}\n\n\toverride public function onPulse(pulse : Pulse<T>) {\n\t\tswitch pulse {\n\t\t\tcase Emit(v): value = v;\n\t\t\tcase Fail(e): forward(Fail(e));\n\t\t\tcase End:     forward(End);\n\t\t}\n\t}\n\n\toverride function feed(consumer : Consumer<T>) {\n\t\tsuper.feed(consumer);\n\t\tconsumer.toImplementation().onPulse(Emit(value));\n\t\treturn this;\n\t}\n\n\tpublic function reset() {\n\t\tthis.value = defaultValue;\n\t}\n\n\tpublic function isDefault() {\n\t\treturn this.value = defaultValue;\n\t}\n}","package steamer.dom;\n\nimport js.html.Element;\nimport js.html.Event;\nimport js.html.KeyboardEvent;\nimport steamer.Consumer;\nimport steamer.Producer;\nimport thx.core.Error;\nimport thx.Assert;\nusing StringTools;\n\nclass Dom {\n\tpublic static function produceEvent(el : Element, name : String) : EventProducer {\n\t\tvar cancel = null,\n\t\t\tproducer =  new Producer(function(forward) {\n\t\t\t\tvar f = function(e) {\n\t\t\t\t\tforward(Emit(e));\n\t\t\t\t};\n\t\t\t\tel.addEventListener(name, f, false);\n\t\t\t\tcancel = function() {\n\t\t\t\t\tel.removeEventListener(name, f, false);\n\t\t\t\t\tforward(End);\n\t\t\t\t};\n\t\t\t});\n\t\treturn { producer : producer, cancel : cancel };\n\t}\n\n\tpublic static function produceKeyboardEvent(el : Element, name : String) : KeyboardEventProducer {\n\t\tif(!name.startsWith('key'))\n\t\t\tname = 'key$name';\n\t\tvar cancel = null,\n\t\t\tproducer =  new Producer(function(forward) {\n\t\t\t\tvar f = function(e : KeyboardEvent) {\n\t\t\t\t\tforward(Emit(e));\n\t\t\t\t};\n\t\t\t\tel.addEventListener(name, f, false);\n\t\t\t\tcancel = function() {\n\t\t\t\t\tel.removeEventListener(name, f, false);\n\t\t\t\t\tforward(End);\n\t\t\t\t};\n\t\t\t});\n\t\treturn { producer : producer, cancel : cancel };\n\t}\n\n\tpublic static function consumeFocus(el : Element) : Consumer<Bool> {\n\t\treturn {\n\t\t\temit : function(v) v ? el.focus() : el.blur()\n\t\t};\n\t}\n\n\tpublic static function consumeText(el : Element) : Consumer<String> {\n\t\tvar originalText = el.innerText;\n\t\tfunction consume(text : String)\n\t\t\tel.innerText = text;\n\t\treturn {\n\t\t\temit : consume,\n\t\t\tend  : consume.bind(originalText)\n\t\t};\n\t}\n\n\tpublic static function consumeHtml(el : Element) : Consumer<String> {\n\t\tvar originalHtml = el.innerHTML;\n\t\tfunction consume(html : String)\n\t\t\tel.innerHTML = html;\n\t\treturn {\n\t\t\temit : consume,\n\t\t\tend  : consume.bind(originalHtml)\n\t\t};\n\t}\n\n\tpublic static function consumeAttribute<T>(el : Element, name : String) : Consumer<T> {\n\t\tvar originalValue : T = cast el.getAttribute(name);\n\t\tfunction consume(value : T)\n\t\t\tel.setAttribute(name, cast value);\n\t\treturn {\n\t\t\temit : consume,\n\t\t\tend  : null == originalValue ?\n\t\t\t\t\tfunction() el.removeAttribute(name) :\n\t\t\t\t\tconsume.bind(originalValue)\n\t\t};\n\t}\n\n\tpublic static function consumeToggleAttribute<T>(el : Element, name : String, ?value : String) : Consumer<Bool> {\n\t\tvar originalValue = el.hasAttribute(name);\n\t\tif(null == value)\n\t\t\tvalue = name;\n\t\tfunction consume(v : Bool)\n\t\t\tif(v)\n\t\t\t\tel.setAttribute(name, value);\n\t\t\telse\n\t\t\t\tel.removeAttribute(name);\n\t\treturn {\n\t\t\temit : consume,\n\t\t\tend  : consume.bind(originalValue)\n\t\t};\n\t}\n\n\tpublic static function consumeToggleClass<T>(el : Element, name : String) : Consumer<Bool> {\n\t\tvar originalValue = el.classList.contains(name);\n\t\tfunction consume(v : Bool)\n\t\t\tif(v)\n\t\t\t\tel.classList.add(name);\n\t\t\telse\n\t\t\t\tel.classList.remove(name);\n\t\treturn {\n\t\t\temit : consume,\n\t\t\tend  : consume.bind(originalValue)\n\t\t};\n\t}\n\n\tpublic static function consumeToggleVisibility<T>(el : Element) : Consumer<Bool> {\n\t\tvar originalDisplay = el.style.display;\n\t\tAssert.notNull(originalDisplay, 'original element.style.display for visibility is NULL');\n\t\tif(originalDisplay == 'none')\n\t\t\toriginalDisplay = '';\n\t\tfunction consume(value : Bool) {\n\t\t\tif(value) {\n\t\t\t\tel.style.display = originalDisplay;\n\t\t\t} else {\n\t\t\t\tel.style.display = 'none';\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\temit : consume,\n\t\t\tend  : consume.bind(true)\n\t\t};\n\t}\n}\n\ntypedef EventProducer = {\n\tproducer : Producer<Event>,\n\tcancel : Void -> Void\n}\n\ntypedef KeyboardEventProducer = {\n\tproducer : Producer<KeyboardEvent>,\n\tcancel : Void -> Void\n}","package steamer.producers;\n\nimport steamer.Pulse;\nimport steamer.Consumer;\nimport steamer.Producer;\n\nimport thx.core.Nil;\nimport thx.Timer;\n\nclass Interval extends Producer<Nil> {\n\tpublic function new(delay : Int, times : Int = 0) {\n\t\tsuper(function(pulse) {\n\t\t\tvar callback = null;\n\t\t\tif(times <= 0){\n\t\t\t\tcallback = function() {\n\t\t\t\t\tTimer.setInterval(function() pulse(Pulses.nil), delay);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcallback = function() {\n\t\t\t\t\tpulse(Pulses.nil);\n\t\t\t\t\tif(0 == --times)\n\t\t\t\t\t\tpulse(End);\n\t\t\t\t\telse\n\t\t\t\t\t\tTimer.setTimeout(callback, delay);\n\t\t\t\t};\n\t\t\t}\n\t\t\tcallback();\n\t\t});\n\t}\n}","package sui.components;\n\nimport dom.Dom;\nimport js.html.Element;\n\nclass Component {\n  public var children(get, null) : Iterable<Component>;\n  public var isAttached(default, null) : Bool = false;\n  public var parent(default, null) : Component;\n  public var properties(default, null) : Properties;\n  public var el(default, null) : Element;\n  var list : Array<Component>;\n\n  public function new(options : ComponentOptions) {\n    list = [];\n    properties = new Properties(this);\n    if(null == options.template) {\n      if(null == options.el)\n        throw '$this needs a template';\n      else {\n        el = options.el;\n        if(null != el.parentElement) {\n          isAttached = true;\n        }\n      }\n    } else {\n      el = Html.parse(options.template);\n    }\n    if(null != options.classes)\n      options.classes.split(' ').map(el.classList.add);\n    if(null != options.parent)\n      options.parent.add(this);\n    if(null != options.container)\n      appendTo(options.container);\n  }\n\n  public function appendTo(container : Element) {\n    container.appendChild(el);\n    isAttached = true;\n  }\n\n  public function detach() {\n    if(!isAttached)\n      throw 'Component is not attached';\n    el.parentElement.removeChild(el);\n    isAttached = false;\n  }\n\n  public function destroy() {\n    if(null != parent)\n      parent.remove(this);\n    if(isAttached)\n      detach();\n    properties.removeAll();\n  }\n\n  public function add(child : Component) {\n    if(null != child.parent)\n      child.parent.remove(child);\n    list.push(child);\n    child.parent = this;\n  }\n\n  public function remove(child : Component) {\n    if(!list.remove(child))\n      throw '$child is not a child of $this';\n    child.parent = null;\n  }\n\n  function get_children()\n    return list;\n\n  public function toString()\n    return Type.getClassName(Type.getClass(this)).split('.').pop();\n}","package sui.components;\n\nimport sui.properties.Property;\nimport sui.properties.PropertyName;\n\nclass Properties {\n  var properties : Map<String, Property>;\n  var target : Component;\n  public function new(target : Component) {\n    this.target = target;\n    properties = new Map();\n  }\n\n  public function removeAll() {\n    for(name in properties.keys())\n      remove(name);\n  }\n\n  function add(property : Property) {\n    if(properties.exists(property.name))\n      throw '$target already has a property $property';\n    properties.set(property.name, property);\n  }\n\n  public function get(name : PropertyName) {\n    return properties.get(name);\n  }\n\n  public function exists(name : PropertyName) {\n    return properties.exists(name);\n  }\n\n  function remove(name : PropertyName) {\n    if(!properties.exists(name))\n      throw 'property \"${name}\" does not exist in $target';\n    var prop = properties.get(name);\n    properties.remove(name);\n    prop.dispose();\n  }\n}","package sui.properties;\n\nimport sui.components.Component;\n\n@:access(sui.components.Properties)\nclass Property {\n  public var component(default, null) : Component;\n  public var name(default, null) : String;\n  var cancels : Array<Void -> Void>;\n  public function new(component : Component, name : String) {\n    this.component = component;\n    this.name = name;\n    cancels = [];\n    component.properties.add(this);\n  }\n\n  public function dispose() {\n    while(cancels.length > 0)\n      cancels.shift()();\n    if(this.component.properties.exists(name)) {\n      this.component.properties.remove(name);\n      this.component = null;\n    }\n  }\n\n  public function toString()\n    return Type.getClassName(Type.getClass(this)).split('.').pop();\n}","package sui.properties;\n\nimport haxe.ds.Option;\nimport sui.components.Component;\nimport steamer.Value;\nimport ui.Runtime;\nusing steamer.Producer;\nusing steamer.dom.Dom;\n\nclass ValueProperty<T> extends Property {\n  public var stream(default, null) : Value<T>;\n  public var runtime(default, null) : Value<Option<Runtime>>;\n  public var runtimeError(default, null) : Value<Option<String>>;\n\n  public function new(defaultValue : T, component : Component, name : String) {\n    stream = new Value(defaultValue);\n    runtime = new Value(None);\n    runtimeError = new Value(None);\n    super(component, name);\n\n    runtimeError\n      .toBool()\n      .feed(component.el.consumeToggleClass('error'));\n    runtime.feed(function(opt : Option<Runtime>) {\n      switch opt {\n        case None:\n          component.el.classList.remove('error');\n          runtimeError.value = None;\n        case Some(runtime):\n          switch runtime.expression {\n            case SyntaxError(e):\n              component.el.classList.add('error');\n              runtimeError.value = None;\n            case Fun(f):\n              component.el.classList.remove('error');\n              runtimeError.value = None;\n              switch f() {\n                case Result(v):\n                  stream.value = transform(v);\n                case Error(e):\n                  runtimeError.value = Some(e);\n              }\n          }\n      }\n    });\n  }\n\n  public function transform(value : Dynamic) : T {\n    return throw Type.getClassName(Type.getClass(this)).split('.').pop() + '.transform() is abstract and must be overridden';\n  }\n\n  override public function dispose() {\n    stream.end();\n    super.dispose();\n  }\n\n  function get_defaultValue()\n    return stream.defaultValue;\n\n  function get_value()\n    return stream.value;\n\n  function set_value(value : T)\n    return stream.value = value;\n}","package sui.properties;\n\nimport types.DynamicTransform;\n\nclass BoolProperty extends ValueProperty<Bool> {\n  override public function transform(value : Dynamic) : Bool {\n    return DynamicTransform.toBool(value);\n  }\n}","package sui.properties;\n\nabstract PropertyName(String) {\n  @:from public inline static function fromProperty(property : Property)\n    return new PropertyName(property.name);\n\n  @:from public inline static function fromString(name : String)\n    return new PropertyName(name);\n\n  public inline function new(name : String)\n    this = name;\n\n  @:to public inline function toString()\n    return this;\n}","package sui.properties;\n\nimport types.DynamicTransform;\n\nclass StringProperty extends ValueProperty<String> {\n  override public function transform(value : Dynamic) : String {\n    return DynamicTransform.toString(value);\n  }\n}","package sui.properties;\n\nimport sui.components.Component;\n\nclass Text extends StringProperty {\n  public function new(component : Component, ?defaultText : String) {\n    super(null == defaultText ? component.el.innerText : defaultText, component, 'text');\n    stream.feed({\n      emit : function(value) component.el.innerText = value,\n      end : function() {}\n    });\n  }\n}","package sui.properties;\n\nusing steamer.dom.Dom;\nimport sui.components.Component;\n\nclass ToggleClass extends BoolProperty {\n  public function new(component : Component, name : String, ?className : String) {\n    var defaultValue = component.el.classList.contains(className);\n    super(defaultValue, component, name);\n    className = null == className ? name : className;\n    stream.feed(component.el.consumeToggleClass(className));\n    cancels.push(function() {\n      if(defaultValue)\n        component.el.classList.add(className);\n      else\n        component.el.classList.remove(className);\n    });\n  }\n}","package sui.properties;\n\nimport sui.components.Component;\nimport sui.properties.ValueProperty;\nimport thx.Assert;\nimport ui.SchemaType;\n\nclass ValueProperties {\n  public var map : Map<String, ValuePropertyInfo<Dynamic>>;\n  public function new() {\n    map = new Map();\n  }\n\n  public function add(name : String, info : ValuePropertyInfo<Dynamic>) {\n    Assert.isFalse(map.exists(name), 'ValueProperties already contains \"$name\"');\n    map.set(name, info);\n  }\n\n  public function remove(name : String) {\n    Assert.isTrue(map.exists(name), 'ValueProperties does not contain \"$name\"');\n    map.remove(name);\n  }\n\n  public function get(name : String) {\n    Assert.isTrue(map.exists(name), 'ValueProperties does not contain \"$name\"');\n    return map.get(name);\n  }\n\n  public function ensure(name : String, component : Component) : ValueProperty<Dynamic> {\n    return if(component.properties.exists(name))\n      cast(component.properties.get(name), ValueProperty<Dynamic>);\n    else\n      get(name).create(component);\n  }\n\n  public function list()\n    return map.keys();\n}\n\ntypedef ValuePropertyInfo<T> = {\n  name    : String,\n  display : String,\n  create  : Component -> ValueProperty<T>,\n  type    : SchemaType\n}","package sui.properties;\n\nusing steamer.dom.Dom;\nimport sui.components.Component;\n\nclass Visible extends BoolProperty {\n  public function new(component : Component, defaultValue : Bool) {\n    super(defaultValue, component, 'visible');\n    stream.feed(component.el.consumeToggleVisibility());\n  }\n}","package thx.core;\n\nimport haxe.PosInfos;\nimport haxe.CallStack;\n\nclass Error #if js extends JSError #end {\n\tpublic static function fromDynamic(err : Dynamic, ?pos : PosInfos) : Error {\n\t\tif(Std.is(err, Error))\n\t\t\treturn cast err;\n\t\treturn new Error(\"\"+err, null, pos);\n\t}\n#if !js\n\tpublic var message(default, null) : String;\n#end\n\tpublic var stack(default, null) : Array<StackItem>;\n\tpublic var pos(default, null) : PosInfos;\n\tpublic function new(message : String, ?stack : Array<StackItem>, ?pos : PosInfos) {\n\t\tthis.message = message;\n\t\tif(null == stack) {\n\t\t\tstack = CallStack.exceptionStack();\n\t\t\tif(stack.length == 0)\n\t\t\t\tstack = CallStack.callStack();\n\t\t}\n\t\tthis.stack = stack;\n\t\tthis.pos = pos;\n\t}\n\n#if !js\n\tpublic function toString()\n\t\treturn message + \"from: \" + pos.className + \".\" + pos.methodName + \"() at \" + pos.lineNumber + \"\\n\\n\" + CallStack.toString(stack);\n#end\n}\n\n#if js\n@:native('Error')\nextern class JSError {\n\tpublic var message(default, null) : String;\n\tpublic function toString() : String;\n}\n#end","package thx;\n\nimport thx.core.Assertion;\nimport haxe.io.Bytes;\nimport haxe.PosInfos;\nimport thx.core.Error;\n\n/**\n* This class contains only static members used to perform assertations inside a test method.\n* It's use is straight forward:\n* <pre>\n* public function testObvious() {\n*   Assert.equals(1, 0); // fails\n*   Assert.isFalse(1 == 1, \"guess what?\"); // fails and returns the passed message\n*   Assert.isTrue(true); // successfull\n* }\n* </pre>\n*/\nclass Assert {\n\t/**\n\t* A stack of results for the current testing workflow. It is used internally\n\t* by other classes of the utest library.\n\t*/\n\tpublic static var results : { add : Assertion -> Void };\n\t/**\n\t* Asserts successfully when the condition is true.\n\t* @param cond: The condition to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function isTrue(cond : Bool, ?msg : String, ?pos : PosInfos) {\n\t\tif (results == null) throw \"Assert.results is not currently bound to any assert context\";\n\t\tif (null == msg)\n\t\t\tmsg = \"expected true\";\n\t\tif(cond)\n\t\t\tresults.add(Success(pos));\n\t\telse\n\t\t\tresults.add(Failure(msg, pos));\n\t}\n\t/**\n\t* Asserts successfully when the condition is false.\n\t* @param cond: The condition to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function isFalse(value : Bool, ?msg : String, ?pos : PosInfos) {\n\t\tif (null == msg)\n\t\t\tmsg = \"expected false\";\n\t\tisTrue(value == false, msg, pos);\n\t}\n\t/**\n\t* Asserts successfully when the value is null.\n\t* @param value: The value to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function isNull(value : Dynamic, ?msg : String, ?pos : PosInfos) {\n\t\tif (msg == null)\n\t\t\tmsg = \"expected null but was \" + q(value);\n\t\tisTrue(value == null, msg, pos);\n\t}\n\t/**\n\t* Asserts successfully when the value is not null.\n\t* @param value: The value to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function notNull(value : Dynamic, ?msg : String, ?pos : PosInfos) {\n\t\tif (null == msg)\n\t\t\tmsg = \"expected not null\";\n\t\tisTrue(value != null, msg, pos);\n\t}\n\t/**\n\t* Asserts successfully when the 'value' parameter is of the of the passed type 'type'.\n\t* @param value: The value to test\n\t* @param type: The type to test against\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function is(value : Dynamic, type : Dynamic, ?msg : String , ?pos : PosInfos) {\n\t\tif (msg == null) msg = \"expected type \" + typeToString(type) + \" but was \" + typeToString(value);\n\t\tisTrue(Std.is(value, type), msg, pos);\n\t}\n\n\t/**\n\t* Asserts successfully when the value parameter is not the same as the expected one.\n\t* <pre>\n\t* Assert.notEquals(10, age);\n\t* </pre>\n\t* @param expected: The expected value to check against\n\t* @param value: The value to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function notEquals(expected : Dynamic, value : Dynamic, ?msg : String , ?pos : PosInfos) {\n\t\tif(msg == null) msg = \"expected \" + q(expected) + \" and testa value \" + q(value) + \" should be different\";\n\t\tisFalse(expected == value, msg, pos);\n\t}\n\n\t/**\n\t* Asserts successfully when the value parameter is equal to the expected one.\n\t* <pre>\n\t* Assert.equals(10, age);\n\t* </pre>\n\t* @param expected: The expected value to check against\n\t* @param value: The value to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function equals(expected : Dynamic, value : Dynamic, ?msg : String , ?pos : PosInfos) {\n\t\tif(msg == null) msg = \"expected \" + q(expected) + \" but was \" + q(value);\n\t\tisTrue(expected == value, msg, pos);\n\t}\n\n\t/**\n\t* Asserts successfully when the value parameter does match against the passed EReg instance.\n\t* <pre>\n\t* Assert.match(~/x/i, \"haXe\");\n\t* </pre>\n\t* @param pattern: The pattern to match against\n\t* @param value: The value to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function match(pattern : EReg, value : Dynamic, ?msg : String , ?pos : PosInfos) {\n\t\tif(msg == null) msg = \"the value \" + q(value) + \"does not match the provided pattern\";\n\t\tisTrue(pattern.match(value), msg, pos);\n\t}\n\n\t/**\n\t* Same as Assert.equals but considering an approximation error.\n\t* <pre>\n\t* Assert.floatEquals(Math.PI, value);\n\t* </pre>\n\t* @param expected: The expected value to check against\n\t* @param value: The value to test\n\t* @param approx: The approximation tollerance. Default is 1e-5\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t* @todo test the approximation argument\n\t*/\n\tpublic static function floatEquals(expected : Float, value : Float, ?approx : Float, ?msg : String , ?pos : PosInfos) : Void {\n\t\tif (msg == null) msg = \"expected \" + q(expected) + \" but was \" + q(value);\n\t\treturn isTrue(_floatEquals(expected, value, approx), msg, pos);\n\t}\n\n\tstatic function _floatEquals(expected : Float, value : Float, ?approx : Float) {\n\t\tif (Math.isNaN(expected))\n\t\t\treturn Math.isNaN(value);\n\t\telse if (Math.isNaN(value))\n\t\t\treturn false;\n\t\telse if (!Math.isFinite(expected) && !Math.isFinite(value))\n\t\t\treturn (expected > 0) == (value > 0);\n\t\tif (null == approx)\n\t\t\tapprox = 1e-5;\n\t\treturn Math.abs(value-expected) < approx;\n\t}\n\n\tstatic function getTypeName(v : Dynamic)\n\t\treturn switch Type.typeof(v) {\n\t\t\tcase TNull    : \"[null]\";\n\t\t\tcase TInt     : \"Int\";\n\t\t\tcase TFloat   : \"Float\";\n\t\t\tcase TBool    : \"Bool\";\n\t\t\tcase TFunction: \"function\";\n\t\t\tcase TClass(c): Type.getClassName(c);\n\t\t\tcase TEnum(e) : Type.getEnumName(e);\n\t\t\tcase TObject  : \"Object\";\n\t\t\tcase TUnknown : \"Unknown\";\n\t\t};\n\n\tstatic function isIterable(v : Dynamic, isAnonym : Bool) {\n\t\tvar fields = isAnonym ? Reflect.fields(v) : Type.getInstanceFields(Type.getClass(v));\n\t\tif(!Lambda.has(fields, \"iterator\"))\n\t\t\treturn false;\n\t\treturn Reflect.isFunction(Reflect.field(v, \"iterator\"));\n\t}\n\n\tstatic function isIterator(v : Dynamic, isAnonym : Bool) {\n\t\tvar fields = isAnonym ? Reflect.fields(v) : Type.getInstanceFields(Type.getClass(v));\n\t\tif(!Lambda.has(fields, \"next\") || !Lambda.has(fields, \"hasNext\"))\n\t\t\treturn false;\n\t\treturn Reflect.isFunction(Reflect.field(v, \"next\")) && Reflect.isFunction(Reflect.field(v, \"hasNext\"));\n\t}\n\n\tstatic function sameAs(expected : Dynamic, value : Dynamic, status : LikeStatus) {\n\t\tvar texpected = getTypeName(expected);\n\t\tvar tvalue = getTypeName(value);\n\n\t\tif(texpected != tvalue) {\n\t\t\tstatus.error = \"expected type \" + texpected + \" but it is \" + tvalue + (status.path == '' ? '' : ' for field ' + status.path);\n\t\t\treturn false;\n\t\t}\n\t\tswitch Type.typeof(expected) {\n\t\t\tcase TFloat:\n\t\t\t\tif (!_floatEquals(expected, value)) {\n\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\tcase TNull, TInt, TBool:\n\t\t\t\tif(expected != value) {\n\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\tcase TFunction:\n\t\t\t\tif (!Reflect.compareMethods(expected, value)) {\n\t\t\t\t\tstatus.error = \"expected same function reference\" + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\tcase TClass(c):\n\t\t\t\tvar cexpected = Type.getClassName(c);\n\t\t\t\tvar cvalue = Type.getClassName(Type.getClass(value));\n\t\t\t\tif (cexpected != cvalue) {\n\t\t\t\t\tstatus.error = \"expected instance of \" + q(cexpected) + \" but it is \" + q(cvalue) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// string\n\t\t\t\tif (Std.is(expected, String) && expected != value) {\n\t\t\t\t\tstatus.error = \"expected '\" + expected + \"' but it is '\" + value + \"'\";\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// arrays\n\t\t\t\tif(Std.is(expected, Array)) {\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tif(expected.length != value.length) {\n\t\t\t\t\t\t\tstatus.error = \"expected \"+expected.length+\" elements but they were \"+value.length + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = status.path;\n\t\t\t\t\t\tfor(i in 0...expected.length) {\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'array['+i+']' : path + '['+i+']';\n\t\t\t\t\t\t\tif (!sameAs(expected[i], value[i], status))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// date\n\t\t\t\tif(Std.is(expected, Date)) {\n\t\t\t\t\tif(expected.getTime() != value.getTime()) {\n\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// bytes\n\t\t\t\tif(Std.is(expected, Bytes)) {\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tvar ebytes : Bytes = expected;\n\t\t\t\t\t\tvar vbytes : Bytes = value;\n\t\t\t\t\t\tif (ebytes.length != vbytes.length) return false;\n\t\t\t\t\t\tfor (i in 0...ebytes.length)\n\t\t\t\t\t\t\tif (ebytes.get(i) != vbytes.get(i))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatus.error = \"expected byte \" + ebytes.get(i) + \" but wss \" + ebytes.get(i) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// hash, inthash\n\t\t\t\tif(Std.is(expected, haxe.ds.StringMap) || Std.is(expected, haxe.ds.IntMap)) {\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tvar keys  = Lambda.array({ iterator : function() return expected.keys() });\n\t\t\t\t\t\tvar vkeys = Lambda.array({ iterator : function() return value.keys() });\n\t\t\t\t\t\tif(keys.length != vkeys.length) {\n\t\t\t\t\t\t\tstatus.error = \"expected \"+keys.length+\" keys but they were \"+vkeys.length + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = status.path;\n\t\t\t\t\t\tfor(key in keys) {\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'hash['+key+']' : path + '['+key+']';\n\t\t\t\t\t\t\tif (!sameAs(expected.get(key), value.get(key), status))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// iterator\n\t\t\t\tif(isIterator(expected, false)) {\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tvar evalues = Lambda.array({ iterator : function() return expected });\n\t\t\t\t\t\tvar vvalues = Lambda.array({ iterator : function() return value });\n\t\t\t\t\t\tif(evalues.length != vvalues.length) {\n\t\t\t\t\t\t\tstatus.error = \"expected \"+evalues.length+\" values in Iterator but they were \"+vvalues.length + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = status.path;\n\t\t\t\t\t\tfor(i in 0...evalues.length) {\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'iterator['+i+']' : path + '['+i+']';\n\t\t\t\t\t\t\tif (!sameAs(evalues[i], vvalues[i], status))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// iterable\n\t\t\t\tif(isIterable(expected, false)) {\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tvar evalues = Lambda.array(expected);\n\t\t\t\t\t\tvar vvalues = Lambda.array(value);\n\t\t\t\t\t\tif(evalues.length != vvalues.length) {\n\t\t\t\t\t\t\tstatus.error = \"expected \"+evalues.length+\" values in Iterable but they were \"+vvalues.length + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = status.path;\n\t\t\t\t\t\tfor(i in 0...evalues.length) {\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'iterable['+i+']' : path + '['+i+']';\n\t\t\t\t\t\t\tif(!sameAs(evalues[i], vvalues[i], status))\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// custom class\n\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\tvar fields = Type.getInstanceFields(Type.getClass(expected));\n\t\t\t\t\tvar path = status.path;\n\t\t\t\t\tfor(field in fields) {\n\t\t\t\t\t\tstatus.path = path == '' ? field : path+'.'+field;\n\t\t\t\t\t\tvar e = Reflect.field(expected, field);\n\t\t\t\t\t\tif(Reflect.isFunction(e)) continue;\n\t\t\t\t\t\tvar v = Reflect.field(value, field);\n\t\t\t\t\t\tif(!sameAs(e, v, status))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\tcase TEnum(e) :\n\t\t\t\tvar eexpected = Type.getEnumName(e);\n\t\t\t\tvar evalue = Type.getEnumName(Type.getEnum(value));\n\t\t\t\tif (eexpected != evalue) {\n\t\t\t\t\tstatus.error = \"expected enumeration of \" + q(eexpected) + \" but it is \" + q(evalue) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (status.recursive || status.path == '') {\n\t\t\t\t\tif (Type.enumIndex(expected) != Type.enumIndex(value)) {\n\t\t\t\t\t\tstatus.error = 'expected ' + q(Type.enumConstructor(expected)) + ' but is ' + q(Type.enumConstructor(value)) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tvar eparams = Type.enumParameters(expected);\n\t\t\t\t\tvar vparams = Type.enumParameters(value);\n\t\t\t\t\tvar path = status.path;\n\t\t\t\t\tfor (i in 0...eparams.length) {\n\t\t\t\t\t\tstatus.path = path == '' ? 'enum[' + i + ']' : path + '[' + i + ']';\n\t\t\t\t\t\tif (!sameAs(eparams[i], vparams[i], status)) {\n\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field ' + status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\tcase TObject  :\n\t\t\t\t// anonymous object\n\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\tvar tfields = Reflect.fields(value);\n\t\t\t\t\tvar fields = Reflect.fields(expected);\n\t\t\t\t\tvar path = status.path;\n\t\t\t\t\tfor(field in fields) {\n\t\t\t\t\t\ttfields.remove(field);\n\t\t\t\t\t\tstatus.path = path == '' ? field : path+'.'+field;\n\t\t\t\t\t\tif(!Reflect.hasField(value, field)) {\n\t\t\t\t\t\t\tstatus.error = \"expected field \" + status.path + \" does not exist in \" + q(value);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar e = Reflect.field(expected, field);\n\t\t\t\t\t\tif(Reflect.isFunction(e))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar v = Reflect.field(value, field);\n\t\t\t\t\t\tif(!sameAs(e, v, status))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif(tfields.length > 0) {\n\t\t\t\t\t\tstatus.error = \"the tested object has extra field(s) (\" + tfields.join(\", \") + \") not included in the expected ones\";\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// iterator\n\t\t\t\tif(isIterator(expected, true)) {\n\t\t\t\t\tif(!(isIterator(value, true))) {\n\t\t\t\t\t\tstatus.error = \"expected Iterable but it is not \" + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tvar evalues = Lambda.array({ iterator : function() return expected });\n\t\t\t\t\t\tvar vvalues = Lambda.array({ iterator : function() return value });\n\t\t\t\t\t\tif(evalues.length != vvalues.length) {\n\t\t\t\t\t\t\tstatus.error = \"expected \"+evalues.length+\" values in Iterator but they were \"+vvalues.length + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = status.path;\n\t\t\t\t\t\tfor(i in 0...evalues.length) {\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'iterator['+i+']' : path + '['+i+']';\n\t\t\t\t\t\t\tif (!sameAs(evalues[i], vvalues[i], status))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// iterable\n\t\t\t\tif(isIterable(expected, true)) {\n\t\t\t\t\tif(!(isIterable(value, true))) {\n\t\t\t\t\t\tstatus.error = \"expected Iterator but it is not \" + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif(status.recursive || status.path == '') {\n\t\t\t\t\t\tvar evalues = Lambda.array(expected);\n\t\t\t\t\t\tvar vvalues = Lambda.array(value);\n\t\t\t\t\t\tif(evalues.length != vvalues.length) {\n\t\t\t\t\t\t\tstatus.error = \"expected \"+evalues.length+\" values in Iterable but they were \"+vvalues.length + (status.path == '' ? '' : ' for field '+status.path);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar path = status.path;\n\t\t\t\t\t\tfor(i in 0...evalues.length) {\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'iterable['+i+']' : path + '['+i+']';\n\t\t\t\t\t\t\tif(!sameAs(evalues[i], vvalues[i], status))\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\tcase TUnknown :\n\t\t\t\treturn throw \"Unable to compare two unknown types\";\n\t\t}\n\t\treturn throw \"Unable to compare values: \" + q(expected) + \" and \" + q(value);\n\t}\n\n\tstatic function q(v : Dynamic)\n\t\treturn if (Std.is(v, String))\n\t\t\t'\"' + StringTools.replace(v, '\"', '\\\\\"') + '\"';\n\t\telse\n\t\t\tStd.string(v);\n\n\t/**\n\t* Check that value is an object with the same fields and values found in expected.\n\t* The default behavior is to check nested objects in fields recursively.\n\t* <pre>\n\t* Assert.same({ name : \"utest\"}, ob);\n\t* </pre>\n\t* @param expected: The expected value to check against\n\t* @param value: The value to test\n\t* @param recursive: States whether or not the test will apply also to sub-objects.\n\t* Defaults to true\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function same(expected : Dynamic, value : Dynamic, ?recursive : Bool, ?msg : String, ?pos : PosInfos) {\n\t\tvar status = { recursive : null == recursive ? true : recursive, path : '', error : null };\n\t\tif(sameAs(expected, value, status))\n\t\t\tAssert.isTrue(true, msg, pos);\n\t\telse\n\t\t\tAssert.fail(msg == null ? status.error : msg, pos);\n\t}\n\n\t/**\n\t* It is used to test an application that under certain circumstances must\n\t* react throwing an error. This assert guarantees that the error is of the\n\t* correct type (or Dynamic if non is specified).\n\t* <pre>\n\t* Assert.raises(function() { throw \"Error!\"; }, String);\n\t* </pre>\n\t* @param method: A method that generates the exception.\n\t* @param type: The type of the expected error. Defaults to Dynamic (catch all).\n\t* @param msgNotThrown: An optional error message used when the function fails to raise the expected\n\t*  \t\t exception. If not passed a default one will be used\n\t* @param msgWrongType: An optional error message used when the function raises the exception but it is\n\t*  \t\t of a different type than the one expected. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t* @todo test the optional type parameter\n\t*/\n\tpublic static function raises(method:Void -> Void, ?type:Class<Dynamic>, ?msgNotThrown : String , ?msgWrongType : String, ?pos : PosInfos) {\n\t\tif(type == null)\n\t\t\ttype = String;\n\t\ttry {\n\t\t\tmethod();\n\t\t\tvar name = Type.getClassName(type);\n\t\t\tif (name == null) name = \"\"+type;\n\t\t\tif (null == msgNotThrown)\n\t\t\t\tmsgNotThrown = \"exception of type \" + name + \" not raised\";\n\t\t\tfail(msgNotThrown, pos);\n\t\t} catch (ex : Dynamic) {\n\t\t\tvar name = Type.getClassName(type);\n\t\t\tif (name == null) name = \"\"+type;\n\t\t\tif (null == msgWrongType)\n\t\t\t\tmsgWrongType = \"expected throw of type \" + name + \" but was \"  + ex;\n\t\t\tisTrue(Std.is(ex, type), msgWrongType, pos);\n\t\t}\n\t}\n\t/**\n\t* Checks that the test value matches at least one of the possibilities.\n\t* @param possibility: An array of mossible matches\n\t* @param value: The value to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function allows<T>(possibilities : Array<T>, value : T, ?msg : String , ?pos : PosInfos)\n\t\tif(Lambda.has(possibilities, value))\n\t\t\tisTrue(true, msg, pos);\n\t\telse\n\t\t\tfail(msg == null ? \"value \" + q(value) + \" not found in the expected possibilities \" + possibilities : msg, pos);\n\t/**\n\t* Checks that the test array contains the match parameter.\n\t* @param match: The element that must be included in the tested array\n\t* @param values: The values to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function contains<T>(match : T, values : Array<T>, ?msg : String , ?pos : PosInfos)\n\t\tif(Lambda.has(values, match))\n\t\t\tisTrue(true, msg, pos);\n\t\telse\n\t\t\tfail(msg == null ? \"values \" + q(values) + \" do not contain \"+match: msg, pos);\n\n\t/**\n\t* Checks that the test array does not contain the match parameter.\n\t* @param match: The element that must NOT be included in the tested array\n\t* @param values: The values to test\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function notContains<T>(match : T, values : Array<T>, ?msg : String , ?pos : PosInfos)\n\t\tif(!Lambda.has(values, match))\n\t\t\tisTrue(true, msg, pos);\n\t\telse\n\t\t\tfail(msg == null ? \"values \" + q(values) + \" do contain \"+match: msg, pos);\n\n\t/**\n\t * Checks that the expected values is contained in value.\n\t * @param match: the string value that must be contained in value\n\t * @param value: the value to test\n\t * @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t */\n\tpublic static function stringContains(match : String, value : String, ?msg : String , ?pos : PosInfos)\n\t\tif (value != null && value.indexOf(match) >= 0)\n\t\t\tisTrue(true, msg, pos);\n\t\telse\n\t\t\tfail(msg == null ? \"value \" + q(value) + \" does not contain \" + q(match) : msg, pos);\n\n\tpublic static function stringSequence(sequence : Array<String>, value : String, ?msg : String , ?pos : PosInfos) {\n\t\tif (null == value) {\n\t\t\tfail(msg == null ? \"null argument value\" : msg, pos);\n\t\t\treturn;\n\t\t}\n\t\tvar p = 0;\n\t\tfor (s in sequence) {\n\t\t\tvar p2 = value.indexOf(s, p);\n\t\t\tif (p2 < 0) {\n\t\t\t\tif (msg == null) {\n\t\t\t\t\tmsg = \"expected '\" + s + \"' after \";\n\t\t\t\t\tif (p > 0) {\n\t\t\t\t\t\tvar cut = value.substr(0, p);\n\t\t\t\t\t\tif (cut.length > 30)\n\t\t\t\t\t\t\tcut = '...' + cut.substr( -27);\n\t\t\t\t\t\tmsg += \" '\" + cut + \"'\" ;\n\t\t\t\t\t} else\n\t\t\t\t\t\tmsg += \" begin\";\n\t\t\t\t}\n\t\t\t\tfail(msg, pos);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tp = p2 + s.length;\n\t\t}\n\t\tisTrue(true, msg, pos);\n\t}\n\n\t/**\n\t* Forces a failure.\n\t* @param msg: An optional error message. If not passed a default one will be used\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function fail(msg = \"failure expected\", ?pos : PosInfos)\n\t\tisTrue(false, msg, pos);\n\t/**\n\t* Creates a warning message.\n\t* @param msg: A mandatory message that justifies the warning.\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\n\t* unless you know what you are doing.\n\t*/\n\tpublic static function warn(msg)\n\t\tresults.add(Warning(msg));\n\n\t/**\n\t* Creates an asynchronous context for test execution. Assertions should be included\n\t* in the passed function.\n\t* <pre>\n\t* public function assertAsync() {\n\t*   var async = Assert.createAsync(function() Assert.isTrue(true));\n\t*   haxe.Timer.delay(async, 50);\n\t* }\n\t* @param f: A function that contains other Assert tests\n\t* @param timeout: Optional timeout value in milliseconds.\n\t*/\n\tpublic static dynamic function createAsync(?f : Void -> Void, ?timeout : Int)\n\t\treturn function(){};\n\t/**\n\t* Creates an asynchronous context for test execution of an event like method.\n\t* Assertions should be included in the passed function.\n\t* It works the same way as Assert.assertAsync() but accepts a function with one\n\t* argument (usually some event data) instead of a function with no arguments\n\t* @param f: A function that contains other Assert tests\n\t* @param timeout: Optional timeout value in milliseconds.\n\t*/\n\tpublic static dynamic function createEvent<EventArg>(f : EventArg -> Void, ?timeout : Int)\n\t\treturn function(e){};\n\n\tstatic function typeToString(t : Dynamic) {\n\t\ttry {\n\t\t\tvar _t = Type.getClass(t);\n\t\t\tif (_t != null)\n\t\t\t\tt = _t;\n\t\t} catch(e : Dynamic) { }\n\t\ttry return Type.getClassName(t) catch (e : Dynamic) { }\n\t\ttry {\n\t\t\tvar _t = Type.getEnum(t);\n\t\t\tif (_t != null)\n\t\t\t\tt = _t;\n\t\t} catch(e : Dynamic) { }\n\t\ttry return Type.getEnumName(t) catch(e : Dynamic) {}\n\t\ttry return Std.string(Type.typeof(t)) catch (e : Dynamic) { }\n\t\ttry return Std.string(t) catch (e : Dynamic) { }\n\t\treturn '<unable to retrieve type name>';\n\t}\n\n\tstatic function __init__() {\n\t\tfunction posToString(pos : haxe.PosInfos) return pos;\n\t\tresults = {\n\t\t\tadd : function(assertion : Assertion) {\n\t\t\t\tswitch assertion {\n\t\t\t\t\tcase Failure(msg, pos):\n\t\t\t\t\t\tthrow new Error(msg, null, pos);\n\t\t\t\t\tcase Error(e, stack), PreConditionError(e, stack), PostConditionError(e, stack):\n\t\t\t\t\t\tthrow new Error(Std.string(e), stack);\n\t\t\t\t\tcase Warning(msg):\n\t\t\t\t\t\ttrace(msg);\n\t\t\t\t\tcase Success(pos):\n\t\t\t\t\t\t// do nothing\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n}\n\nprivate typedef LikeStatus = {\n\trecursive : Bool,\n\tpath : String,\n\terror : String\n};","package thx;\n\nclass Timer {\n\tpublic inline static function setInterval(callback : Void -> Void, delay : Int) : TimerID\n\t\treturn untyped __js__('setInterval')(callback, delay);\n\n\tpublic inline static function setTimeout(callback : Void -> Void, delay : Int) : TimerID\n\t\treturn untyped __js__('setTimeout')(callback, delay);\n\n\tpublic inline static function setImmediate(callback : Void -> Void) : TimerID\n\t\treturn untyped __js__('setImmediate')(callback);\n\n\tpublic inline static function clearTimer(id : TimerID) : Void\n\t\treturn untyped __js__('clearTimeout')(id);\n\n\tstatic function __init__() untyped {\n\t\tvar scope : Dynamic = (window || __js__('this'));\n\t\tif(!scope.setImmediate)\n\t\t\tscope.setImmediate = function(callback) scope.setTimeout(callback, 0);\n\t}\n}\n\nextern\nclass TimerID {}\n\n/*\nlet immediate = require('immediate'),\n\tTimer = {\n\tdelay(ms, ƒ) {\n\t\tif(ƒ)\n\t\t\treturn setTimeout(ƒ, ms);\n\t\telse\n\t\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t},\n\timmediate(ƒ) {\n\t\tif(ƒ)\n\t\t\treturn immediate(ƒ);\n\t\telse\n\t\t\treturn new Promise((resolve) => immediate(resolve));\n\t},\n\tdebounce(ƒ, ms = 0) {\n\t\tlet tid, context, args, laterƒ;\n\t\treturn function() {\n\t\t\tcontext = this;\n\t\t\targs = arguments;\n\t\t\tlaterƒ = function() {\n\t\t\t\tif (!immediate) ƒ.apply(context, args);\n\t\t\t};\n\t\t\tclearTimeout(tid);\n\t\t\ttid = setTimeout(laterƒ, ms);\n\t\t};\n\t},\n\treduce(ƒ, ms = 0) {\n\t\tlet tid, context, args;\n\t\treturn function() {\n\t\t\tcontext = this;\n\t\t\targs = arguments;\n\t\t\tif(tid) return;\n\t\t\ttid = setTimeout(function() {\n\t\t\t\ttid = null;\n\t\t\t\tƒ.apply(context, args);\n\t\t\t}, ms);\n\t\t};\n\t}\n};\n\nexport default Timer;\n*/","/**\n * ...\n * @author Franco Ponticelli\n */\n\npackage thx.core;\n\nimport thx.core.Functions.Function in F;\n\n#if macro\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.ExprTools;\n#end\n\nclass Arrays {\n\tpublic static function same<T>(a : Array<T>, b : Array<T>, ?eq : T -> T -> Bool) {\n\t\tif(a == null || b == null || a.length != b.length) return false;\n\t\tif(null == eq) eq = F.equality;\n\t\tfor(i in 0...a.length)\n\t\t\tif(!eq(a[i], b[i]))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic static function cross<T>(a : Array<T>, b : Array<T>) {\n\t\tvar r = [];\n\t\tfor (va in a)\n\t\t\tfor (vb in b)\n\t\t\t\tr.push([va, vb]);\n\t\treturn r;\n\t}\n\n\tpublic static function crossMulti<T>(a : Array<Array<T>>) {\n\t\tvar acopy  = a.copy(),\n\t\t\tresult = acopy.shift().map(function(v) return [v]);\n\t\twhile (acopy.length > 0) {\n\t\t\tvar arr = acopy.shift(),\n\t\t\t\ttresult = result;\n\t\t\tresult = [];\n\t\t\tfor (v in arr) {\n\t\t\t\tfor (ar in tresult) {\n\t\t\t\t\tvar t = ar.copy();\n\t\t\t\t\tt.push(v);\n\t\t\t\t\tresult.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static function pushIf<T>(arr : Array<T>, cond : Bool, value : T) {\n\t\tif (cond)\n\t\t\tarr.push(value);\n\t\treturn arr;\n\t}\n\n\tpublic static function eachPair<TIn, TOut>(arr : Array<TIn>, handler : TIn -> TIn -> Bool)\n\t\tfor(i in 0...arr.length)\n\t\t\tfor(j in i...arr.length)\n\t\t\t\tif(!handler(arr[i], arr[j]))\n\t\t\t\t\treturn;\n\n\t#if js inline #end\n\tpublic static function mapi<TIn, TOut>(arr : Array<TIn>, handler : TIn -> Int -> TOut) : Array<TOut> {\n\t\t#if js\n\t\t\treturn (cast arr : { map : (TIn -> Int -> TOut) -> Array<TOut> }).map(handler);\n\t\t#else\n\t\t\tvar r = [];\n\t\t\tfor(i in 0...arr.length)\n\t\t\t\tr.push(handler(arr[i], i));\n\t\t\treturn r;\n\t\t#end\n\t}\n\n\tinline public static function flatMap<TIn, TOut>(arr : Array<TIn>, callback : TIn -> Array<TOut>) : Array<TOut>\n\t\treturn flatten(arr.map(callback));\n\n\t#if js inline #end\n\tpublic static function flatten<T>(arr : Array<Array<T>>) : Array<T>\n\t\t#if js\n\t\t\treturn untyped __js__('Array.prototype.concat.apply')([], arr);\n\t\t#else\n\t\t\treturn reduce(arr, function(acc : Array<T>, item) return acc.concat(item), []);\n\t\t#end\n\n\tinline public static function reduce<TItem, TAcc>(arr : Array<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc\n\t\t#if js\n\t\t\treturn untyped arr.reduce(callback, initial);\n\t\t#else\n\t\t\treturn Iterables.reduce(arr, callback, initial);\n\t\t#end\n\n\tinline public static function reducei<TItem, TAcc>(arr : Array<TItem>, callback : TAcc -> TItem -> Int -> TAcc, initial : TAcc) : TAcc\n\t\t#if js\n\t\t\treturn untyped arr.reduce(callback, initial);\n\t\t#else\n\t\t\treturn Iterables.reducei(arr, callback, initial);\n\t\t#end\n\n\tpublic static function order<T>(arr : Array<T>, sort : T -> T -> Int) {\n\t\tvar n = arr.copy();\n\t\tn.sort(sort);\n\t\treturn n;\n\t}\n\n\tinline public static function isEmpty<T>(arr : Array<T>) : Bool\n\t\treturn arr.length == 0;\n\n\tpublic static function contains<T>(arr : Array<T>, element : T, ?eq : T -> T -> Bool) : Bool {\n\t\tif(null == eq) {\n\t\t\treturn arr.indexOf(element) >= 0;\n\t\t} else {\n\t\t\tfor(i in 0...arr.length)\n\t\t\t\tif(eq(arr[i], element))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static function shuffle<T>(a : Array<T>) : Array<T> {\n\t\tvar t = Ints.range(a.length),\n\t\t\tarr = [];\n\t\twhile (t.length > 0) {\n\t\t\tvar pos = Std.random(t.length),\n\t\t\t\tindex = t[pos];\n\t\t\tt.splice(pos, 1);\n\t\t\tarr.push(a[index]);\n\t\t}\n\t\treturn arr;\n\t}\n\n\tpublic static function extract<T>(a : Array<T>, f : T -> Bool) : T {\n\t\tfor(i in 0...a.length) {\n\t\t\tif(f(a[i]))\n\t\t\t\treturn a.splice(i, 1)[0];\n\t\t}\n\t\treturn null;\n\t}\n\n\tmacro public static function mapField<T>(a : ExprOf<Array<T>>, field : Expr) {\n\t\tvar id = 'o.'+ExprTools.toString(field),\n\t\t\t\texpr = Context.parse(id, field.pos);\n\t\treturn macro $e{a}.map(function(o) return ${expr});\n\t}\n\n\tmacro public static function mapFieldi<T>(a : ExprOf<Array<T>>, field : Expr) {\n\t\tvar id = 'o.'+ExprTools.toString(field),\n\t\t\t\texpr = Context.parse(id, field.pos);\n\t\treturn macro thx.core.Arrays.mapi($e{a}, function(o, i) return ${expr});\n\t}\n}","package thx.core;\n\nclass Function0 {\n\tpublic static function noop() : Void {}\n\tpublic inline static function join(fa : Void -> Void, fb : Void -> Void)\n\t\treturn function() {\n\t\t\tfa();\n\t\t\tfb();\n\t\t}\n\n\tpublic inline static function once(f : Void -> Void)\n\t\treturn function() {\n\t\t\tf();\n\t\t\tf = function(){}\n\t\t};\n}\n\nclass Function1 {\n\tpublic static function noop<T>(_ : T) : Void {}\n\tpublic inline static function compose<TIn, TRet1, TRet2>(fa : TRet2 -> TRet1, fb : TIn -> TRet2)\n\t\treturn function(v : TIn) return fa(fb(v));\n\n\tpublic inline static function join<TIn>(fa : TIn -> Void, fb : TIn -> Void)\n\t\treturn function(v : TIn) {\n\t\t\tfa(v);\n\t\t\tfb(v);\n\t\t}\n}\n\nclass Function {\n\tpublic static function equality<T>(a : T, b : T) return a == b;\n}","/**\n * ...\n * @author Franco Ponticelli\n */\n\npackage thx.core;\n\nclass Ints {\n\tpublic static inline function clamp(v : Int, min : Int, max : Int) : Int\n\t\treturn v < min ? min : (v > max ? max : v);\n\n\tstatic var pattern_parse = ~/^[+-]?(\\d+|0x[0-9A-F]+)$/i;\n\tpublic static function canParse(s : String)\n\t\treturn pattern_parse.match(s);\n\n\tpublic inline static function min(a : Int, b : Int)\n\t\treturn a < b ? a : b;\n\n\tpublic inline static function max(a : Int, b : Int)\n\t\treturn a > b ? a : b;\n\n\t// TODO add proper octal/hex/exp support\n\tpublic static function parse(s : String) {\n\t\tif (s.substr(0, 1) == \"+\")\n\t\t\ts = s.substr(1);\n\t\treturn Std.parseInt(s);\n\t}\n\n\tpublic inline static function compare(a : Int, b : Int)\n\t\treturn a - b;\n\n\tpublic static function range(start : Int, ?stop : Int, step = 1) : Array<Int> {\n\t\tif (null == stop) {\n\t\t\tstop = start;\n\t\t\tstart = 0;\n\t\t}\n\t\tif ((stop - start) / step == Math.POSITIVE_INFINITY) throw \"infinite range\";\n\t\tvar range = [], i = -1, j;\n\t\tif (step < 0)\n\t\t\twhile ((j = start + step * ++i) > stop) range.push(j);\n\t\telse\n\t\t\twhile ((j = start + step * ++i) < stop) range.push(j);\n\t\treturn range;\n\t}\n}","package thx.core;\n\nclass Iterables {\n\tpublic inline static function map<T, S>(it : Iterable<T>, f : T -> S) : Array<S>\n\t\treturn Iterators.map(it.iterator(), f);\n\n\tpublic inline static function eachPair<TIn, TOut>(it : Iterable<TIn>, handler : TIn -> TIn -> Bool)\n\t\treturn Iterators.eachPair(it.iterator(), handler);\n\n\tpublic inline static function toArray<T>(it : Iterable<T>) : Array<T>\n\t\treturn Iterators.toArray(it.iterator());\n\n\tpublic inline static function order<T>(it : Iterable<T>, sort : T -> T -> Int) : Array<T>\n\t\treturn Iterators.order(it.iterator(), sort);\n\n\tpublic inline static function reduce<TItem, TAcc>(it : Iterable<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc\n\t\treturn Iterators.reduce(it.iterator(), callback, initial);\n\n\tpublic inline static function reducei<TItem, TAcc>(it : Iterable<TItem>, callback : TAcc -> TItem -> Int -> TAcc, initial : TAcc) : TAcc\n\t\treturn Iterators.reducei(it.iterator(), callback, initial);\n\n\tpublic inline static function isEmpty<T>(it : Iterable<T>) : Bool\n\t\treturn Iterators.isEmpty(it.iterator());\n\n\tpublic inline static function filter<T>(it : Iterable<T>, predicate : T -> Bool) : Array<T>\n\t\treturn Iterators.filter(it.iterator(), predicate);\n}","package thx.core;\n\nclass Iterators {\n\tpublic static function map<T, S>(it : Iterator<T>, f : T -> S) : Array<S> {\n\t\tvar acc = [];\n\t\tfor(v in it)\n\t\t\tacc.push(f(v));\n\t\treturn acc;\n\t}\n\n\tpublic static function mapi<T, S>(it : Iterator<T>, f : T -> Int -> S) : Array<S> {\n\t\tvar acc = [],\n\t\t\ti = 0;\n\t\tfor(v in it)\n\t\t\tacc.push(f(v, i++));\n\t\treturn acc;\n\t}\n\n\tpublic static function eachPair<TIn, TOut>(it : Iterator<TIn>, handler : TIn -> TIn -> Bool)\n\t\tArrays.eachPair(toArray(it), handler);\n\n\tpublic static function toArray<T>(it : Iterator<T>) : Array<T> {\n\t\tvar items = [];\n\t\tfor(item in it)\n\t\t\titems.push(item);\n\t\treturn items;\n\t}\n\n\tpublic static function order<T>(it : Iterator<T>, sort : T -> T -> Int) {\n\t\tvar n = Iterators.toArray(it);\n\t\tn.sort(sort);\n\t\treturn n;\n\t}\n\n\tpublic static function reduce<TItem, TAcc>(it : Iterator<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc {\n\t\tmap(it, function(v) initial = callback(initial, v));\n\t\treturn initial;\n\t}\n\n\tpublic static function reducei<TItem, TAcc>(it : Iterator<TItem>, callback : TAcc -> TItem -> Int -> TAcc, initial : TAcc) : TAcc {\n\t\tmapi(it, function(v, i) initial = callback(initial, v, i));\n\t\treturn initial;\n\t}\n\n\tinline public static function isEmpty<T>(it : Iterator<T>) : Bool\n\t\treturn !it.hasNext();\n\n\tpublic static function filter<TItem>(it : Iterator<TItem>, predicate : TItem -> Bool) : Array<TItem>\n\t\treturn reduce(it, function(acc : Array<TItem>, item) {\n\t\t\t\tif(predicate(item))\n\t\t\t\t\tacc.push(item);\n\t\t\t\treturn acc;\n\t\t\t}, []);\n}","package thx.core;\n\nclass Objects {\n\tinline public static function isEmpty(o : {})\n\t\treturn Reflect.fields(o).length == 0;\n}\n","package thx.core;\n\nimport haxe.ds.Option;\n\nclass Options {\n\tpublic static function toValue<T>(option : Option<T>) : Null<T>\n\t\treturn switch option {\n\t\t\tcase None: null;\n\t\t\tcase Some(v) : v;\n\t\t};\n\n\tpublic static function toBool<T>(option : Option<T>) : Bool\n\t\treturn switch option {\n\t\t\tcase None: false;\n\t\t\tcase Some(_) : true;\n\t\t};\n\n\tpublic static function toOption<T>(value : T) : Option<T>\n\t\treturn null == value ? None : Some(value);\n\n\tpublic static function equals<T>(a : Option<T>, b : Option<T>, ?eq : T -> T -> Bool)\n\t\treturn switch [a, b] {\n\t\t\tcase [None, None]: true;\n\t\t\tcase [Some(a), Some(b)]:\n\t\t\t\tif(null == eq)\n\t\t\t\t\teq = function(a, b) return a == b;\n\t\t\t\teq(a,b);\n\t\t\tcase [_, _]:\n\t\t\t\tfalse;\n\t\t};\n\n\tpublic static function equalsValue<T>(a : Option<T>, b : Null<T>, ?eq : T -> T -> Bool)\n\t\treturn equals(a, toOption(b));\n}","/**\n * ...\n * @author Franco Ponticelli\n */\n\npackage thx.core;\n\nclass Set<T> {\n\tpublic static function ofArray<T>(arr : Array<T>) : Set<T> {\n\t\tvar set = new Set();\n\t\tfor (item in arr)\n\t\t\tset.add(item);\n\t\treturn set;\n\t}\n\n\tpublic var length : Int;\n\tvar _v : Array<T>;\n\tpublic function new() {\n\t\t_v = [];\n\t\tlength = 0;\n\t}\n\n\tpublic function add(v : T) : Void {\n\t\t_v.remove(v);\n\t\t_v.push(v);\n\t\tlength = _v.length;\n\t}\n\n\tpublic function remove(v : T) : Bool {\n\t\tvar t = _v.remove(v);\n\t\tlength = _v.length;\n\t\treturn t;\n\t}\n\n\tpublic function exists(v : T) : Bool {\n\t\tfor (t in _v)\n\t\t\tif (t == v)\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tpublic function iterator()\n\t\treturn _v.iterator();\n\n\tpublic function array()\n\t\treturn _v.copy();\n\n\tpublic function toString()\n\t\treturn \"{\" + _v.join(\", \") + \"}\";\n}","package thx.core;\n\nusing StringTools;\n\nclass Strings {\n\tstatic var _reSplitWC = ~/(\\r\\n|\\n\\r|\\n|\\r)/g;\n\tstatic var _reReduceWS = ~/\\s+/;\n#if !php\n\tstatic var _reStripTags = ~/(<[a-z]+[^>\\/]*\\/?>|<\\/[a-z]+>)/i;\n#end\n\t// TODO, test me\n\tpublic static function upTo(value : String, searchFor : String) {\n\t\tvar pos = value.indexOf(searchFor);\n\t\tif (pos < 0)\n\t\t\treturn value;\n\t\telse\n\t\t\treturn value.substr(0, pos);\n\t}\n\n\t// TODO, test me\n\tpublic static function startFrom(value : String, searchFor : String) {\n\t\tvar pos = value.indexOf(searchFor);\n\t\tif (pos < 0)\n\t\t\treturn value;\n\t\telse\n\t\t\treturn value.substr(pos + searchFor.length);\n\t}\n\n\t// TODO, test me\n\tpublic static function rtrim(value : String, charlist : String) : String {\n#if php\n\t\treturn untyped __call__(\"rtrim\", value, charlist);\n#else\n\t\tvar len = value.length;\n\t\twhile (len > 0) {\n\t\t\tvar c = value.substr(len - 1, 1);\n\t\t\tif (charlist.indexOf(c) < 0)\n\t\t\t\tbreak;\n\t\t\tlen--;\n\t\t}\n\t\treturn value.substr(0, len);\n#end\n\t}\n\n\t// TODO, test me\n\tpublic static function ltrim(value : String, charlist : String) : String {\n#if php\n\t\treturn untyped __call__(\"ltrim\", value, charlist);\n#else\n\t\tvar start = 0;\n\t\twhile (start < value.length) {\n\t\t\tvar c = value.substr(start, 1);\n\t\t\tif (charlist.indexOf(c) < 0)\n\t\t\t\tbreak;\n\t\t\tstart++;\n\t\t}\n\t\treturn value.substr(start);\n#end\n\t}\n\n\tpublic static inline function trim(value : String, charlist : String) : String {\n#if php\n\t\treturn untyped __call__(\"trim\", value, charlist);\n#else\n\t\treturn rtrim(ltrim(value, charlist), charlist);\n#end\n\t}\n\n\tstatic var _reCollapse = ~/\\s+/g;\n\tpublic static function collapse(value : String)\n\t\treturn _reCollapse.replace(StringTools.trim(value), \" \");\n\n\tpublic static inline function ucfirst(value : String) : String\n\t\treturn (value == null ? null : value.charAt(0).toUpperCase() + value.substr(1));\n\n\tpublic static inline function lcfirst(value : String) : String\n\t\treturn (value == null ? null : value.charAt(0).toLowerCase() + value.substr(1));\n\n\tpublic static function empty(value : String)\n\t\treturn value == null || value == '';\n\n\tpublic static inline function isAlphaNum(value : String) : Bool\n#if php\n\t\treturn untyped __call__(\"ctype_alnum\", value);\n#else\n\t\treturn (value == null ? false : __alphaNumPattern.match(value));\n#end\n\n\tpublic static inline function digitsOnly(value : String) : Bool\n#if php\n\t\treturn untyped __call__(\"ctype_digit\", value);\n#else\n\t\treturn (value == null ? false : __digitsPattern.match(value));\n#end\n\n\tpublic static function ucwords(value : String) : String\n\t\treturn __ucwordsPattern.map(ucfirst(value), __upperMatch);\n\n\t/**\n\t * Like ucwords but uses only white spaces as boundaries\n\t */\n\tpublic static function ucwordsws(value : String) : String\n#if php\n\t\treturn untyped __call__(\"ucwords\", value);\n#else\n\t\treturn __ucwordswsPattern.map(ucfirst(value), __upperMatch);\n#end\n\n\tstatic function __upperMatch(re : EReg)\n\t\treturn re.matched(0).toUpperCase();\n\tstatic var __ucwordsPattern = new EReg('[^a-zA-Z]([a-z])', 'g');\n#if !php\n\tstatic var __ucwordswsPattern = new EReg('\\\\s[a-z]', 'g');\n\tstatic var __alphaNumPattern = new EReg('^[a-z0-9]+$', 'i');\n\tstatic var __digitsPattern = new EReg('^[0-9]+$', '');\n#end\n\n\t/**\n\t*  Replaces undescores with space, finds UC characters, turns them into LC and prepends them with a space.\n\t*  More than one UC in sequence is left untouched.\n\t**/\n\tpublic static function humanize(s : String)\n\t\treturn underscore(s).replace('_', ' ');\n\n\t// TO TEST\n\tpublic static function capitalize(s : String)\n\t\treturn s.substr(0, 1).toUpperCase() + s.substr(1);\n\n\t// TO TEST\n\tpublic static function succ(s : String)\n\t\treturn s.substr(0, -1) + String.fromCharCode(s.substr(-1).charCodeAt(0)+1);\n\n\t// TO TEST\n\tpublic static function underscore(s : String) {\n\t\ts = (~/::/g).replace(s, '/');\n\t\ts =\t(~/([A-Z]+)([A-Z][a-z])/g).replace(s, '$1_$2');\n\t\ts = (~/([a-z\\d])([A-Z])/g).replace(s, '$1_$2');\n\t\ts = (~/-/g).replace(s, '_');\n\t\treturn s.toLowerCase();\n\t}\n\n\tpublic static function dasherize(s : String)\n\t\treturn s.replace('_', '-');\n\n\tpublic static function repeat(s : String, times : Int) {\n\t\tvar b = [];\n\t\tfor(i in 0...times)\n\t\t\tb.push(s);\n\t\treturn b.join('');\n\t}\n\n\tpublic static function wrapColumns(s : String, columns = 78, indent = \"\", newline = \"\\n\") {\n\t\tvar parts = _reSplitWC.split(s),\n\t\t\tresult = [];\n\t\tfor(part in parts)\n\t\t\tresult.push(_wrapColumns(StringTools.trim(_reReduceWS.replace(part, \" \")), columns, indent, newline));\n\t\treturn result.join(newline);\n\t}\n\n\tstatic function _wrapColumns(s : String, columns : Int, indent : String, newline : String) {\n\t\tvar parts = [],\n\t\t\tpos = 0,\n\t\t\tlen = s.length,\n\t\t\tilen = indent.length;\n\t\tcolumns -= ilen;\n\t\twhile(true) {\n\t\t\tif(pos + columns >= len - ilen) {\n\t\t\t\tparts.push(s.substr(pos));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar i = 0;\n\t\t\twhile(!StringTools.isSpace(s, pos + columns - i) && i < columns)\n\t\t\t\ti++;\n\t\t\tif(i == columns) {\n\t\t\t\t// search ahead\n\t\t\t\ti = 0;\n\t\t\t\twhile(!StringTools.isSpace(s, pos + columns + i) && pos + columns + i < len)\n\t\t\t\t\ti++;\n\t\t\t\tparts.push(s.substr(pos, columns + i));\n\t\t\t\tpos += columns + i + 1;\n\t\t\t} else {\n\t\t\t\tparts.push(s.substr(pos, columns - i));\n\t\t\t\tpos += columns - i + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn indent + parts.join(newline + indent);\n\t}\n\n\tpublic static function stripTags(s : String) : String\n#if php\n\t\treturn untyped __call__(\"strip_tags\", s);\n#else\n\t\treturn _reStripTags.replace(s, \"\");\n#end\n\n\tpublic static function ellipsis(s : String, maxlen = 20, symbol = \"...\") {\n\t\tif (s.length > maxlen)\n\t\t\treturn s.substr(0, symbol.length > maxlen - symbol.length ? symbol.length : maxlen - symbol.length) + symbol;\n\t\telse\n\t\t\treturn s;\n\t}\n\n\tpublic static function compare(a : String, b : String) return a < b ? -1 : a > b ? 1 : 0;\n}","package thx.core;\n\n#if !js\nimport haxe.Timer in T;\n#end\n\nclass Timer {\n#if !js\n  static var timers = new Map<Int, haxe.Timer>();\n  static var _id = 0;\n  public static function repeat(callback : Void -> Void, delay : Int) : TimerID {\n    var id = _id++,\n        timer = new T(delay);\n    timer.run = callback;\n    timers.set(id, timer);\n    return id;\n  }\n\n  public static function delay(callback : Void -> Void, delay : Int) : TimerID {\n    var id = _id++,\n        timer = T.delay(function() {\n          callback();\n          clear(id);\n        }, delay);\n    timers.set(id, timer);\n    return id;\n  }\n\n  public static function immediate(callback : Void -> Void) : TimerID\n    return delay(callback, 0);\n\n  public static function clear(id : TimerID) : Void {\n    var timer = timers.get(id);\n    if(null != timer) {\n      timers.remove(id);\n      timer.stop();\n    }\n  }\n\n#else\n  public inline static function repeat(callback : Void -> Void, delay : Int) : TimerID\n    return untyped __js__('setInterval')(callback, delay);\n\n  public inline static function delay(callback : Void -> Void, delay : Int) : TimerID\n    return untyped __js__('setTimeout')(callback, delay);\n\n  public inline static function immediate(callback : Void -> Void) : TimerID\n    return untyped __js__('setImmediate')(callback);\n\n  public inline static function clear(id : TimerID) : Void\n    return untyped __js__('clearTimeout')(id);\n\n  static function __init__() untyped {\n    var scope : Dynamic = __js__('(\"undefined\" !== typeof window && window) || (\"undefined\" !== typeof global && global) || this');\n    if(!scope.setImmediate)\n      scope.setImmediate = function(callback) scope.setTimeout(callback, 0);\n  }\n#end\n}\n\n#if !js\ntypedef TimerID = Int;\n#else\nextern\nclass TimerID {}\n#end","package thx.core;\n\nabstract Tuple0(Nil) {\n\tinline public function new()\n\t\tthis = nil;\n\n\tinline public function toTuple1<T0>(v : T0)\n\t\treturn new Tuple1(v);\n\n\tinline public function toString()\n\t\treturn 'Tuple0()';\n\n\t@:to inline public function toNil()\n\t\treturn this;\n\n\t@:from inline static public function nilToTuple(v : Nil)\n\t\treturn new Tuple0();\n}\n\nabstract Tuple1<T0>(T0) {\n\tinline public function new(_0 : T0)\n\t\tthis = _0;\n\tpublic var _0(get, never) : T0;\n\tinline function get__0() return this;\n\n\tinline public function toTuple2<T1>(v : T1)\n\t\treturn new Tuple2(_0, v);\n\n\tinline public function toString()\n\t\treturn 'Tuple1($_0)';\n}\n\nabstract Tuple2<T0, T1>({ _0 : T0, _1 : T1 }) {\n\tinline public function new(_0 : T0, _1 : T1)\n\t\tthis = { _0 : _0, _1 : _1 };\n\tpublic var _0(get, never) : T0;\n\tpublic var _1(get, never) : T1;\n\tinline function get__0() return this._0;\n\tinline function get__1() return this._1;\n\n\tinline public function toTuple3<T2>(v : T2)\n\t\treturn new Tuple3(_0, _1, v);\n\n\tinline public function toString()\n\t\treturn 'Tuple2($_0,$_1)';\n}\n\nabstract Tuple3<T0, T1, T2>({ _0 : T0, _1 : T1, _2 : T2 }) {\n\tinline public function new(_0 : T0, _1 : T1, _2 : T2)\n\t\tthis = { _0 : _0, _1 : _1, _2 : _2 };\n\tpublic var _0(get, never) : T0;\n\tpublic var _1(get, never) : T1;\n\tpublic var _2(get, never) : T2;\n\tinline function get__0() return this._0;\n\tinline function get__1() return this._1;\n\tinline function get__2() return this._2;\n\n\tinline public function toTuple4<T3>(v : T3)\n\t\treturn new Tuple4(_0, _1, _2, v);\n\n\tinline public function toString()\n\t\treturn 'Tuple3($_0,$_1,$_2)';\n}\n\nabstract Tuple4<T0, T1, T2, T3>({ _0 : T0, _1 : T1, _2 : T2, _3 : T3 }) {\n\tinline public function new(_0 : T0, _1 : T1, _2 : T2, _3 : T3)\n\t\tthis = { _0 : _0, _1 : _1, _2 : _2, _3 : _3 };\n\tpublic var _0(get, never) : T0;\n\tpublic var _1(get, never) : T1;\n\tpublic var _2(get, never) : T2;\n\tpublic var _3(get, never) : T3;\n\tinline function get__0() return this._0;\n\tinline function get__1() return this._1;\n\tinline function get__2() return this._2;\n\tinline function get__3() return this._3;\n\n\tinline public function toTuple5<T4>(v : T4)\n\t\treturn new Tuple5(_0, _1, _2, _3, v);\n\n\tinline public function toString()\n\t\treturn 'Tuple4($_0,$_1,$_2,$_3)';\n}\n\nabstract Tuple5<T0, T1, T2, T3, T4>({ _0 : T0, _1 : T1, _2 : T2, _3 : T3, _4 : T4 }) {\n\tinline public function new(_0 : T0, _1 : T1, _2 : T2, _3 : T3, _4 : T4)\n\t\tthis = { _0 : _0, _1 : _1, _2 : _2, _3 : _3, _4 : _4 };\n\tpublic var _0(get, never) : T0;\n\tpublic var _1(get, never) : T1;\n\tpublic var _2(get, never) : T2;\n\tpublic var _3(get, never) : T3;\n\tpublic var _4(get, never) : T4;\n\tinline function get__0() return this._0;\n\tinline function get__1() return this._1;\n\tinline function get__2() return this._2;\n\tinline function get__3() return this._3;\n\tinline function get__4() return this._4;\n\n\tinline public function toTuple6<T5>(v : T5)\n\t\treturn new Tuple6(_0, _1, _2, _3, _4, v);\n\n\tinline public function toString()\n\t\treturn 'Tuple5($_0,$_1,$_2,$_3,$_4)';\n}\n\nabstract Tuple6<T0, T1, T2, T3, T4, T5>({ _0 : T0, _1 : T1, _2 : T2, _3 : T3, _4 : T4, _5 : T5 }) {\n\tinline public function new(_0 : T0, _1 : T1, _2 : T2, _3 : T3, _4 : T4, _5 : T5)\n\t\tthis = { _0 : _0, _1 : _1, _2 : _2, _3 : _3, _4 : _4, _5 : _5 };\n\tpublic var _0(get, never) : T0;\n\tpublic var _1(get, never) : T1;\n\tpublic var _2(get, never) : T2;\n\tpublic var _3(get, never) : T3;\n\tpublic var _4(get, never) : T4;\n\tpublic var _5(get, never) : T5;\n\tinline function get__0() return this._0;\n\tinline function get__1() return this._1;\n\tinline function get__2() return this._2;\n\tinline function get__3() return this._3;\n\tinline function get__4() return this._4;\n\tinline function get__5() return this._5;\n\n\tinline public function toString()\n\t\treturn 'Tuple6($_0,$_1,$_2,$_3,$_4,$_5)';\n}","/**\n * ...\n * @author Franco Ponticelli\n */\n\npackage thx.core;\n\nclass Types {\n\tpublic static inline function isAnonymousObject(v : Dynamic) : Bool\n\t\treturn Reflect.isObject(v) && null == Type.getClass(v);\n\n\tpublic static function sameType<A, B>(a : A, b : B) : Bool\n\t\treturn ValueTypes.toString(Type.typeof(a)) == ValueTypes.toString(Type.typeof(b));\n}\n\nclass ClassTypes {\n\tpublic inline static function toString(cls : Class<Dynamic>)\n\t\treturn Type.getClassName(cls);\n\n\tstatic public #if !php inline #end function as<T1, T2>(value : T1, type : Class<T2>) : Null<T2>\n\t\treturn (Std.is(value, type) ? cast value : null);\n}\n\nclass ValueTypes {\n\tpublic static function typeAsString<T>(value : T)\n\t\treturn toString(Type.typeof(value));\n\n\tpublic static function toString(type : Type.ValueType) {\n\t\treturn switch type {\n\t\t\tcase TInt:      \"Int\";\n\t\t\tcase TFloat:    \"Float\";\n\t\t\tcase TBool:     \"Bool\";\n\t\t\tcase TObject:   \"Dynamic\"; // TODO ?\n\t\t\tcase TFunction: \"Function\";\n\t\t\tcase TClass(c): Type.getClassName(c);\n\t\t\tcase TEnum(e):  Type.getEnumName(e);\n\t\t\tcase _:         null;\n\t\t}\n\t}\n\n\tpublic static function typeInheritance(type : Type.ValueType) {\n\t\treturn switch type {\n\t\t\tcase TInt:      [\"Int\"];\n\t\t\tcase TFloat:    [\"Float\"];\n\t\t\tcase TBool:     [\"Bool\"];\n\t\t\tcase TObject:   [\"Dynamic\"];\n\t\t\tcase TFunction: [\"Function\"];\n\t\t\tcase TClass(c):\n\t\t\t\tvar classes = [];\n\t\t\t\twhile (null != c) {\n\t\t\t\t\tclasses.push(c);\n\t\t\t\t\tc = Type.getSuperClass(c);\n\t\t\t\t}\n\t\t\t\tclasses.map(Type.getClassName);\n\t\t\tcase TEnum(e):  [Type.getEnumName(e)];\n\t\t\tcase _:         null;\n\t\t}\n\t}\n}","package thx.core;\n\nclass UUID {\n\tstatic var itoh = '0123456789ABCDEF';\n\n\tstatic inline function random()\n\t\treturn Math.floor(Math.random()*0x10);\n\n\tstatic inline function srandom()\n\t\treturn ''+random();\n\n\tpublic static function create() {\n\t\tvar s = [];\n\t\tfor(i in 0...8)\n\t\t\ts[i] = srandom();\n\t\ts[8]  = '-';\n\t\tfor(i in 9...13)\n\t\t\ts[i] = srandom();\n\t\ts[13] = '-';\n\t\ts[14] = '4';\n\t\tfor(i in 15...18)\n\t\t\ts[i] = srandom();\n\t\ts[18] = '-';\n\t\ts[19] = '' + ((random() & 0x3) | 0x8);\n\t\tfor(i in 20...23)\n\t\t\ts[i] = srandom();\n\t\ts[23] = '-';\n\t\tfor(i in 24...36)\n\t\t\ts[i] = srandom();\n\t\treturn s.join('');\n\t}\n}","package thx.promise;\n\nimport thx.core.Error;\nimport thx.promise.Promise;\n\n@:access(thx.promise.Promise)\nclass Deferred<T> {\n  public var promise(default, null) : Promise<T>;\n  public function new()\n    promise = new Promise<T>();\n\n  public function rejectWith(error : Dynamic)\n    return fulfill(Failure(Error.fromDynamic(error)));\n  public function reject(error : Error)\n    return fulfill(Failure(error));\n  public function resolve(value : T)\n    return fulfill(Success(value));\n  public function fulfill(result : PromiseValue<T>)\n    return promise.setState(result);\n\n  public function toString() return 'Deferred';\n}","package thx.promise;\n\nimport haxe.ds.Option;\nimport thx.core.Error;\nimport thx.core.Tuple;\nimport thx.core.Nil;\nusing thx.core.Options;\nusing thx.core.Arrays;\n\nclass Promise<T> {\n  public static var nil(default, null) : Promise<Nil> = Promise.value(Nil.nil);\n\n  public static function create<T>(callback : (T -> Void) -> (Error -> Void) -> Void) : Promise<T> {\n    var deferred = new Deferred<T>();\n    callback(deferred.resolve, deferred.reject);\n    return deferred.promise;\n  }\n\n  public static function fulfilled<T>(callback : (PromiseValue<T> -> Void) -> Void) : Promise<T> {\n    var deferred = new Deferred<T>();\n    callback(deferred.fulfill);\n    return deferred.promise;\n  }\n\n  public static function all<T>(arr : Array<Promise<T>>) : Promise<Array<T>>\n    return Promise.create(function(resolve, reject) {\n      var results  = [],\n          counter  = 0,\n          hasError = false;\n      arr.mapi(function(p, i) {\n        p.either(function(value) {\n          if(hasError) return;\n          results[i] = value;\n          counter++;\n          if(counter == arr.length)\n            resolve(results);\n        }, function(err) {\n          if(hasError) return;\n          hasError = true;\n          reject(err);\n        });\n      });\n    });\n\n  public static function value<T>(v : T) : Promise<T>\n    return Promise.create(function(resolve, _) resolve(v));\n\n  public static function error<T>(err : Error) : Promise<T>\n    return Promise.create(function(_, reject) reject(err));\n\n  var handlers : Array<PromiseValue<T> -> Void>;\n  var state : Option<PromiseValue<T>>;\n  private function new() {\n    handlers = [];\n    state = None;\n  }\n\n  public function then(handler : PromiseValue<T> -> Void) {\n    handlers.push(handler);\n    update();\n    return this;\n  }\n\n  public function either(success : T -> Void, failure : Error -> Void) {\n    then(function(r) switch r {\n      case Success(value): success(value);\n      case Failure(error): failure(error);\n    });\n    return this;\n  }\n\n  public function success(success : T -> Void)\n    return either(success, function(_){});\n\n  public function failure(failure : Error -> Void)\n    return either(function(_){}, failure);\n\n  public function throwFailure()\n    return failure(function(err) {\n      throw err;\n    });\n\n  public function map<TOut>(handler : PromiseValue<T> -> Promise<TOut>)\n    return Promise.fulfilled(function(fulfill)\n      then(function(result) handler(result).then(fulfill))\n    );\n\n  public function mapEither<TOut>(success : T -> Promise<TOut>, failure : Error -> Promise<TOut>)\n    return map(function(result) return switch result {\n        case Success(value): success(value);\n        case Failure(error): failure(error);\n      });\n\n  public function mapSuccess<TOut>(success : T -> Promise<TOut>)\n    return mapEither(success, function(err) return Promise.error(err));\n\n  public function mapFailure(failure : Error -> Promise<T>)\n    return mapEither(function(value : T) return Promise.value(value), failure);\n\n  public function always(handler : Void -> Void)\n    then(function(_) handler());\n\n  public function mapAlways<TOut>(handler : Void -> Promise<TOut>)\n    map(function(_) return handler());\n\n  public function isResolved()\n    return switch state {\n      case None, Some(Failure(_)): false;\n      case _: true;\n    };\n\n  public function isFailure()\n    return switch state {\n      case None, Some(Success(_)): false;\n      case _: true;\n    };\n\n  public function isComplete()\n    return switch state { case None: false; case Some(_): true; };\n\n  public function toString() return 'Promise';\n\n  function setState(newstate : PromiseValue<T>) {\n    switch state {\n      case None:\n        state = Some(newstate);\n      case Some(r):\n        throw new Error('promise was already $r, can\\'t apply new state $newstate');\n    }\n    update();\n    return this;\n  }\n\n  function update()\n    switch state {\n      case None:\n      case Some(result): {\n        var handler;\n        while(null != (handler = handlers.shift()))\n          handler(result);\n      }\n    };\n}\n\nclass Promises {\n  public static function log<T>(promise : Promise<T>, ?prefix : String = '')\n    return promise.either(\n      function(r) trace('$prefix SUCCESS: $r'),\n      function(e) trace('$prefix ERROR: ${e.toString()}')\n    );\n\n  public static function delay<T>(p : Promise<T>, ?interval : Int) : Promise<T>\n    return p.map(\n      function(r)\n        return Promise.fulfilled(\n          null == interval ?\n            function(fulfill) thx.core.Timer.immediate(fulfill.bind(r)) :\n            function(fulfill) thx.core.Timer.delay(fulfill.bind(r), interval)\n        )\n    );\n\n  public static function join<T1,T2>(p1 : Promise<T1>, p2 : Promise<T2>) : Promise<Tuple2<T1,T2>> {\n    return Promise.create(function(resolve, reject) {\n      var hasError = false,\n        counter = 0,\n        v1 : Null<T1> = null,\n        v2 : Null<T2> = null;\n\n      function complete() {\n        if(counter < 2)\n          return;\n        resolve(new Tuple2(v1, v2));\n      }\n\n      function handleError(error) {\n        if(hasError) return;\n        hasError = true;\n        reject(error);\n      }\n\n      p1.either(function(v) {\n        if(hasError) return;\n        counter++;\n        v1 = v;\n        complete();\n      }, handleError);\n\n      p2.either(function(v) {\n        if(hasError) return;\n        counter++;\n        v2 = v;\n        complete();\n      }, handleError);\n    });\n  }\n}\n\nclass PromiseTuple6 {\n  public static function mapTuple<T1,T2,T3,T4,T5,T6,TOut>(promise : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> Promise<TOut>) : Promise<TOut>\n    return promise.mapSuccess(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4, t._5)\n    );\n\n  public static function tuple<T1,T2,T3,T4,T5,T6>(promise : Promise<Tuple6<T1,T2,T3,T4,T5,T6>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> T6 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2, t._3, t._4, t._5),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple5 {\n  public static function join<T1,T2,T3,T4,T5,T6>(p1 : Promise<Tuple5<T1,T2,T3,T4,T5>>, p2 : Promise<T6>) : Promise<Tuple6<T1,T2,T3,T4,T5,T6>> {\n    return Promise.create(function(resolve, reject) {\n      Promises.join(p1, p2)\n        .either(\n          function(t) resolve(t._0.toTuple6(t._1)),\n          function(e) reject(e));\n    });\n  }\n\n  public static function mapTuple<T1,T2,T3,T4,T5,TOut>(promise : Promise<Tuple5<T1,T2,T3,T4,T5>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> Promise<TOut>) : Promise<TOut>\n    return promise.mapSuccess(function(t)\n      return success(t._0, t._1, t._2, t._3, t._4)\n    );\n\n  public static function tuple<T1,T2,T3,T4,T5>(promise : Promise<Tuple5<T1,T2,T3,T4,T5>>, success : T1 -> T2 -> T3 -> T4 -> T5 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2, t._3, t._4),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple4 {\n  public static function join<T1,T2,T3,T4,T5>(p1 : Promise<Tuple4<T1,T2,T3,T4>>, p2 : Promise<T5>) : Promise<Tuple5<T1,T2,T3,T4,T5>> {\n    return Promise.create(function(resolve, reject) {\n      Promises.join(p1, p2)\n        .either(\n          function(t) resolve(t._0.toTuple5(t._1)),\n          function(e) reject(e));\n    });\n  }\n\n  public static function mapTuple<T1,T2,T3,T4,TOut>(promise : Promise<Tuple4<T1,T2,T3,T4>>, success : T1 -> T2 -> T3 -> T4 -> Promise<TOut>) : Promise<TOut>\n    return promise.mapSuccess(function(t)\n      return success(t._0, t._1, t._2, t._3)\n    );\n\n  public static function tuple<T1,T2,T3,T4>(promise : Promise<Tuple4<T1,T2,T3,T4>>, success : T1 -> T2 -> T3 -> T4 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2, t._3),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple3 {\n  public static function join<T1,T2,T3,T4>(p1 : Promise<Tuple3<T1,T2,T3>>, p2 : Promise<T4>) : Promise<Tuple4<T1,T2,T3,T4>> {\n    return Promise.create(function(resolve, reject) {\n      Promises.join(p1, p2)\n        .either(\n          function(t) resolve(t._0.toTuple4(t._1)),\n          function(e) reject(e));\n    });\n  }\n\n  public static function mapTuple<T1,T2,T3,TOut>(promise : Promise<Tuple3<T1,T2,T3>>, success : T1 -> T2 -> T3 -> Promise<TOut>) : Promise<TOut>\n    return promise.mapSuccess(function(t)\n      return success(t._0, t._1, t._2)\n    );\n\n  public static function tuple<T1,T2,T3>(promise : Promise<Tuple3<T1,T2,T3>>, success : T1 -> T2 -> T3 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1, t._2),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseTuple2 {\n  public static function join<T1,T2,T3>(p1 : Promise<Tuple2<T1,T2>>, p2 : Promise<T3>) : Promise<Tuple3<T1,T2,T3>> {\n    return Promise.create(function(resolve, reject) {\n      Promises.join(p1, p2)\n        .either(\n          function(t) resolve(t._0.toTuple3(t._1)),\n          function(e) reject(e));\n    });\n  }\n\n  public static function mapTuple<T1,T2,TOut>(promise : Promise<Tuple2<T1,T2>>, success : T1 -> T2 -> Promise<TOut>) : Promise<TOut>\n    return promise.mapSuccess(function(t)\n      return success(t._0, t._1)\n    );\n\n  public static function tuple<T1,T2>(promise : Promise<Tuple2<T1,T2>>, success : T1 -> T2 -> Void, ?failure : Error -> Void)\n    return promise.either(\n      function(t) success(t._0, t._1),\n      null == failure ? function(_) {} : failure\n    );\n}\n\nclass PromiseNil {\n  public static function join<T2>(p1 : Promise<Nil>, p2 : Promise<T2>) : Promise<T2>\n    return Promise.create(function(resolve, reject) {\n      Promises.join(p1, p2)\n        .either(\n          function(t) resolve(t._1),\n          function(e) reject(e));\n    });\n}","package thx.ref;\n\nclass BaseRef {\n  public var parent(default, null) : IParentRef;\n  public function new(?parent : IParentRef) {\n    this.parent = null != parent ? parent : EmptyParent.instance;\n  }\n\n  public function getRoot() : IRef {\n    var ref : IRef = cast this;\n    while(!Std.is(ref.parent, BaseRef.EmptyParent))\n      ref = cast ref.parent;\n    return ref;\n  }\n}\n\nclass EmptyParent implements IParentRef {\n  public static var instance(default, null) : IParentRef = new EmptyParent();\n\n  function new() {}\n\n  public function removeChild(child : IRef) { }\n}","package thx.ref;\n\nusing thx.core.Iterators;\nusing thx.core.Arrays;\nusing thx.core.Ints;\n\nclass ArrayRef extends BaseRef implements IRef implements IParentRef {\n  var items : Map<Int, IRef>;\n  var inverse : Map<IRef, Int>;\n\n  public function new(?parent : IParentRef) {\n    super(parent);\n    items   = new Map();\n    inverse = new Map();\n  }\n\n  public function get() {\n    var res = [];\n    items\n      .keys()\n      .toArray()\n      .order(Ints.compare)\n      .map(function(i) return items.get(i))\n      .map(function(ref) {\n        if(ref.hasValue())\n          res.push(ref.get());\n      });\n    return res;\n  }\n\n  public function set(value : Dynamic) {\n    if(!Std.is(value, Array)) throw 'value \"$value\" is not an array';\n\n    (value : Array<Dynamic>).mapi(function(v, i) {\n      var ref = items.get(i);\n      if(null == ref) {\n        items.set(i, ref = Ref.fromValue(v, this));\n        inverse.set(ref, i);\n      } else {\n        ref.set(v);\n      }\n    });\n  }\n\n  public function remove() {\n    for(ref in items) {\n      ref.remove();\n    }\n    parent.removeChild(this);\n  }\n\n  public function removeChild(child : IRef) : Void {\n    var i = inverse.get(child);\n    if(null == i) throw '\"$child\" is not child of \"$this\"';\n    items.remove(i);\n    inverse.remove(child);\n  }\n\n  public function hasValue() {\n    for(ref in items)\n      if(ref.hasValue())\n        return true;\n    return false;\n  }\n\n  public function resolve(path : String, terminal : Bool = true) : IRef {\n    if(path == \"\") return this;\n    if(!Ref.reIndex.match(path))\n      throw 'unable to resolve \"$path\" for ArrayRef';\n    var index = Std.parseInt(Ref.reIndex.matched(1)),\n      rest  = Ref.reIndex.matchedRight(),\n      ref   = items.get(index);\n    if(null == ref) {\n      items.set(index, ref = Ref.fromPath(rest, this, terminal));\n      inverse.set(ref, index);\n    }\n    return ref.resolve(rest, terminal);\n  }\n}","package thx.ref;\n\nusing thx.core.Iterators;\nusing thx.core.Iterables;\nimport thx.core.Types;\n\nclass ObjectRef extends BaseRef implements IRef implements IParentRef {\n  var fields : Map<String, IRef>;\n  var inverse : Map<IRef, String>;\n\n  public function new(?parent : IParentRef) {\n    super(parent);\n    fields = new Map();\n    inverse = new Map();\n  }\n\n  public function get() : Dynamic {\n    var o = {};\n    fields.keys().map(function(key) {\n      var ref = fields.get(key);\n      if(!ref.hasValue()) return;\n      Reflect.setField(o, key, ref.get());\n    });\n    return o;\n  }\n\n  public function set(obj : Dynamic) {\n    if(!Types.isAnonymousObject(obj)) throw 'object \"$obj\" is not an anonymous object';\n    Reflect.fields(obj).map(function(field) {\n      var ref   = fields.get(field),\n        value = Reflect.field(obj, field);\n      if(null == ref) {\n        ref = Ref.fromValue(value, this);\n        fields.set(field, ref);\n        inverse.set(ref, field);\n      } else {\n        ref.set(value);\n      }\n    });\n  }\n\n  public function hasValue() {\n    for(ref in fields)\n      if(ref.hasValue())\n        return true;\n    return false;\n  }\n\n  public function remove() {\n    fields.map(function(ref) ref.remove());\n    parent.removeChild(this);\n  }\n\n  public function removeChild(child : IRef) {\n    var key = inverse.get(child);\n    if(null == key) throw '\"$child\" is not child of \"$this\"';\n    inverse.remove(child);\n    fields.remove(key);\n  }\n\n  public function resolve(path : String, terminal : Bool = true) : IRef {\n    if(path == \"\") return this;\n    if(!Ref.reField.match(path))\n      throw 'unable to resolve \"$path\" for ObjectRef';\n    var field = Ref.reField.matched(1),\n      rest  = Ref.reField.matchedRight(),\n      ref   = fields.get(field);\n    if(null == ref) {\n      fields.set(field, ref = Ref.fromPath(rest, this, terminal));\n      inverse.set(ref, field);\n    }\n    return ref.resolve(rest, terminal);\n  }\n}","package thx.ref;\n\nusing thx.core.Types;\n\nclass Ref {\n  public static function fromValue(value : Dynamic, ?parent : IParentRef) : IRef {\n    if(null == parent)\n      parent = BaseRef.EmptyParent.instance;\n    var ref : IRef = if(Std.is(value, Array)) {\n        new ArrayRef(parent);\n      } else if(Types.isAnonymousObject(value)) {\n        new ObjectRef(parent);\n      } else {\n        new ValueRef(parent);\n      }\n    ref.set(value);\n    return ref;\n  }\n\n  public static var reField = ~/^\\.?([^.\\[]+)/;\n  public static var reIndex = ~/^\\[(\\d+)\\]/;\n  public static function fromPath(path : String, ?parent : IParentRef, terminal : Bool = true) : IRef {\n    if(null == parent)\n      parent = BaseRef.EmptyParent.instance;\n    if(path == \"\") {\n      return terminal ? new ValueRef(parent) : new UnknownRef(parent);\n    } else if(reField.match(path)) {\n      return new ObjectRef(parent);\n    } else if(reIndex.match(path)) {\n      return new ArrayRef(parent);\n    } else {\n      return throw 'invalid path \"$path\"';\n    }\n  }\n\n  public static function resolvePath(path : String, ?parent : IParentRef, terminal : Bool = true) : IRef {\n    var ref = fromPath(path, parent, terminal);\n    return ref.resolve(path);\n  }\n}","package thx.ref;\n\nusing thx.core.Objects;\nusing thx.core.Arrays;\n\nclass UnknownRef extends BaseRef implements IRef implements IParentRef {\n  public var ref(default, null) : Null<IRef>;\n  var hasRef : Bool = false;\n\n  public function get()\n    return hasRef ? ref.get() : null;\n\n  public function set(value : Dynamic) {\n    if(hasRef)\n      ref.set(value);\n    else {\n      hasRef = true;\n      ref = Ref.fromValue(value, this);\n    }\n  }\n\n  public function remove() : Void {\n    if(hasRef)\n      ref.remove();\n    parent.removeChild(this);\n  }\n\n  public function removeChild(child : IRef) : Void {\n    if(hasRef) {\n      ref = null;\n      hasRef = false;\n    }\n  }\n\n  public function hasValue() : Bool\n    return hasRef && ref.hasValue();\n\n  public function resolve(path : String, terminal : Bool = true) : IRef {\n    if(hasRef)\n      return ref.resolve(path, terminal);\n    if(path == \"\")\n      return this;\n    hasRef = true;\n    ref = Ref.fromPath(path, this, terminal);\n    return ref.resolve(path, terminal);\n  }\n}","package thx.ref;\n\nusing thx.core.Objects;\nusing thx.core.Arrays;\n\nclass ValueRef extends BaseRef implements IRef {\n  var _hasValue : Bool = false;\n  var value : Dynamic;\n\n  public function get()\n    return value;\n\n  public function set(value : Dynamic) {\n    this.value = value;\n    _hasValue = true;\n  }\n\n  public function remove() : Void {\n    value = null;\n    _hasValue = false;\n    parent.removeChild(this);\n  }\n\n  public function hasValue() : Bool\n    return _hasValue;\n\n  public function resolve(path : String, terminal : Bool = true) : IRef {\n    if(path != \"\") throw 'unable to resolve path \"$path\" on ValueRef';\n    return this;\n  }\n}","package thx.stream;\n\nimport haxe.ds.Option;\nimport thx.core.Error;\nimport thx.core.Nil;\nimport thx.core.Timer in T;\nimport thx.promise.Promise;\nusing thx.core.Options;\nusing thx.core.Tuple;\n\nclass Emitter<T> {\n  public static function create<T>(init : Stream<T> -> Void) : Emitter<T> {\n    return new Emitter(init);\n  }\n\n  var init : Stream<T> -> Void;\n  function new(init : Stream<T> -> Void) {\n    this.init = init;\n  }\n\n  public function sign(subscriber : StreamValue<T> -> Void) : IStream {\n    var stream = new Stream(subscriber);\n    init(stream);\n    return stream;\n  }\n\n  public function subscribe(?pulse : T -> Void, ?fail : Error -> Void, ?end : Bool -> Void) : IStream {\n    pulse = null != pulse ? pulse : function(_) {};\n    fail = null != fail ? fail : function(_) {};\n    end = null != end ? end : function(_) {};\n    var stream = new Stream(function(r) switch r {\n      case Pulse(v): pulse(v);\n      case Failure(e): fail(e);\n      case End(c): end(c);\n    });\n    init(stream);\n    return stream;\n  }\n\n  @:access(thx.stream.Value)\n  @:access(thx.stream.Stream)\n  public function feed(value : Value<T>) : IStream {\n    var stream : Stream<T> = new Stream(null);\n    stream.subscriber = function(r) switch r {\n      case Pulse(v): value.set(v);\n      case Failure(e): stream.fail(e);\n      case End(c): if(c) stream.cancel() else stream.end();\n    };\n    value.upStreams.push(stream);\n    stream.addCleanUp(function() value.upStreams.remove(stream));\n    init(stream);\n    return stream;\n  }\n\n  public function delay(time : Int)\n    return new Emitter(function(stream) {\n      var id = T.delay(function() init(stream), time);\n      stream.addCleanUp(T.clear.bind(id));\n    });\n\n  public function map<TOut>(f : T -> Promise<TOut>) : Emitter<TOut>\n    return new Emitter(function(stream) {\n      init(new Stream(function(r) {\n        switch r {\n        case Pulse(v):\n          f(v).either(\n            function(vout) stream.pulse(vout),\n            function(err)  stream.fail(err)\n          );\n        case Failure(e):   stream.fail(e);\n        case End(true):    stream.cancel();\n        case End(false):   stream.end();\n      }}));\n    });\n\n  public function mapValue<TOut>(f : T -> TOut) : Emitter<TOut>\n    return map(function(v) return Promise.value(f(v)));\n\n  // TODO ... have a look at those nasty instream\n  public function takeUntil(f : T -> Promise<Bool>) : Emitter<T>\n    return new Emitter(function(stream) {\n      var instream : Stream<T> = null;\n      instream = new Stream(function(r : StreamValue<T>) switch r {\n        case Pulse(v):\n          f(v).either(\n            function(c : Bool) if(c) {\n              stream.pulse(v);\n            } else {\n              instream.end();\n              stream.end();\n            },\n            stream.fail\n          );\n        case Failure(e):\n          instream.fail(e);\n          stream.fail(e);\n        case End(true):\n          instream.cancel();\n          stream.cancel();\n        case End(false):\n          instream.end();\n          stream.end();\n      });\n      this.init(instream);\n    });\n\n  public function take(count : Int)\n    return takeUntil({\n      var counter = 0;\n      function(_) return Promise.value(counter++ < count);\n    });\n\n  public function audit(handler : T -> Void) : Emitter<T>\n    return mapValue(function(v) {\n      handler(v);\n      return v;\n    });\n\n  public function filter(f : T -> Promise<Bool>) : Emitter<T>\n    return new Emitter(function(stream) {\n      init(new Stream(function(r) switch r {\n        case Pulse(v):\n          f(v).either(\n            function(c)   if(c) stream.pulse(v),\n            function(err) stream.fail(err)\n          );\n        case Failure(e):  stream.fail(e);\n        case End(true):   stream.cancel();\n        case End(false):  stream.end();\n      }));\n    });\n\n  public function filterValue(f : T -> Bool) : Emitter<T>\n    return filter(function(v) return Promise.value(f(v)));\n\n  public function concat(other : Emitter<T>) : Emitter<T>\n    return new Emitter(function(stream) {\n      init(new Stream(function(r) switch r {\n        case Pulse(v):    stream.pulse(v);\n        case Failure(e):  stream.fail(e);\n        case End(true):   stream.cancel();\n        case End(false):  other.init(stream);\n      }));\n    });\n\n  public function merge(other : Emitter<T>) : Emitter<T>\n    return new Emitter(function(stream : Stream<T>) {\n      init(stream);\n      other.init(stream);\n    });\n\n  public function reduce<TOut>(acc : TOut, f : TOut -> T -> TOut) : Emitter<TOut>\n    return new Emitter(function(stream) {\n      init(new Stream(function(r) switch r {\n        case Pulse(v):\n          acc = f(acc, v);\n          stream.pulse(acc);\n        case Failure(e):  stream.fail(e);\n        case End(true):   stream.cancel();\n        case End(false):  stream.end();\n      }));\n    });\n\n  public function toOption() : Emitter<Option<T>>\n    return mapValue(function(v) return null == v ? None : Some(v));\n  public function toNil() : Emitter<Nil>\n    return mapValue(function(_) return nil);\n  public function toTrue() : Emitter<Bool>\n    return mapValue(function(_) return true);\n  public function toFalse() : Emitter<Bool>\n    return mapValue(function(_) return false);\n  public function toValue<T>(value : T) : Emitter<T>\n    return mapValue(function(_) return value);\n  public function log(?prefix : String, ?posInfo : haxe.PosInfos) {\n    prefix = prefix == null ? '': '${prefix}: ';\n    return mapValue(function(v) {\n      haxe.Log.trace('$prefix$v', posInfo);\n      return v;\n    });\n  }\n\n  public function withValue(?expected : T) : Emitter<T>\n    return filterValue(\n      null == expected ?\n        function(v : T) return v != null :\n        function(v : T) return v == expected\n    );\n\n/*\n  public function zip<TOther>(other : Producer<TOther>) : Producer<Tuple2<T, TOther>> {\n    return new Producer(function(forward : Pulse<Tuple2<T, TOther>> -> Void) {\n      var ended = false,\n        endA  = false,\n        endB  = false,\n        buffA : Array<T> = [],\n        buffB : Array<TOther> = [];\n\n      function produce() {\n        if(((buffA.length == 0 && endA) || (buffB.length == 0 && endB)) && !ended) {\n          buffA = null;\n          buffB = null;\n          ended = true;\n          return forward(End);\n        }\n        if(buffA.length == 0 || buffB.length == 0) return;\n        forward(Emit(new Tuple2(buffA.shift(), buffB.shift())));\n      }\n\n      this.feed(new Bus(\n        function(value : T) {\n          if(ended) return;\n          buffA.push(value);\n          produce();\n        },\n        function() {\n          endA = true;\n          produce();\n        },\n        function(error) {\n          forward(Fail(error));\n        }\n      ));\n\n      other.feed(new Bus(\n        function(value : TOther) {\n          if(ended) return;\n          buffB.push(value);\n          produce();\n        },\n        function() {\n          endB = true;\n          produce();\n        },\n        function(error) {\n          forward(Fail(error));\n        }\n      ));\n    }, endOnError);\n  }\n\n  public function blend<TOther, TOut>(other : Producer<TOther>, f : T -> TOther -> TOut) : Producer<TOut> {\n    return this.zip(other).map(function(tuple) {\n      return f(tuple._0, tuple._1);\n    });\n  }\n\n  public function pair<TOther>(other : Producer<TOther>) : Producer<Tuple2<T, TOther>> {\n    return new Producer(function(forward : Pulse<Tuple2<T, TOther>> -> Void) {\n      var endA  = false,\n        endB  = false,\n        buffA : T = null,\n        buffB : TOther = null;\n\n      function produce() {\n        if(endA && endB) {\n          buffA = null;\n          buffB = null;\n          return forward(End);\n        }\n        if(buffA == null || buffB == null) return;\n        forward(Emit(new Tuple2(buffA, buffB)));\n      }\n\n      this.feed(new Bus(\n        function(value : T) {\n          buffA = value;\n          produce();\n        },\n        function() {\n          endA = true;\n          produce();\n        },\n        function(error) {\n          forward(Fail(error));\n        }\n      ));\n\n      other.feed(new Bus(\n        function(value : TOther) {\n          buffB = value;\n          produce();\n        },\n        function() {\n          endB = true;\n          produce();\n        },\n        function(error) {\n          forward(Fail(error));\n        }\n      ));\n\n    }, endOnError);\n  }\n\n  public function distinct(?equals : T -> T -> Bool) : Producer<T> {\n    if(null == equals)\n      equals = function(a, b) return a == b;\n    return new Producer(function(forward) {\n      var last : T = null;\n      this.feed(Bus.passOn(\n        function(v) {\n          if(equals(v, last)) return;\n          last = v;\n          forward(Emit(v));\n        },\n        forward\n      ));\n    }, endOnError);\n  }\n\n  public  function debounce(delay : Int) : Producer<T> {\n    return new Producer(function(forward) {\n      var id : TimerID = null;\n      this.feed(Bus.passOn(\n        function(v : T) {\n          Timer.clearTimer(id);\n          id = Timer.setTimeout(forward.bind(Emit(v)), delay);\n        },\n        forward\n      ));\n    }, endOnError);\n  }\n\n  public function sampleBy<TSampler>(sampler : Producer<TSampler>) : Producer<Tuple2<T, TSampler>> {\n    return new Producer(function(forward : Pulse<Tuple2<T, TSampler>> -> Void) {\n      var latest : T = null;\n      this.feed(Bus.passOn(\n        function(v) latest = v,\n        forward\n      ));\n      sampler.feed(Bus.passOn(\n        function(v) {\n          // skip if this hasn't produced anything yet or has been cleared\n          if(null == latest) return;\n          forward(Emit(new Tuple2(latest, v)));\n          latest = null;\n        },\n        forward\n      ));\n    }, endOnError);\n  }\n\n  public function keep(n : Int) : Producer<Array<T>> {\n    return new Producer(function(forward) {\n      var acc = [];\n      this.feed(Bus.passOn(\n        function(v) {\n          acc.push(v);\n          if(acc.length > n)\n            acc.shift();\n          forward(Emit(acc));\n        },\n        forward\n      ));\n    }, endOnError);\n  }\n\n  public function previous() : Producer<T> {\n    return new Producer(function(forward) {\n      var isFirst   = true,\n        state : T = null;\n      this.feed(Bus.passOn(\n        function(v) {\n          if(isFirst) {\n            isFirst = false;\n          } else {\n            forward(Emit(state));\n          }\n          state = v;\n        },\n        forward\n      ));\n    }, endOnError);\n  }\n*/\n// public function window(length : Int, fillBeforeEmit = false) : Emitter<T> // or unique\n// public function reduce(acc : TOut, TOut -> T) : Emitter<TOut>\n// public function debounce(delay : Int) : Emitter<T>\n// exact pair\n// public function zip<TOther>(other : Emitter<TOther>) : Emitter<Tuple<T, TOther>> // or sync\n// mapFilter?\n}\n\nclass EmitterStrings {\n  public static function toBool(emitter : Emitter<String>) : Emitter<Bool>\n    return emitter\n      .mapValue(function(s) return s != null && s != \"\");\n}\n\nclass EmitterOptions {\n  public static function filterOption<T>(emitter : Emitter<Option<T>>) : Emitter<T>\n    return emitter\n      .filterValue(function(opt) return opt.toBool())\n      .mapValue(function(opt) return opt.toValue());\n\n  public static function toValue<T>(emitter : Emitter<Option<T>>) : Emitter<Null<T>>\n    return emitter\n      .mapValue(function(opt) return opt.toValue());\n\n  public static function toBool<T>(emitter : Emitter<Option<T>>) : Emitter<Bool>\n    return emitter\n      .mapValue(function(opt) return opt.toBool());\n}\n\nclass Emitters {\n  public static function skipNull<T>(emitter : Emitter<Null<T>>) : Emitter<T>\n    return emitter\n      .filterValue(function(value) return null != value);\n}\n\nclass EmitterBools {\n  public static function negate(emitter : Emitter<Bool>)\n    return emitter.mapValue(function(v) return !v);\n}\n\n@:access(thx.stream.Emitter)\nclass EmitterEmitters {\n  public static function flatMap<T>(emitter : Emitter<Array<T>>) : Emitter<T>\n    return new Emitter(function(stream) {\n      emitter.init(new Stream(function(r : StreamValue<Array<T>>) {\n        switch r {\n        case Pulse(arr):   arr.map(stream.pulse);\n        case Failure(e):   stream.fail(e);\n        case End(true):    stream.cancel();\n        case End(false):   stream.end();\n      }}));\n    });\n}\n\nclass EmitterValues {\n  public static function left<TLeft, TRight>(emitter : Emitter<Tuple2<TLeft, TRight>>) : Emitter<TLeft>\n    return emitter.mapValue(function(v) return v._0);\n\n  public static function right<TLeft, TRight>(emitter : Emitter<Tuple2<TLeft, TRight>>) : Emitter<TRight>\n    return emitter.mapValue(function(v) return v._1);\n}","package thx.stream;\n\nimport thx.core.Error;\n\nclass Stream<T> implements IStream {\n\n  var subscriber : StreamValue<T> -> Void;\n  var cleanUps : Array<Void -> Void>;\n  var finalized : Bool;\n  public var canceled(default, null) : Bool;\n  public function new(subscriber : StreamValue<T> -> Void) {\n    this.subscriber = subscriber;\n    this.cleanUps   = [];\n    this.finalized  = false;\n    this.canceled   = false;\n  }\n\n  public function addCleanUp(f : Void -> Void) {\n    cleanUps.push(f);\n  }\n\n  public function pulse(v : T) {\n    subscriber(Pulse(v));\n  }\n\n  public function end() {\n    finalize(End(false));\n  }\n\n  public function cancel() {\n    canceled = true;\n    finalize(End(true));\n  }\n\n  public function fail(error : Error) {\n    finalize(Failure(error));\n  }\n\n  function finalize(signal : StreamValue<T>) {\n    if(finalized) return;\n    finalized = true;\n    while(cleanUps.length > 0)\n      cleanUps.shift()();\n    subscriber(signal);\n    subscriber = function(_) {};\n  }\n}","package thx.stream;\n\nclass Value<T> extends Emitter<T> {\n  var value : T;\n  var downStreams : Array<Stream<T>>;\n  var upStreams : Array<Stream<T>>;\n  public function new(value : T) {\n    this.value = value;\n    this.downStreams = [];\n    this.upStreams = [];\n    super(function(stream : Stream<T>) {\n      this.downStreams.push(stream);\n      stream.addCleanUp(function() this.downStreams.remove(stream));\n      stream.pulse(this.value);\n    });\n  }\n\n  public function get() : T\n    return value;\n\n  public function set(value : T) {\n    if(this.value == value)\n      return;\n    this.value = value;\n    update();\n  }\n\n  public function clearStreams()\n    for(stream in downStreams.copy())\n      stream.end();\n\n  public function clearEmitters()\n    for(stream in upStreams.copy())\n      stream.cancel();\n\n  public function clear() {\n    clearEmitters();\n    clearStreams();\n  }\n\n  function update()\n    for(stream in downStreams.copy())\n      stream.pulse(value);\n}","package thx.stream.dom;\n\nusing StringTools;\nusing thx.core.Nil;\nusing thx.stream.Emitter;\nusing thx.promise.Promise;\nimport js.html.*;\n\nclass Dom {\n  public static function ready() : Promise<Nil> {\n    return Promise.create(function(resolve, _) {\n      js.Browser.document.addEventListener(\"DOMContentLoaded\", function(_) {\n        resolve(nil);\n      }, false);\n    });\n  }\n\n  public static function streamEvent<TEvent : Event>(el : Element, name : String, capture = false) : Emitter<TEvent>\n    return Emitter.create(function(stream) {\n      el.addEventListener(name, stream.pulse, capture);\n      stream.addCleanUp(function() el.removeEventListener(name, stream.pulse, capture));\n    });\n\n  public inline static function streamMouseEvent(el : Element, name : String, capture = false) : Emitter<MouseEvent>\n    return streamEvent(el, name, capture);\n\n  public static function streamKey(el : Element, name : String, capture = false) : Emitter<KeyboardEvent>\n    return Emitter.create({\n      if(!name.startsWith('key'))\n        name = 'key$name';\n      function(stream) {\n        el.addEventListener(name, stream.pulse, capture);\n        stream.addCleanUp(function() el.removeEventListener(name, stream.pulse, capture));\n      }\n    });\n\n  public inline static function streamClick(el : Element, capture = false) : Emitter<MouseEvent>\n    return streamMouseEvent(el, 'click', capture);\n\n  public inline static function streamInput(el : InputElement, capture = false) : Emitter<String>\n    return streamMouseEvent(el, 'input', capture).mapValue(function(_) return el.value);\n\n  public static function subscribeText(el : Element) : String -> Void\n    return function(text : String) el.innerText = text;\n\n  public static function subscribeHTML(el : Element) : String -> Void\n    return function(html : String) el.innerHTML = html;\n\n  public static function subscribeFocus(el : Element) : Bool -> Void\n    return function(focus : Bool) if(focus) el.focus() else el.blur();\n\n  public static function subscribeAttribute<T>(el : Element, name : String) : T -> Void\n    return function(value : T) if(null == value) el.removeAttribute(name) else el.setAttribute(name, cast value);\n\n  public static function subscribeToggleAttribute<T>(el : Element, name : String, ?value : T) : Bool -> Void {\n    if(null == value)\n      value = cast el.getAttribute(name);\n    return function(on) if(on) el.removeAttribute(name) else el.setAttribute(name, cast value);\n  }\n\n  public static function subscribeToggleVisibility(el : Element) : Bool -> Void {\n    var originalDisplay = el.style.display;\n    if(originalDisplay == 'none')\n      originalDisplay = '';\n    return function(on) if(on) el.style.display = originalDisplay else el.style.display = 'none';\n  }\n}","package types;\n\nusing thx.core.Arrays;\nimport ui.Expression;\n\nclass ArrayTransform {\n  public static function toArray(value : Array<Dynamic>) : Array<Dynamic> {\n     return null != value ? value : [];\n  }\n\n  public static function toBool(value : Array<Dynamic>) : Bool {\n    return toArray(value).length > 0;\n  }\n\n  public static function toDate(value : Array<Dynamic>) : Date {\n    var defaults = [2000, 0, 1, 0, 0, 0],\n      values   = toArray(value)\n        .map(DynamicTransform.toFloat)\n        .map(function(v) return Math.round(v))\n        .slice(0, defaults.length);\n    values = values.concat(defaults.slice(values.length));\n    return new Date(values[0], values[1], values[2], values[3], values[4], values[5]);\n  }\n\n  public static function toFloat(value : Array<Dynamic>) : Float {\n    return toArray(value).length;\n  }\n\n  public static function toObject(value : Array<Dynamic>) : {} {\n    var obj = {};\n    toArray(value).mapi(function(v, i) {\n      Reflect.setField(obj, 'field_${i+1}', v);\n    });\n    return obj;\n  }\n\n  public static function toString(value : Array<Dynamic>) : String {\n    return toArray(value).map(DynamicTransform.toString).join(', ');\n  }\n\n  public static function toCode(value : Array<Dynamic>) : String {\n    return '[${toArray(value).map(DynamicTransform.toCode).join(\",\")}]';\n  }\n\n  public static function toReference(value : Array<Dynamic>) : String {\n    return '';\n  }\n}","package types;\n\nimport ui.Expression;\n\nclass BoolTransform {\n  public static function toArray(value : Bool) : Array<Dynamic> {\n    return [toBool(value) ? false : value];\n  }\n\n  public static function toBool(value : Bool) : Bool {\n    return null != value && value;\n  }\n\n  public static function toDate(value : Bool) : Date {\n    return Date.now();\n  }\n\n  public static function toFloat(value : Bool) : Float {\n    return toBool(value) ? 1 : 0;\n  }\n\n  public static function toObject(value : Bool) : {} {\n    return ArrayTransform.toObject([toBool(value)]);\n  }\n\n  public static function toString(value : Bool) : String {\n    return toBool(value) ? 'Yes' : 'No';\n  }\n\n  public static function toCode<T>(value : Bool) : String {\n    return toBool(value) ? 'true' : 'false';\n  }\n\n  public static function toReference(value : Bool) : String {\n    return '';\n  }\n}","package types;\n\nimport haxe.Json;\nimport ui.Expression;\nusing StringTools;\n\nclass CodeTransform {\n  public static function toArray(value : String) : Array<Dynamic> {\n    return try {\n      var t = Json.parse(toCode(value));\n      if(Std.is(t, Array))\n        t;\n      else\n        DynamicTransform.toArray(t);\n    } catch(_ : Dynamic) {\n      [];\n    }\n  }\n\n  public static function toBool(value : String) : Bool {\n    return switch toCode(value) {\n      case 'true', '1': true;\n      case _: false;\n    }\n  }\n\n  static var datePattern = ~/Date\\(-?\\d+(:?\\.\\d+)?(:?e-?\\d+)?\\)/;\n  public static function toDate(value : String) : Date {\n    if(datePattern.match(value))\n      return Date.fromTime(Std.parseFloat(datePattern.matched(1)));\n    else\n      return Date.now();\n  }\n\n  public static function toFloat(value : String) : Float {\n    return Std.parseFloat(toCode(value));\n  }\n\n  public static function toObject(value : String) : {} {\n    return try {\n      var t = Json.parse(toCode(value));\n      if(Reflect.isObject(t) && !Std.is(t, String))\n        t;\n      else\n        DynamicTransform.toObject(t);\n    } catch(_ : Dynamic) {\n      {};\n    }\n  }\n\n  public static function toString(value : String) : String {\n    return try {\n      var t = Json.parse(toCode(value));\n      if(Std.is(t, String))\n        t;\n      else\n        DynamicTransform.toString(t);\n    } catch(_ : Dynamic) {\n      '';\n    }\n  }\n\n  public static function toCode(value : String) : String {\n    return null != value ? value.trim() : 'null';\n  }\n\n  static var PATTERN = ~/^\\s*\\$\\.([a-z](:?(\\.|\\[\\d+\\])?[a-z0-9]*)*)\\s*$/;\n  public static function toReference(value : String) : String {\n    var code = toCode(value);\n    return PATTERN.match(code) ? PATTERN.matched(1) : '';\n  }\n}","package types;\n\nimport ui.Expression;\n\nclass DateTransform {\n  public static function toArray(value : Date) : Array<Dynamic> {\n    return [toDate(value)];\n  }\n\n  public static function toBool(value : Date) : Bool {\n    return false;\n  }\n\n  public static function toDate(value : Date) : Date {\n    return null != value ? value : Date.now();\n  }\n\n  public static function toFloat(value : Date) : Float {\n    return toDate(value).getTime();\n  }\n\n  public static function toObject(value : Date) : {} {\n    return ArrayTransform.toObject([toDate(value)]);\n  }\n\n  public static function toString(value : Date) : String {\n    return toDate(value).toString();\n  }\n\n  public static function toCode(value : Date) : String {\n    return 'new Date(${toDate(value).getTime()})';\n  }\n\n  public static function toReference(value : Date) : String {\n    return '';\n  }\n}","package types;\n\nimport ui.Expression;\n\nclass DynamicTransform {\n  public static function toArray(value : Dynamic) : Array<Dynamic> {\n    if(null == value)\n      return [];\n    if(Std.is(value, Array))\n      return ArrayTransform.toArray(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toArray(value);\n    if(Std.is(value, Date))\n      return DateTransform.toArray(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toArray(value);\n    if(Std.is(value, String))\n      return StringTransform.toArray(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toArray(value);\n    if(Reflect.isFunction(value))\n      return toArray(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toArray';\n  }\n\n  public static function toBool(value : Dynamic) : Bool {\n    if(null == value)\n      return false;\n    if(Std.is(value, Array))\n      return ArrayTransform.toBool(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toBool(value);\n    if(Std.is(value, Date))\n      return DateTransform.toBool(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toBool(value);\n    if(Std.is(value, String))\n      return StringTransform.toBool(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toBool(value);\n    if(Reflect.isFunction(value))\n      return toBool(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toBool';\n  }\n\n  public static function toDate(value : Dynamic) : Date {\n    if(null == value)\n      return Date.now();\n    if(Std.is(value, Array))\n      return ArrayTransform.toDate(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toDate(value);\n    if(Std.is(value, Date))\n      return DateTransform.toDate(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toDate(value);\n    if(Std.is(value, String))\n      return StringTransform.toDate(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toDate(value);\n    if(Reflect.isFunction(value))\n      return toDate(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toDate';\n  }\n\n  public static function toFloat(value : Dynamic) : Float {\n    if(null == value)\n      return 0;\n    if(Std.is(value, Array))\n      return ArrayTransform.toFloat(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toFloat(value);\n    if(Std.is(value, Date))\n      return DateTransform.toFloat(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toFloat(value);\n    if(Std.is(value, String))\n      return StringTransform.toFloat(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toFloat(value);\n    if(Reflect.isFunction(value))\n      return toFloat(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toFloat';\n  }\n\n  public static function toObject(value : Dynamic) : {} {\n    if(null == value)\n      return {};\n    if(Std.is(value, Array))\n      return ArrayTransform.toObject(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toObject(value);\n    if(Std.is(value, Date))\n      return DateTransform.toObject(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toObject(value);\n    if(Std.is(value, String))\n      return StringTransform.toObject(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toObject(value);\n    if(Reflect.isFunction(value))\n      return toObject(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toObject';\n  }\n\n  public static function toString(value : Dynamic) : String {\n    if(null == value)\n      return '';\n    if(Std.is(value, Array))\n      return ArrayTransform.toString(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toString(value);\n    if(Std.is(value, Date))\n      return DateTransform.toString(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toString(value);\n    if(Std.is(value, String))\n      return StringTransform.toString(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toString(value);\n    if(Reflect.isFunction(value))\n      return toString(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toString';\n  }\n\n  public static function toCode(value : Dynamic) : String {\n    if(null == value)\n      return 'null';\n    if(Std.is(value, Array))\n      return ArrayTransform.toCode(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toCode(value);\n    if(Std.is(value, Date))\n      return DateTransform.toCode(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toCode(value);\n    if(Std.is(value, String))\n      return StringTransform.toCode(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toCode(value);\n    if(Reflect.isFunction(value))\n      return toCode(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toCode';\n  }\n\n  public static function toReference(value : Dynamic) : String {\n    if(null == value)\n      return '';\n    if(Std.is(value, Array))\n      return ArrayTransform.toReference(value);\n    if(Std.is(value, Bool))\n      return BoolTransform.toReference(value);\n    if(Std.is(value, Date))\n      return DateTransform.toReference(value);\n    if(Std.is(value, Float))\n      return FloatTransform.toReference(value);\n    if(Std.is(value, String))\n      return StringTransform.toReference(value);\n    if(Reflect.isObject(value))\n      return ObjectTransform.toReference(value);\n    if(Reflect.isFunction(value))\n      return toReference(null);\n    return throw 'Type of $value cannot be matched by DynamicTransform.toReference';\n  }\n}","package types;\n\nimport ui.Expression;\n\nclass FloatTransform {\n  public static function toArray(value : Float) : Array<Dynamic> {\n    return [toFloat(value)];\n  }\n\n  public static function toBool(value : Float) : Bool {\n    return toFloat(value) != 0;\n  }\n\n  public static function toDate(value : Float) : Date {\n    return Date.fromTime(toFloat(value));\n  }\n\n  public static function toFloat(value : Float) : Float {\n    return null != value ? value : 0.0;\n  }\n\n  public static function toObject(value : Float) : {} {\n    return ArrayTransform.toObject([toFloat(value)]);\n  }\n\n  public static function toString(value : Float) : String {\n    return '' + toFloat(value);\n  }\n\n  public static function toCode(value : Float) : String {\n    return '' + toFloat(value);\n  }\n\n  public static function toReference(value : Array<Dynamic>) : String {\n    return '';\n  }\n}","package types;\n\nimport ui.Expression;\nimport thx.core.Objects;\n\nclass ObjectTransform {\n  public static function toArray(value : {}) : Array<Dynamic> {\n    return [toObject(value)];\n  }\n\n  public static function toBool(value : {}) : Bool {\n    return !Objects.isEmpty(toObject(value));\n  }\n\n  public static function toDate(value : {}) : Date {\n    return Date.now();\n  }\n\n  public static function toFloat(value : {}) : Float {\n    return Reflect.fields(toObject(value)).length;\n  }\n\n  public static function toObject(value : {}) : {} {\n    return null != value ? value : {};\n  }\n\n  public static function toString(value : {}) : String {\n    return Reflect.fields(toObject(value)).map(function(field) {\n      return '$field: ' + DynamicTransform.toString(Reflect.field(value, field));\n    }).join(', ');\n  }\n\n  public static function toCode(value : {}) : String {\n    return \"{\" + Reflect.fields(toObject(value)).map(function(field) {\n      return '\"$field\" : ' + DynamicTransform.toCode(Reflect.field(value, field));\n    }).join(', ') + \"}\";\n  }\n\n  public static function toReference(value : Array<Dynamic>) : String {\n    return '';\n  }\n}","package types;\n\nimport haxe.Json;\nimport ui.Expression;\nusing StringTools;\n\nclass ReferenceTransform {\n  public static function toArray(value : String) : Array<Dynamic> {\n    return ArrayTransform.toArray(null);\n  }\n\n  public static function toBool(value : String) : Bool {\n    return BoolTransform.toBool(null);\n  }\n\n  public static function toDate(value : String) : Date {\n    return DateTransform.toDate(null);\n  }\n\n  public static function toFloat(value : String) : Float {\n    return FloatTransform.toFloat(null);\n  }\n\n  public static function toObject(value : String) : {} {\n    return ObjectTransform.toObject(null);\n  }\n\n  public static function toString(value : String) : String {\n    return StringTransform.toString(null);\n  }\n\n  public static function toCode(value : String) : String {\n    value = toReference(value);\n    return '' == value ? '' : '$.$value';\n  }\n\n  public static function toReference(value : String) : String {\n    return null == value ? '' : value;\n  }\n}","package types;\n\nimport ui.Expression;\nusing StringTools;\n\nclass StringTransform {\n  public static function toArray(value : String) : Array<Dynamic> {\n    return toString(value).split(',').map(StringTools.trim);\n  }\n\n  public static function toBool(value : String) : Bool {\n    return switch toString(value).trim().toLowerCase() {\n      case '', 'off', 'no', 'false', '0': false;\n      case _: true;\n    };\n  }\n\n  public static function toDate(value : String) : Date {\n    return try {\n      Date.fromString(value);\n    } catch(e : Dynamic) {\n      Date.now();\n    };\n  }\n\n  public static function toFloat(value : String) : Float {\n    return Std.parseFloat(toString(value));\n  }\n\n  public static function toObject(value : String) : {} {\n    return ArrayTransform.toObject([toString(value)]);\n  }\n\n  public static function toString(value : String) : String {\n    return null != value ? value : '';\n  }\n\n  public static function toCode(value : String) : String {\n    return '\"' + toString(value).replace('\"', '\\\\\"') + '\"';\n  }\n\n  public static function toReference(value : Array<Dynamic>) : String {\n    return '';\n  }\n}","package types;\n\nimport types.ArrayTransform;\nimport types.BoolTransform;\nimport types.DateTransform;\nimport types.FloatTransform;\nimport types.ObjectTransform;\nimport types.StringTransform;\nimport ui.SchemaType;\n\nclass TypeTransform {\n  public static function transform(srcType : SchemaType, dstType : SchemaType) : Dynamic -> Dynamic {\n    return switch srcType {\n      case ArrayType(_):\n        switch dstType {\n          case ArrayType(_):\n            ArrayTransform.toArray;\n          case BoolType:\n            ArrayTransform.toBool;\n          case DateType:\n            ArrayTransform.toDate;\n          case FloatType:\n            ArrayTransform.toFloat;\n          case ObjectType(_):\n            ArrayTransform.toObject;\n          case StringType:\n            ArrayTransform.toString;\n          case CodeType:\n            ArrayTransform.toCode;\n          case ReferenceType:\n            ArrayTransform.toReference;\n        }\n      case BoolType:\n        switch dstType {\n          case ArrayType(_):\n            BoolTransform.toArray;\n          case BoolType:\n            BoolTransform.toBool;\n          case DateType:\n            BoolTransform.toDate;\n          case FloatType:\n            BoolTransform.toFloat;\n          case ObjectType(_):\n            BoolTransform.toObject;\n          case StringType:\n            BoolTransform.toString;\n          case CodeType:\n            BoolTransform.toCode;\n          case ReferenceType:\n            BoolTransform.toReference;\n        }\n      case DateType:\n        switch dstType {\n          case ArrayType(_):\n            DateTransform.toArray;\n          case BoolType:\n            DateTransform.toBool;\n          case DateType:\n            DateTransform.toDate;\n          case FloatType:\n            DateTransform.toFloat;\n          case ObjectType(_):\n            DateTransform.toObject;\n          case StringType:\n            DateTransform.toString;\n          case CodeType:\n            DateTransform.toCode;\n          case ReferenceType:\n            DateTransform.toReference;\n        }\n      case FloatType:\n        switch dstType {\n          case ArrayType(_):\n            FloatTransform.toArray;\n          case BoolType:\n            FloatTransform.toBool;\n          case DateType:\n            FloatTransform.toDate;\n          case FloatType:\n            FloatTransform.toFloat;\n          case ObjectType(_):\n            FloatTransform.toObject;\n          case StringType:\n            FloatTransform.toString;\n          case CodeType:\n            FloatTransform.toCode;\n          case ReferenceType:\n            FloatTransform.toReference;\n        }\n      case ObjectType(_):\n        switch dstType {\n          case ArrayType(_):\n            ObjectTransform.toArray;\n          case BoolType:\n            ObjectTransform.toBool;\n          case DateType:\n            ObjectTransform.toDate;\n          case FloatType:\n            ObjectTransform.toFloat;\n          case ObjectType(_):\n            ObjectTransform.toObject;\n          case StringType:\n            ObjectTransform.toString;\n          case CodeType:\n            ObjectTransform.toCode;\n          case ReferenceType:\n            ObjectTransform.toReference;\n        }\n      case StringType:\n        switch dstType {\n          case ArrayType(_):\n            StringTransform.toArray;\n          case BoolType:\n            StringTransform.toBool;\n          case DateType:\n            StringTransform.toDate;\n          case FloatType:\n            StringTransform.toFloat;\n          case ObjectType(_):\n            StringTransform.toObject;\n          case StringType:\n            StringTransform.toString;\n          case CodeType:\n            StringTransform.toCode;\n          case ReferenceType:\n            StringTransform.toReference;\n        }\n      case CodeType:\n        switch dstType {\n          case ArrayType(_):\n            CodeTransform.toArray;\n          case BoolType:\n            CodeTransform.toBool;\n          case DateType:\n            CodeTransform.toDate;\n          case FloatType:\n            CodeTransform.toFloat;\n          case ObjectType(_):\n            CodeTransform.toObject;\n          case StringType:\n            CodeTransform.toString;\n          case CodeType:\n            CodeTransform.toCode;\n          case ReferenceType:\n            CodeTransform.toReference;\n        }\n      case ReferenceType:\n        switch dstType {\n          case ArrayType(_):\n            ReferenceTransform.toArray;\n          case BoolType:\n            ReferenceTransform.toBool;\n          case DateType:\n            ReferenceTransform.toDate;\n          case FloatType:\n            ReferenceTransform.toFloat;\n          case ObjectType(_):\n            ReferenceTransform.toObject;\n          case StringType:\n            ReferenceTransform.toString;\n          case CodeType:\n            ReferenceTransform.toCode;\n          case ReferenceType:\n            ReferenceTransform.toReference;\n        }\n    }\n  }\n}","package ui;\n\nimport steamer.MultiProducer;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport thx.Assert;\nimport ui.fragments.Block;\nimport ui.fragments.ReadonlyBlock;\nimport ui.fragments.Fragment;\nimport steamer.Value;\nimport haxe.ds.Option;\nusing thx.core.Options;\nusing steamer.Producer;\n\nclass Article {\n  public var component(default, null) : Component;\n  public var fragment(default, null) : Value<Option<Fragment>>;\n\n  var fragmentStream : MultiProducer<Fragment>;\n  var fragments : Map<Fragment, Void -> Void>;\n\n  public function new(options : ComponentOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<article></article>';\n    component = new Component(options);\n    fragments = new Map();\n    fragmentStream = new MultiProducer();\n    fragment = new Value(None);\n    fragmentStream.toOption().feed(fragment);\n    var filtered = fragment.filterOption();\n    filtered.previous().feed(function(fragment : Fragment) {\n      fragment.active.value = false;\n    });\n    filtered.feed(function(fragment : Fragment) {\n      fragment.active.value = true;\n    });\n  }\n\n  function addFragment(fragment : Fragment) {\n    var addFocus = fragment\n      .focus\n      .filter(function(v) return v)\n      .map(function(_) : Fragment return fragment);\n    fragmentStream.add(addFocus);\n    fragments.set(fragment, function() {\n      fragmentStream.remove(addFocus);\n    });\n  }\n\n  public function addBlock() {\n    var fragment = new Block({\n        parent : component,\n        container : component.el,\n        defaultText : 'block'\n      });\n    addFragment(fragment);\n    return fragment;\n  }\n\n  public function addReadonly() {\n    var fragment = new ReadonlyBlock({\n        parent : component,\n        container : component.el\n      });\n    addFragment(fragment);\n    return fragment;\n  }\n\n  public function removeFragment(fragment : Fragment) {\n    if(this.fragment.value.equalsValue(fragment))\n      this.fragment.value = None;\n    var finalizer = fragments.get(fragment);\n    Assert.notNull(finalizer);\n    finalizer();\n  }\n}","package ui;\n\nimport js.html.Element;\nimport sui.components.Component;\nimport dom.Dom;\nimport ui.fragments.FragmentMapper;\nusing steamer.Producer;\n\nclass Card {\n  public static function create(model : Model, container : Element, mapper : FragmentMapper) {\n    var card = new Component({\n        template : '<div class=\"card\"><div class=\"doc\"></div><aside><div class=\"context\"></div><div class=\"model\"></div></aside></div>'\n      }),\n      context = Query.first('.context', card.el),\n      modelView = new ModelView(),\n      document = new Document({ el : Query.first('.doc', card.el) }),\n      context = new ContextView(\n        document,\n        model,\n        modelView,\n        mapper,\n        { el : Query.first('.context', card.el) }\n      );\n\n    modelView.component.appendTo(Query.first('.model', card.el));\n\n    modelView.schema.feed(model.schemaEventConsumer);\n    modelView.data.feed(model.dataEventConsumer);\n\n    card.appendTo(container);\n\n    // TODO remove me\n    document.article.addReadonly();\n    var block = document.article.addBlock();\n    mapper.values.ensure('strong', block.component);\n    block = document.article.addBlock();\n    mapper.values.ensure('emphasis', block.component);\n    block = document.article.addBlock();\n    mapper.values.ensure('strong', block.component);\n    mapper.values.ensure('emphasis', block.component);\n    document.article.addBlock();\n  }\n}","package ui.widgets;\n\nimport js.Browser;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport js.html.Element;\nimport sui.properties.Visible;\nimport dom.Dom;\n\nclass FrameOverlay {\n  public var component(default, null) : Component;\n  public var visible(default, null) : Visible;\n  public var anchorElement(default, null) : Element;\n  var my : AnchorPoint;\n  var at : AnchorPoint;\n  public function new(options : ComponentOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<div class=\"frame-overlay\"></div>';\n    component = new Component(options);\n    visible = new Visible(component, false);\n    function clear(_) {\n      visible.stream.value = false;\n    }\n    visible.stream\n      .filter(function(b) {\n        return !b;\n      })\n      .feed(function(_) {\n        Browser.document.removeEventListener('mouseup', clear, false);\n      });\n    visible.stream\n      .filter(function(b) {\n        return b;\n      })\n      .feed(function(_) {\n        Browser.document.addEventListener('mouseup', clear, false);\n        reposition();\n      });\n    anchorElement = Browser.document.body;\n  }\n\n  public function anchorTo(el : Element, ?my : AnchorPoint, ?at : AnchorPoint) {\n    anchorElement = el;\n    this.my = null == my ? TopLeft : my;\n    this.at = null == at ? BottomLeft : at;\n    if(visible.stream.value)\n      reposition();\n  }\n\n  public function reposition() {\n    if(!component.isAttached) {\n      var parent = [Query.first(Config.selectors.app), Browser.document.body].filter(function(v) return null != v).shift();\n      component.appendTo(parent);\n    }\n    var style = component.el.style;\n    style.position = \"fixed\";\n\n    var atrect = anchorElement.getBoundingClientRect(),\n      myrect = component.el.getBoundingClientRect(),\n      x = 0.0,\n      y = 0.0;\n    // AT Y\n    switch at {\n      case TopLeft, Top, TopRight:\n        y = atrect.top;\n      case Left, Center, Right:\n        y = atrect.top + atrect.height / 2;\n      case BottomLeft, Bottom, BottomRight:\n        y = atrect.top + atrect.height;\n    }\n    // AT X\n    switch at {\n      case TopLeft, Left, BottomLeft:\n        x = atrect.left;\n      case Top, Center, Bottom:\n        x = atrect.left + atrect.width / 2;\n      case TopRight, Right, BottomRight:\n        x = atrect.left + atrect.width;\n    }\n    // MY Y\n    switch my {\n      case TopLeft, Top, TopRight:\n        y -= 0;\n      case Left, Center, Right:\n        y -= myrect.height / 2;\n      case BottomLeft, Bottom, BottomRight:\n        y -= myrect.height;\n    }\n    // MY X\n    switch my {\n      case TopLeft, Left, BottomLeft:\n        x -= 0;\n      case Top, Center, Bottom:\n        x -= myrect.width / 2;\n      case TopRight, Right, BottomRight:\n        x -= myrect.width;\n    }\n    style.top  = y + 'px';\n    style.left = x + 'px';\n  }\n}","package ui.widgets;\n\nimport sui.components.ComponentOptions;\n\nclass Tooltip extends FrameOverlay {\n  public function new(options : ComponentOptions) {\n    super(options);\n  }\n\n  public function setContent(html : String) {\n    component.el.innerHTML = html;\n  }\n}","package ui;\n\nimport steamer.Feeder;\nimport steamer.Producer;\nimport steamer.Value;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport dom.Dom;\nimport sui.properties.ToggleClass;\nimport sui.properties.ValueProperty;\nusing thx.core.Arrays;\nimport types.CodeTransform;\nimport types.ReferenceTransform;\nimport types.TypeTransform;\nimport ui.editors.CodeEditor;\nimport ui.editors.Editor;\nimport ui.editors.EditorPicker;\nusing steamer.dom.Dom;\nimport haxe.ds.Option;\nimport ui.SchemaType;\nimport ui.widgets.Tooltip;\nimport ui.FieldValue;\nusing thx.core.Options;\nusing ui.Expression;\nusing StringTools;\n\nclass ContextField {\n  public static var tooltip(default, null) : Tooltip = new Tooltip({ classes : 'tooltip error' });\n  public var component(default, null) : Component;\n  //public var editor(default, null) : Editor<Dynamic>;\n  public var focus(default, null) : Value<Bool>;\n  public var active(default, null) : Value<Bool>;\n  public var name(default, null) : String;\n  public var withError(default, null) : Value<Option<String>>;\n  public var fieldValue(default, null) : FieldValue;\n  public var type(default, null) : SchemaType;\n  public var currentType(default, null) : Value<SchemaType>;\n\n  public function new(options : ContextFieldOptions) {\n    if(null == options.template && null == options.el)\n      options.template = '<div class=\"field\"><div class=\"key-container\"><div class=\"key\"></div></div><div class=\"value-container\"></div></div>';\n\n    component = new Component(options);\n    // setup field key\n    var key = Query.first('.key', component.el);\n    key.innerText = options.display;\n\n    name = options.name;\n    type = options.type;\n    currentType = new Value(options.type);\n\n    focus = new Value(false);\n    active = new Value(false);\n    withError = new Value(None);\n\n    function wireRuntime(editor : Editor<Dynamic>, convert : String -> Runtime) {\n      var runtime = editor.value.map(convert);\n      runtime\n        .distinct(function(a, b) {\n          return b != null && a.dependencies.same(b.dependencies);\n        })\n        .feed(function(res : Runtime) {\n          options.model.changes.feed(function(path) {\n            if(res.dependencies.contains(path, function(a, b) return b.startsWith(a))) {\n              options.value.runtime.value = Some(convert(editor.value.value));\n            }\n          });\n        });\n      runtime\n        .toOption()\n        .feed(options.value.runtime);\n      runtime\n        .map(function(res) return res.expression.toErrorOption())\n        .merge(options.value.runtimeError)\n        .feed(withError);\n    }\n\n    var bus = new Feeder();\n    fieldValue = new FieldValue(\n      component,\n      Query.first('.value-container', component.el),\n      function(type : SchemaType, editor : Editor<Dynamic>) {\n        editor.focus.feed(focus);\n        currentType.value = type;\n        switch type {\n          case CodeType:\n            wireRuntime(editor, function(value : String) return Runtime.toRuntime(value, options.model));\n          case ReferenceType:\n            wireRuntime(editor, function(value : String) return Runtime.toRuntime(ReferenceTransform.toCode(value), options.model));\n            // TODO break loop!\n            bus.feed(function(value : Dynamic) {\n              var path = editor.value.value;\n              options.modelView.setField(path, value, options.type);\n            });\n            options.value.stream.feed(bus);\n          case _:\n            options.value.runtime.value = None;\n            editor.value.feed(options.value.stream);\n            // TODO does this leak?\n            options.value.stream.feed(editor.value);\n        }\n      },\n      function(type : SchemaType, editor : Editor<Dynamic>) {\n        switch type {\n          case CodeType:\n          case ReferenceType:\n            trace(\"cancelling\");\n            bus.cancel();\n          case _:\n        }\n      }\n    );\n\n    var runtime = options.value.runtime.value.toValue();\n    if(null == runtime)\n      fieldValue.setEditor(options.type, options.value.stream.value);\n    else {\n      var reference = CodeTransform.toReference(runtime.code);\n      if(null != reference && \"\" != reference)\n        fieldValue.setEditor(ReferenceType, CodeTransform.toReference(runtime.code));\n      else\n        fieldValue.setEditor(CodeType, runtime.code);\n    }\n\n    active.feed(component.el.consumeToggleClass('active'));\n\n    var clickKey = key.produceEvent('click');\n    clickKey.producer\n      .feed(function(_) {\n        if(null != fieldValue.editor)\n          fieldValue.editor.focus.value = true;\n      });\n\n    var hasError = component.el.consumeToggleClass('error');\n    withError.map(function(o) {\n      return switch o {\n        case None: false;\n        case Some(_): true;\n      }\n    }).feed(hasError);\n    withError.feed(function(o) {\n      switch o {\n        case Some(err):\n          tooltip.setContent(err);\n          tooltip.anchorTo(component.el, Top, Bottom);\n          tooltip.visible.stream.value = true;\n        case _:\n          if(tooltip.anchorElement == component.el)\n            tooltip.visible.stream.value = false;\n      }\n    });\n\n  }\n\n  public function destroy() {\n    component.destroy();\n    focus = null;\n  }\n}\n\ntypedef ContextFieldOptions = {>ComponentOptions,\n  type : SchemaType,\n  display : String,\n  name : String,\n  value : ValueProperty<Dynamic>,\n  model : Model,\n  modelView : ModelView\n}","package ui;\n\nimport dom.Dom;\nimport haxe.ds.Option;\nimport js.html.Element;\nimport steamer.Value;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport sui.properties.ValueProperties;\nimport sui.properties.ValueProperty;\nimport ui.fragments.FragmentMapper;\nimport ui.SchemaType;\nimport ui.widgets.Button;\nimport ui.fragments.Fragment;\nimport ui.widgets.Menu;\nimport ui.widgets.Toolbar;\nusing thx.core.Options;\nusing steamer.Producer;\n\nclass ContextView {\n  public var component(default, null) : Component;\n  public var toolbar(default, null) : Toolbar;\n  public var document(default, null) : Document;\n  public var field(default, null) : Value<Option<ContextField>>;\n  public var model(default, null) : Model;\n  public var modelView(default, null) : ModelView;\n  var el : Element;\n  var button : {\n    add : Button,\n    remove : Button,\n    toValue : Button,\n    toCode : Button,\n    toReference : Button\n  };\n  var menu : {\n    add : Menu\n  };\n  var mapper : FragmentMapper;\n\n  public function new(document : Document, model : Model, modelView : ModelView, mapper : FragmentMapper, options : ComponentOptions) {\n    this.document = document;\n    this.model = model;\n    this.modelView = modelView;\n    this.mapper = mapper;\n    component = new Component(options);\n    toolbar   = new Toolbar({ parent : component, container : component.el });\n    el = Html.parse('<div class=\"fields\"><div></div></div>');\n    component.el.appendChild(el);\n    el = Query.first('div', el);\n\n    button = {\n      add : toolbar.left.addButton('add property', Config.icons.dropdown),\n      toValue : toolbar.right.addButton('', Config.icons.value),\n      toCode : toolbar.right.addButton('', Config.icons.code),\n      toReference : toolbar.right.addButton('', Config.icons.reference),\n      remove : toolbar.right.addButton('', Config.icons.remove)\n    };\n    menu = {\n      add : new Menu({ parent : component })\n    };\n\n    menu.add.anchorTo(button.add.component.el);\n    button.add.clicks.toTrue().feed(menu.add.visible.stream);\n\n    button.add.enabled.value = false;\n\n    button.remove.clicks.feed(function(_) {\n      var field = field.value.toValue(),\n        fragment = document.article.fragment.value.toValue();\n      fragment.component.properties.get(field.name).dispose();\n      field.destroy();\n      setAddMenuItems(fragment);\n    });\n\n    button.toValue.clicks.feed(function(_) {\n      var field = field.value.toValue(),\n        type  = field.fieldValue.type;\n      field.fieldValue.setEditor(field.type);\n    });\n    button.toCode.clicks.feed(function(_) {\n      var field = field.value.toValue(),\n        type  = field.fieldValue.type;\n      field.fieldValue.setEditor(CodeType);\n    });\n    button.toReference.clicks.feed(function(_) {\n      var field = field.value.toValue(),\n        type  = field.fieldValue.type;\n      field.fieldValue.setEditor(ReferenceType);\n    });\n\n    field = new Value(None);\n    var delayed = field\n      .debounce(10);\n\n    delayed\n      .toBool()\n      .feed(button.remove.enabled);\n    field\n      .filterOption()\n      .map(function(v) : Producer<SchemaType> return v.currentType)\n      .flatMap()\n      .feed(function(type) {\n        switch type {\n          case CodeType:\n            button.toCode.enabled.value = false;\n            button.toReference.enabled.value = true;\n            button.toValue.enabled.value = true;\n          case ReferenceType:\n            button.toCode.enabled.value = true;\n            button.toReference.enabled.value = false;\n            button.toValue.enabled.value = true;\n          case _:\n            button.toCode.enabled.value = true;\n            button.toReference.enabled.value = true;\n            button.toValue.enabled.value = false;\n        }\n      });\n\n    var filtered = field.filterOption();\n    filtered.previous().feed(function(field : ContextField)\n      field.active.value = false);\n    filtered.feed(function(field : ContextField)\n      field.active.value = true);\n\n    document.article.fragment.feed({\n      some : setFragmentStatus,\n      none : resetFragmentStatus\n    });\n  }\n\n  function resetFragmentStatus() {\n    resetFields();\n    resetAddMenuItems();\n  }\n\n  function setFragmentStatus(fragment : Fragment) {\n    setFields(fragment);\n    setAddMenuItems(fragment);\n  }\n\n  function resetFields() {\n    el.innerHTML = '';\n  }\n\n  function setFields(fragment : Fragment) {\n    resetFields();\n    mapper\n      .getAttachedPropertiesForFragment(fragment)\n      .map(function(info) {\n        var value = cast(fragment.component.properties.get(info.name), ValueProperty<Dynamic>);\n        addField(info, value);\n      });\n  }\n\n  function addField(info : ValuePropertyInfo<Dynamic>, value : ValueProperty<Dynamic>) {\n    var f = new ContextField({\n        container : el,\n        parent    : component,\n        display   : info.display,\n        name      : info.name,\n        type      : info.type,\n        value     : value,\n        model     : model,\n        modelView : modelView\n      });\n\n    f.focus\n      .filterValue(true)\n      .map(function(_) return Some(f))\n      .feed(field);\n  }\n\n  function resetAddMenuItems() {\n    button.remove.enabled.value = false;\n    button.toValue.enabled.value = false;\n    button.toCode.enabled.value = false;\n    button.toReference.enabled.value = false;\n    button.add.enabled.value = false;\n    menu.add.clear();\n  }\n\n  function setAddMenuItems(fragment : Fragment) {\n    resetAddMenuItems();\n    var attachables = mapper.getAttachablePropertiesForFragment(fragment);\n    button.add.enabled.value = attachables.length > 0;\n    attachables.map(function(info) {\n      var button = new Button('add ${info.display}');\n      menu.add.addItem(button.component);\n      button.clicks.feed(function(_) {\n        mapper.values.ensure(info.name, fragment.component);\n        setFragmentStatus(fragment);\n      });\n    });\n  }\n}","package ui;\n\nimport haxe.Json;\nimport steamer.Producer;\nimport steamer.Pulse;\nimport thx.ref.ObjectRef;\nimport thx.ref.IRef;\nimport steamer.Value;\n\nclass Data {\n  var root : ObjectRef;\n  var cache : Map<String, IRef>;\n  public var value(default, null) : Value<{}>;\n\n  public function new(data : {}) {\n    value = new Value(data);\n    reset(data);\n  }\n\n  function resolve(path : String) {\n    var ref = cache.get(path);\n    if(null == ref) {\n      ref = root.resolve(path);\n      if(ref.hasValue())\n        cache.set(path, ref);\n    }\n    return ref;\n  }\n\n  public function get(path : String) : Dynamic {\n    return resolve(path).get();\n  }\n\n  public function hasValue(path : String) : Bool {\n    return resolve(path).hasValue();\n  }\n\n  public function set(path : String, value : Dynamic) : Data {\n    var ref = resolve(path);\n    cache.set(path, ref);\n    if(ref.get() != value) {\n      ref.set(value);\n      this.value.value = toObject();\n    }\n    return this;\n  }\n\n  public function reset(value : Dynamic) : Data {\n    root = new ObjectRef(null);\n    cache = new Map();\n    if(null != value) {\n      set(\"\", value);\n    }\n    this.value.value = toObject();\n    return this;\n  }\n\n  public function remove(path : String) {\n    var ref = cache.get(path);\n    if(null == ref) {\n      ref = root.resolve(path);\n    }\n\n    if(ref.hasValue()) {\n      ref.remove();\n      this.value.value = toObject();\n    }\n    cache.remove(path);\n  }\n\n  public function rename(oldpath : String, newpath : String) {\n    if(!hasValue(oldpath) || hasValue(newpath))\n      return false;\n    var v = get(oldpath);\n    remove(oldpath);\n    set(newpath, v);\n    this.value.value = toObject();\n    return true;\n  }\n\n  public function toObject() : {} {\n    return root.get();\n  }\n\n  public function toJSON()\n    return Json.stringify(toObject());\n}","package ui;\n\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport ui.fragments.Fragment;\nimport ui.widgets.Toolbar;\nimport ui.widgets.Statusbar;\nimport steamer.Consumer;\nusing steamer.Producer;\nusing thx.core.Options;\nusing steamer.dom.Dom;\n\nclass Document {\n  public var component(default, null) : Component;\n  public var toolbar(default, null) : Toolbar;\n  public var article(default, null) : Article;\n  public var statusbar(default, null) : Statusbar;\n\n  public function new(options : ComponentOptions) {\n    component = new Component(options);\n    toolbar   = new Toolbar({ parent : component, container : component.el });\n    article   = new Article({ parent : component, container : component.el });\n    statusbar = new Statusbar({ parent : component, container : component.el });\n\n    var buttonRemove = toolbar.right.addButton('', Config.icons.remove);\n    article.fragment.toBool().feed(buttonRemove.enabled);\n\n    var buttonAdd = toolbar.left.addButton('', Config.icons.add);\n    buttonAdd.clicks.feed(function(_) {\n      article.addBlock();\n    });\n\n    buttonRemove.enabled.value = false;\n    buttonRemove.clicks.feed(function(_) {\n      article.fragment.value.toValue().component.destroy();\n      article.fragment.value = None;\n    });\n  }\n}","package ui;\n\nimport ui.Runtime;\nimport haxe.ds.Option;\n\nenum Expression {\n  Fun(f : Void -> RuntimeResult);\n  SyntaxError(msg : String);\n}\n\nclass Expressions {\n  public static function toErrorOption(exp : Expression) {\n    return switch exp {\n      case SyntaxError(e): Some(e);\n      case _: None;\n    };\n  }\n}","package ui;\n\nimport js.html.Element;\nimport sui.components.Component;\nimport ui.SchemaType;\nimport thx.Assert;\nimport ui.editors.EditorPicker;\nimport ui.editors.Editor;\nimport dom.Dom;\nimport types.TypeTransform;\n\nclass FieldValue {\n  public var type(default, null) : SchemaType;\n  public var editor(default, null) : Null<Editor<Dynamic>>;\n  var parent : Component;\n  var container : Element;\n  var afterCreate : InitFunction;\n  var afterRemove : InitFunction;\n  public function new(parent : Component, container : Element, afterCreate : InitFunction, afterRemove : InitFunction) {\n    this.parent = parent;\n    this.container = container;\n    this.afterCreate = afterCreate;\n    this.afterRemove = afterRemove;\n  }\n\n  public function setEditor(type, ?value : Dynamic) {\n    if(null != editor) {\n      if(null == value) {\n        value = TypeTransform.transform(this.type, type)(editor.value.value);\n      }\n      afterRemove(this.type, editor);\n      container.innerHTML = '';\n    }\n    this.type = type;\n    editor = EditorPicker.pick(type, container, parent, value);\n    editor.component.el.classList.add('value');\n    afterCreate(this.type, editor);\n  }\n}\n\ntypedef InitFunction = SchemaType -> Editor<Dynamic> -> Void;","package ui;\n\nimport steamer.Consumer;\nimport steamer.Feeder;\nimport steamer.Producer;\n\nclass Model {\n  public var data(default, null) : Data;\n  public var schema(default, null) : Schema;\n\n  public var dataEventConsumer(default, null) : Consumer<DataEvent>;\n  public var schemaEventConsumer(default, null) : Consumer<SchemaEvent>;\n\n  public var changes(default, null) : Producer<String>;\n  var feeder : Feeder<String>;\n\n  public function new(data : Data) {\n    this.changes = this.feeder = new Feeder();\n    this.data = data;\n    this.schema = new Schema();\n    this.dataEventConsumer = function(e : DataEvent) {\n      switch e {\n        case SetValue(path, value, type):\n          data.set(path, value);\n          feeder.forward(Emit(path));\n      }\n    };\n    this.schemaEventConsumer = function(e : SchemaEvent) {\n      switch e {\n        case ListFields(list):\n          for(item in list)\n            schema.add(item.name, item.type);\n          feeder.forward(Emit(\"\"));\n        case AddField(path, type):\n          schema.add(path, type);\n        case DeleteField(path):\n          schema.delete(path);\n          data.remove(path);\n          feeder.forward(Emit(path));\n        case RenameField(oldpath, newpath):\n          schema.rename(oldpath, newpath);\n          data.rename(oldpath, newpath);\n          feeder.forward(Emit(oldpath));\n          feeder.forward(Emit(newpath));\n        case RetypeField(path, type):\n          schema.retype(path, type);\n          feeder.forward(Emit(path));\n      }\n    };\n  }\n}","package ui;\n\nimport js.html.Element;\nimport steamer.MultiProducer;\nusing steamer.Producer;\nimport steamer.Pulse;\nimport sui.components.Component;\nimport thx.Assert;\nimport ui.DataEvent;\nimport ui.SchemaEvent;\nimport ui.widgets.Toolbar;\nimport dom.Dom;\nimport steamer.Feeder;\n\nclass ModelView {\n  public var component(default, null) : Component;\n  public var schema(default, null) : Producer<SchemaEvent>;\n  public var data(default, null) : Producer<DataEvent>;\n  public var toolbar(default, null) : Toolbar;\n  public var currentField(default, null) : Null<ModelViewField>;\n\n  var pairs : Element;\n\n  var schemaFeeder : Feeder<SchemaEvent>;\n  var dataFeeder : Feeder<DataEvent>;\n  var fields : Map<String, ModelViewField>;\n  var fieldFocus : MultiProducer<ModelViewField>;\n  var fieldBlur : MultiProducer<ModelViewField>;\n\n  public function new() {\n    component = new Component({\n      template : '<div class=\"modelview\"></div>'\n    });\n    toolbar = new Toolbar({});\n    toolbar.component.appendTo(component.el);\n\n    var buttonAdd = toolbar.left.addButton('', Config.icons.add);\n    buttonAdd.clicks.feed(function(_){\n      addField(guessFieldName(), StringType);\n    });\n\n    var buttonRemove = toolbar.right.addButton('', Config.icons.remove);\n    buttonRemove.clicks.feed(function(_) {\n      removeField(currentField);\n    });\n    buttonRemove.enabled.value = false;\n\n    pairs = Html.parse('<div class=\"fields\"><div></div></div>');\n    component.el.appendChild(pairs);\n    pairs = Query.first('div', pairs);\n\n    schema = this.schemaFeeder = new Feeder();\n    data = this.dataFeeder = new Feeder();\n\n    fields = new Map();\n\n    fieldFocus = new MultiProducer();\n    fieldFocus.feed(function(field) {\n      this.currentField = field;\n      buttonRemove.enabled.value = null != field;\n    });\n  }\n\n  public function guessFieldName() {\n    var id = 0,\n      prefix = 'field',\n      t;\n    function assemble(id)\n      return id > 0 ? [prefix, '$id'].join('_') : prefix;\n    while(fields.exists(t = assemble(id))) id++;\n    return t;\n  }\n\n  public function removeFieldByName(name : String) {\n    var field = fields.get(name);\n    removeField(field);\n  }\n\n  public function removeField(field : ModelViewField) {\n    Assert.notNull(field, 'when removing a field it should not be null');\n    var name = field.key.value.value;\n    field.destroy();\n    if(fields.remove(name)) {\n      schemaFeeder.forward(Emit(DeleteField(name)));\n    }\n  }\n\n  public function setField(path : String, value : Dynamic, type : SchemaType) {\n    if(path == \"\" || path == null)\n      return;\n    var field = fields.get(path);\n    if(null == field)\n      field = addField(path, type);\n    field.value.value.value = types.TypeTransform.transform(type, field.value.type)(value);\n  }\n\n  public function addField(name : String, type : SchemaType) {\n    var field = new ModelViewField({\n      container : pairs,\n      parent : component,\n      key : name\n    });\n\n    // setup field key\n    var oldname = null;\n\n    function createSetValue() {\n      return SetValue(field.key.value.value, field.value.value.value, field.value.type);\n    }\n\n    field.key.value\n      .filter(function(newname : String) {\n        // check that it doesn't exist already\n        if(fields.exists(newname)) {\n          // if exists revert and don't propagate\n          field.key.value.value = oldname;\n          return false;\n        } else {\n          return true;\n        }\n      })\n      .map(function(newname : String) {\n        if(null == oldname) {\n          // new field\n          oldname = newname;\n          return AddField(newname, field.value.type);\n        } else {\n          // rename field name in fields\n          var v = fields.get(oldname);\n          fields.remove(oldname);\n          fields.set(newname, v);\n          var r = RenameField(oldname, newname);\n          oldname = newname;\n          return r;\n        }\n      })\n      .feed(schemaFeeder);\n\n    // setup field value\n    // TODO support multiple editors data types\n    // the debounce is not only practical to avoid too many calls\n    // but also helps so that data events occur after schema\n    // events (not the best synch mechanism ever)\n    field.value.value.map(function(_ : String) {\n      return createSetValue();\n    }).debounce(250).feed(dataFeeder);\n    fieldFocus.add(field.focus.map(function(v) return v ? field : null));\n\n    fields.set(name, field);\n\n    return field;\n  }\n}","package ui;\n\nimport steamer.Producer;\nimport dom.Dom;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport sui.properties.ToggleClass;\nimport ui.editors.TextEditor;\n\nclass ModelViewField {\n  public var component(default, null) : Component;\n  public var key(default, null) : TextEditor;\n  public var value(default, null) : TextEditor;\n  public var focus(default, null) : Producer<Bool>;\n\n  var classActive : ToggleClass;\n\n  public function new(options : FieldEditableKeyOptions) {\n    if(null == options.template && null == options.el)\n      options.template = '<div class=\"field\"><div class=\"key-container\"><div class=\"key\"></div></div><div class=\"value-container\"><div class=\"value\"></div></div></div>';\n\n    component = new Component(options);\n    // setup field key\n    key = new TextEditor({\n      el : Query.first('.key', component.el),\n      parent : component,\n      defaultText : options.key,\n      placeHolder : 'key'\n    });\n\n    // setup field value\n    // TODO support multiple editors data types\n    value = new TextEditor({\n      el : Query.first('.value', component.el),\n      parent : component,\n      defaultText : '',\n      placeHolder : 'value'\n    });\n    // 250 is kind of a magic value and it is enough\n    // to be able to click on a button\n    // and not have lost focus in the meanwhile\n    var f = key.focus.merge(value.focus);\n    focus = f.debounce(250).distinct();\n    classActive = new ToggleClass(component, 'active');\n    f.feed(classActive.stream);\n  }\n\n  public function destroy() {\n    classActive.dispose();\n    component.destroy();\n    key = null;\n    value = null;\n    focus = null;\n  }\n}\n\ntypedef FieldEditableKeyOptions = {>ComponentOptions,\n  key : String\n}","package ui;\n\nimport haxe.ds.Option;\nusing thx.core.Set;\nusing thx.core.Iterables;\nimport ui.Expression;\nimport ui.Scope;\n\nclass Runtime {\n  static function createFunction(args : Array<String>, code : String) : Dynamic -> Dynamic -> Dynamic\n    return (untyped __js__('new Function'))(args.join(','), code);\n\n  static function formatCode(code : String, scope : Dynamic) {\n    var prelim = Reflect.fields(scope)\n      .map(function(field) {\n        return 'var $field = scope.$field;';\n      })\n      .join('\\n');\n    return '$prelim\ndelete scope;\nreturn $code;';\n  }\n\n  static var pattern = ~/\\$\\.(.+?)\\b/;\n  // TODO poorman implementation\n  public static function extractDependencies(code : String) {\n    var set = new Set();\n    while(pattern.match(code)) {\n      set.add(pattern.matched(1));\n      code = pattern.matchedRight();\n    }\n    return set.order(thx.core.Strings.compare);\n  }\n\n  public static function toRuntime(code : String, model : Model) : Runtime {\n    var expression = try {\n        var scope = new Scope();\n        var formatted = formatCode(code, scope);\n        var f = createFunction(['$', 'scope'], formatted);\n\n        Fun(function() try return Result(f(model.data.toObject(), scope)) catch(e : Dynamic) return Error(Std.string(e)));\n      } catch(e : Dynamic) {\n        SyntaxError(Std.string(e));\n      };\n    return new Runtime(expression, code);\n  }\n\n  public static function toErrorOption(runtime : Runtime) : Option<String>\n    return switch runtime.expression {\n      case SyntaxError(e): Some(e);\n      case _: None;\n    };\n\n  public var expression(default, null) : Expression;\n  public var code(default, null) : String;\n  public var dependencies(default, null) : Array<String>;\n  public function new(expression : Expression, code : String) {\n    this.expression = expression;\n    this.code = code;\n    this.dependencies = extractDependencies(code);\n  }\n}\n\nenum RuntimeResult {\n  Result(value : Dynamic);\n  Error(msg : String);\n}","package ui;\n\nimport steamer.Consumer;\nimport steamer.Feeder;\nimport steamer.Producer;\nimport steamer.Pulse;\nimport thx.core.Error;\nimport ui.SchemaEvent;\n\nclass Schema {\n  var fields : Map<String, SchemaType>;\n  public var stream(default, null) : Producer<SchemaEvent>;\n  var feeder : Feeder<SchemaEvent>;\n\n  public function new() {\n    fields = new Map();\n    stream = feeder = new Feeder();\n  }\n\n  public function add(name : String, type : SchemaType) {\n    if(fields.exists(name))\n      throw new Error('Schema already contains a field \"$name\"');\n    fields.set(name, type);\n    feeder.forward(Emit(AddField(name, type)));\n  }\n\n  public function reset(?list : Array<FieldPair>) {\n    if(null == list)\n      list = [];\n    fields = new Map();\n    list.map(function(pair) {\n      fields.set(pair.name, pair.type);\n    });\n    feeder.forward(Emit(ListFields(list.copy())));\n  }\n\n  public function delete(name : String) {\n    if(!fields.exists(name))\n      throw new Error('Schema does not contain a field \"${name}\"');\n    fields.remove(name);\n    feeder.forward(Emit(DeleteField(name)));\n  }\n\n  public function rename(oldname : String, newname : String) {\n    if(!fields.exists(oldname))\n      throw new Error('Schema does not contain a field \"${oldname}\"');\n    var type = fields.get(oldname);\n    fields.remove(oldname);\n    fields.set(newname, type);\n    feeder.forward(Emit(RenameField(oldname, newname)));\n  }\n\n  public function retype(name : String, type : SchemaType) {\n    if(!fields.exists(name))\n      throw new Error('Schema does not contain a field \"${name}\"');\n    fields.set(name, type);\n    feeder.forward(Emit(RetypeField(name, type)));\n  }\n\n  public function get(name : String) {\n    return fields.get(name);\n  }\n\n  public function exists(name : String) {\n    return fields.exists(name);\n  }\n\n  public function getFieldNames() {\n    var arr = [];\n    for(key in fields.keys())\n      arr.push(key);\n    return arr;\n  }\n\n  public function getPairs() {\n    return getFieldNames().map(function(key) {\n      return {\n        name : key,\n        type : fields.get(key)\n      };\n    });\n  }\n}","package ui;\n\nclass Scope {\n  public var name : String = \"Franco\";\n  public function new() {}\n}","package ui.editors;\n\nusing steamer.Producer;\nimport js.html.KeyboardEvent;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport steamer.Value;\nimport sui.properties.Text;\nimport ui.SchemaType;\nusing steamer.dom.Dom;\n\nclass BoolEditor implements Editor<Bool> {\n  public var component(default, null) : Component;\n  public var focus(default, null) : Value<Bool>;\n  public var value(default, null) : Value<Bool>;\n  public var type(default, null) : SchemaType;\n  var cancel : Void -> Void;\n  public function new(options : BoolEditorOptions) {\n    type = BoolType;\n    if(null == options.defaultValue)\n      options.defaultValue = false;\n    if(null == options.el && null == options.template)\n      options.template = '<div></div>';\n    component = new Component(options);\n    var cls = component.el.classList;\n    cls.add('fa');\n    cls.add('editor');\n    cls.add('bool');\n    cls.add('fa-' + Config.icons.unchecked);\n    component.el.setAttribute('tabindex', '0');\n\n    value = new Value(options.defaultValue);\n    var clickPair    = component.el.produceEvent('click'),\n      focusPair    = component.el.produceEvent('focus'),\n      blurPair     = component.el.produceEvent('blur'),\n      keyboardPair = component.el.produceKeyboardEvent('up');\n\n    value\n      .feed(component.el.consumeToggleClass('fa-' + Config.icons.checked));\n    value\n      .negate()\n      .feed(component.el.consumeToggleClass('fa-' + Config.icons.unchecked));\n\n    clickPair.producer\n      .toNil()\n      .merge(\n        keyboardPair.producer\n          .filter(function(e : KeyboardEvent) {\n            return switch e.keyCode {\n              case 32, 13: // spacebar, return\n                true;\n              case _:\n                false;\n            };\n          })\n          .toNil()\n      )\n      .map(function(_) return !value.value)\n      .feed(value);\n\n    focus = new Value(false);\n    focus.filterValue(true).feed(component.el.consumeFocus());\n    focusPair.producer\n      .map(function(_) return true)\n      .merge(\n        blurPair.producer\n          .map(function(_) return false)\n      ).feed(focus);\n    cancel = function() {\n      clickPair.cancel();\n      focusPair.cancel();\n      blurPair.cancel();\n      keyboardPair.cancel();\n    };\n  }\n\n  public function destroy() {\n    cancel();\n    component.destroy();\n    value.end();\n  }\n}\n\ntypedef BoolEditorOptions = {> ComponentOptions,\n  defaultValue : Bool\n}","package ui.editors;\n\nusing steamer.Producer;\nimport js.html.Element;\nimport js.html.Event;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport steamer.Value;\nimport sui.properties.Text;\nimport ui.SchemaType;\nusing steamer.dom.Dom;\nimport js.Browser;\n\nclass TextEditor implements Editor<String> {\n  public var component(default, null) : Component;\n  public var focus(default, null) : Value<Bool>;\n  public var value(default, null) : Value<String>;\n  public var type(default, null) : SchemaType;\n  var cancel : Void -> Void;\n  public function new(options : TextEditorOptions) {\n    type = StringType;\n    if(null == options.defaultText)\n      options.defaultText = '';\n    if(null == options.placeHolder)\n      options.placeHolder = '';\n    if(null == options.el && null == options.template)\n      options.template = '<div></div>';\n    if(null == options.inputEvent)\n      options.inputEvent = function(component : Component) return component.el.produceEvent('input');\n\n    component = new Component(options);\n    component.el.classList.add('editor');\n    component.el.setAttribute('tabindex', '0');\n    component.el.setAttribute('placeholder', options.placeHolder);\n\n    // TODO find out how to set the content of :before programmatically\n    component.el.style.content = options.placeHolder;\n\n    var text       = new Text(component, options.defaultText),\n      inputPair  = options.inputEvent(component),\n      changePair = component.el.produceEvent('input'),\n      focusPair  = component.el.produceEvent('focus'),\n      blurPair   = component.el.produceEvent('blur');\n\n    value = text.stream;\n    inputPair.producer\n      .map(function(_) return text.component.el.textContent)\n      .feed(value);\n\n    focus = new Value(false);\n    focus.feed(component.el.consumeToggleAttribute('contenteditable', 'true'));\n    focus.filterValue(true).feed(component.el.consumeFocus());\n    focus\n      .filterValue(true)\n      .feed(function(_) {\n        Browser.document.getSelection().selectAllChildren(component.el);\n      });\n\n    focusPair.producer\n      .map(function(_) return true)\n      .merge(\n        blurPair.producer\n          .map(function(_) return false)\n      ).feed(focus);\n    cancel = function() {\n      text.dispose();\n      changePair.cancel();\n      inputPair.cancel();\n      focusPair.cancel();\n      blurPair.cancel();\n    };\n\n    var empty = new Value(options.defaultText == '');\n    changePair.producer\n      .map(function(_) return text.component.el.textContent == '')\n      .merge(value.map(function(t) return t ==''))\n      .feed(empty);\n    empty.feed(component.el.consumeToggleClass('empty'));\n  }\n\n  public function destroy() {\n    value.end();\n    component.destroy();\n    cancel();\n  }\n}\n\ntypedef TextEditorOptions = {> ComponentOptions,\n  defaultText : String,\n  ?placeHolder : String,\n  ?inputEvent : Component -> { producer : Producer<Event>, cancel : Void -> Void }\n}","package ui.editors;\n\nimport steamer.Producer;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport steamer.Value;\nimport sui.properties.Text;\nimport ui.SchemaType;\nimport ui.editors.TextEditor;\nusing steamer.dom.Dom;\n\nclass CodeEditor extends TextEditor {\n  public function new(options : TextEditorOptions) {\n    if(null == options.inputEvent)\n      options.inputEvent = function(component : Component) return component.el.produceEvent('blur');\n    super(options);\n    component.el.classList.add('code');\n  }\n}","package ui.editors;\n\nusing steamer.Producer;\nimport js.html.KeyboardEvent;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport steamer.Value;\nimport sui.properties.Text;\nimport ui.SchemaType;\nusing steamer.dom.Dom;\n\nclass DateEditor implements Editor<Date> {\n  public var component(default, null) : Component;\n  public var focus(default, null) : Value<Bool>;\n  public var value(default, null) : Value<Date>;\n  public var type(default, null) : SchemaType;\n  var cancel : Void -> Void;\n  public function new(options : DateEditorOptions) {\n    type = BoolType;\n    if(null == options.defaultValue)\n      options.defaultValue = Date.now();\n    if(null == options.template)\n      options.template = '<input type=\"date\"/>';\n\n    component = new Component(options);\n\n    var cls = component.el.classList;\n    cls.add('editor');\n    cls.add('date');\n    component.el.setAttribute('tabindex', '0');\n\n    value = new Value(options.defaultValue);\n    var inputPair    = component.el.produceEvent('input'),\n      focusPair    = component.el.produceEvent('focus'),\n      blurPair     = component.el.produceEvent('blur');\n\n    focus = new Value(false);\n    focus.filterValue(true).feed(component.el.consumeFocus());\n    focusPair.producer\n      .map(function(_) return true)\n      .merge(\n        blurPair.producer\n          .map(function(_) return false)\n      ).feed(focus);\n\n    inputPair.producer\n      .map(function(_) {\n        return (cast component.el : js.html.InputElement).valueAsDate;\n      })\n      .feed(value);\n    cancel = function() {\n      inputPair.cancel();\n      focusPair.cancel();\n      blurPair.cancel();\n    };\n  }\n\n  public function destroy() {\n    cancel();\n    component.destroy();\n    value.end();\n  }\n}\n\ntypedef DateEditorOptions = {> ComponentOptions,\n  defaultValue : Date\n}","package ui.editors;\n\nimport js.html.Element;\nimport sui.components.Component;\nimport ui.SchemaType;\n\nclass EditorPicker {\n  public static function pick(type : SchemaType, el : Element, parent : Component, value : Dynamic) : Editor<Dynamic> {\n    return switch type {\n      case BoolType:\n        new BoolEditor({ container : el, parent : parent, defaultValue : value });\n      case CodeType:\n        new CodeEditor({ container : el, parent : parent, defaultText : value, placeHolder : 'code' });\n      case ReferenceType:\n        new ReferenceEditor({ container : el, parent : parent, defaultText : value, placeHolder : 'reference' });\n      case StringType:\n        new TextEditor({ container : el, parent : parent, defaultText : value, placeHolder : 'content' });\n      case DateType:\n        new DateEditor({ container : el, parent : parent, defaultValue : value });\n      case FloatType:\n        new FloatEditor({ container : el, parent : parent, defaultValue : value });\n      case _:\n        throw 'Editor for $type has not been implemented yet';\n    }\n  }\n}","package ui.editors;\n\nusing steamer.Producer;\nimport js.html.KeyboardEvent;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport steamer.Value;\nimport sui.properties.Text;\nimport ui.SchemaType;\nusing steamer.dom.Dom;\n\nclass FloatEditor implements Editor<Float> {\n  public var component(default, null) : Component;\n  public var focus(default, null) : Value<Bool>;\n  public var value(default, null) : Value<Float>;\n  public var type(default, null) : SchemaType;\n  var cancel : Void -> Void;\n  public function new(options : FloatEditorOptions) {\n    type = BoolType;\n    if(null == options.defaultValue)\n      options.defaultValue = 0.0;\n    if(null == options.template)\n      options.template = '<input type=\"number\"/>';\n\n    component = new Component(options);\n\n    var cls = component.el.classList;\n    cls.add('editor');\n    cls.add('float');\n    component.el.setAttribute('tabindex', '0');\n\n    value = new Value(options.defaultValue);\n    var inputPair    = component.el.produceEvent('input'),\n      focusPair    = component.el.produceEvent('focus'),\n      blurPair     = component.el.produceEvent('blur');\n\n    focus = new Value(false);\n    focus.filterValue(true).feed(component.el.consumeFocus());\n    focusPair.producer\n      .map(function(_) return true)\n      .merge(\n        blurPair.producer\n          .map(function(_) return false)\n      ).feed(focus);\n\n    inputPair.producer\n      .map(function(_) {\n        return (cast component.el : js.html.InputElement).valueAsNumber;\n      })\n      .feed(value);\n    cancel = function() {\n      inputPair.cancel();\n      focusPair.cancel();\n      blurPair.cancel();\n    };\n  }\n\n  public function destroy() {\n    cancel();\n    component.destroy();\n    value.end();\n  }\n}\n\ntypedef FloatEditorOptions = {> ComponentOptions,\n  defaultValue : Float\n}","package ui.editors;\n\nimport steamer.Producer;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport steamer.Value;\nimport sui.properties.Text;\nimport ui.SchemaType;\nimport ui.editors.TextEditor;\nusing steamer.dom.Dom;\n\nclass ReferenceEditor extends TextEditor {\n  public function new(options : TextEditorOptions) {\n    if(null == options.inputEvent)\n      options.inputEvent = function(component : Component) return component.el.produceEvent('blur');\n    super(options);\n    component.el.classList.add('reference');\n  }\n}","package ui.fragments;\n\nimport steamer.Value;\nimport sui.components.Component;\nimport sui.properties.ToggleClass;\nimport ui.editors.TextEditor;\n\nclass Block implements Fragment {\n  public var name(default, null) : String = 'block';\n  public var editor(default, null) : TextEditor;\n  public var component(default, null) : Component;\n  public var focus(default, null) : Value<Bool>;\n  public var active(default, null) : Value<Bool>;\n  public var uid(default, null) : String;\n  public function new(options : BlockOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<section class=\"block\"></div>';\n    uid = null != options.uid ? options.uid : thx.core.UUID.create();\n    if(null == options.placeHolder)\n      options.placeHolder = 'block content';\n    editor = new TextEditor(options);\n    active = new Value(false);\n    active.feed(new ToggleClass(editor.component, 'active').stream);\n    focus = editor.focus;\n    component = editor.component;\n  }\n\n  public function destroy() {\n    editor.destroy();\n  }\n\n  public function toString()\n    return name;\n}\n\ntypedef BlockOptions = {> TextEditorOptions,\n  ?uid : String\n}","package ui.fragments;\n\nimport sui.properties.ValueProperties;\nimport ui.fragments.FragmentProperties;\nusing thx.core.Iterators;\n\nclass FragmentMapper {\n  public var fragments(default, null) : FragmentProperties;\n  public var values(default, null) : ValueProperties;\n  public function new(fragments : FragmentProperties, values : ValueProperties) {\n    this.fragments = fragments;\n    this.values = values;\n  }\n\n  public function getValuePropertyInfoForFragment(fragment : FragmentName)\n    return fragments.getAssociations(fragment)\n      .map(values.get);\n\n\n  public function getAttachedPropertiesForFragment(fragment : Fragment)\n    return fragments.getAssociations(fragment)\n      .filter(function(name) return fragment.component.properties.exists(name))\n      .map(values.get);\n\n  public function getAttachablePropertiesForFragment(fragment : Fragment)\n    return fragments.getAssociations(fragment)\n      .filter(function(name) return !fragment.component.properties.exists(name))\n      .map(values.get);\n}","package ui.fragments;\n\nabstract FragmentName(String) {\n  @:from public inline static function fromFragment(fragment : Fragment)\n    return new FragmentName(fragment.name);\n\n  @:from public inline static function fromString(name : String)\n    return new FragmentName(name);\n\n  public inline function new(name : String)\n    this = name;\n\n  @:to public inline function toString()\n    return this;\n}","package ui.fragments;\n\nimport thx.core.Set;\nimport sui.properties.PropertyName;\nusing thx.core.Iterables;\n\nclass FragmentProperties {\n  var map : Map<String, Set<String>>;\n  public function new() {\n    map = new Map();\n  }\n\n  public function associate(fragment : FragmentName, property : PropertyName) {\n    var s = map.get(fragment);\n    if(null == s)\n      map.set(fragment, s = new Set());\n    s.add(property);\n  }\n\n  public function associateMany(fragment : FragmentName, properties : Iterable<PropertyName>)\n    properties.map(associate.bind(fragment, _));\n\n  public function getAssociations(fragment : FragmentName) : Iterator<String> {\n    var s = map.get(fragment);\n    if(s == null)\n      s = new Set();\n    return s.iterator();\n  }\n}","package ui.fragments;\n\nimport steamer.Value;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nusing steamer.dom.Dom;\n\nclass ReadonlyBlock implements Fragment {\n  public var name(default, null) : String = 'readonly';\n  public var component(default, null) : Component;\n  public var focus(default, null) : Value<Bool>;\n  public var active(default, null) : Value<Bool>;\n  public var uid(default, null) : String;\n\n  var focusEvent : EventProducer;\n  var blurEvent : EventProducer;\n  public function new(options : FragmentOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<section class=\"readonly block\" tabindex=\"0\">readonly</div>';\n\n    component = new Component(options);\n    focus = new Value(false);\n    active = new Value(false);\n    focusEvent = component.el.produceEvent('focus');\n    blurEvent  = component.el.produceEvent('blur');\n    uid = null != options.uid ? options.uid : thx.core.UUID.create();\n\n    focusEvent.producer\n      .map(function(_) return true)\n      .merge(blurEvent\n        .producer\n        .map(function(_) return false))\n      .feed(focus);\n\n    active.feed(function(isActive) {\n      if(isActive)\n        component.el.classList.add('active');\n      else\n        component.el.classList.remove('active');\n    });\n  }\n\n  public function destroy() {\n    focusEvent.cancel();\n    blurEvent.cancel();\n    component.destroy();\n  }\n\n  public function toString()\n    return name;\n}","package ui.widgets;\n\nimport js.html.Event;\nimport steamer.Producer;\nimport steamer.Value;\nimport sui.components.Component;\nusing steamer.dom.Dom;\n\nclass Button {\n  public var component(default, null) : Component;\n  public var clicks(default, null) : Producer<Event>;\n  public var enabled(default, null) : Value<Bool>;\n  var cancel : Void -> Void;\n  public function new(text = '', ?icon : String) {\n    component = new Component({\n      template : null == icon\n        ? '<button>$text</button>'\n        : '<button class=\"fa fa-$icon\">$text</button>'\n    });\n    var pair = component.el.produceEvent('click');\n    clicks = pair.producer;\n    cancel = pair.cancel;\n\n    enabled = new Value(true);\n    enabled.feed(function(value : Bool) {\n      if(value)\n        component.el.removeAttribute(\"disabled\");\n      else\n        component.el.setAttribute(\"disabled\", \"disabled\");\n    });\n  }\n\n  public function destroy() {\n    cancel();\n    component.destroy();\n  }\n}","package ui.widgets;\n\nimport js.Browser;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\nimport js.html.Element;\nimport thx.Assert;\nimport dom.Dom;\n\nclass Menu extends FrameOverlay {\n  var items : Map<Component, Element>;\n  var ul : Element;\n  public function new(options : ComponentOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<menu class=\"frame-overlay\"><ul></ul></menu>';\n    super(options);\n    ul = Query.first('ul', component.el);\n    items = new Map();\n  }\n\n  public function clear() {\n    ul.innerHTML = '';\n    items = new Map();\n  }\n\n  public function addItem(item : Component) {\n    var el = Browser.document.createLIElement();\n    item.appendTo(el);\n    component.add(item);\n    ul.appendChild(el);\n    items.set(item, el);\n  }\n\n  public function removeItem(item : Component) {\n    Assert.notNull(item);\n    Assert.isTrue(items.exists(item));\n    var el = items.get(item);\n    item.detach();\n    ul.removeChild(el);\n  }\n}","package ui.widgets;\n\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\n\nclass Statusbar {\n  public var component(default, null) : Component;\n  public function new(options : ComponentOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<footer class=\"statusbar\"></footer>';\n    component = new Component(options);\n  }\n}","package ui.widgets;\n\nimport dom.Dom;\nimport js.html.Element;\nimport sui.components.Component;\nimport sui.components.ComponentOptions;\n\nclass Toolbar {\n  public var component(default, null) : Component;\n  public var left(default, null) : ToolbarGroup;\n  public var center(default, null) : ToolbarGroup;\n  public var right(default, null) : ToolbarGroup;\n  public function new(options : ComponentOptions) {\n    if(null == options.el && null == options.template)\n      options.template = '<header class=\"toolbar\"><div><div class=\"left\"></div><div class=\"center\"></div><div class=\"right\"></div></div></header>';\n    component = new Component(options);\n    left   = new ToolbarGroup(Query.first('.left', component.el), component);\n    center = new ToolbarGroup(Query.first('.center', component.el), component);\n    right  = new ToolbarGroup(Query.first('.right', component.el), component);\n  }\n}\n\nclass ToolbarGroup {\n  public var el(default, null) : Element;\n  var component : Component;\n\n  public function new(el : Element, component : Component) {\n    this.el = el;\n    this.component = component;\n  }\n\n  public function addButton(text = '', ?icon : String) {\n    var button = new Button(text, icon);\n    button.component.appendTo(el);\n    component.add(button.component);\n    return button;\n  }\n}","class Config {\n  public static var icons(default, null) = {\n    add : 'plus-circle',\n    remove : 'ban',\n    dropdown : 'reorder',\n    checked : 'dot-circle-o',\n    unchecked : 'circle-o',\n    switchtype : 'bolt',\n    code : 'bolt',\n    value : 'pencil',\n    reference : 'link',\n  };\n\n  public static var selectors(default, null) = {\n    app : '.card'\n  };\n}"],
"names":[],
"mappings":"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qB;;kCAGhB,lBACZ;CAAO,AAAqB;;mCAGhB,nBACZ;CAAO,AAAuB;;oCAGlB,pBACZ;CAAO,AAAyB;;oCAGpB,pBACZ;CAAO,AAAyB;;kCAGpB,lBAAyC;CACrD,EAAQ,FAAY;CACb,AAAC,GAAK,HAAS,KAAK,HAAG;;uCAGlB,vBACZ;CAAO,GAAQ,HAAS,KAAI;;;;gCC/BhB,hBACZ;CAAO,AAAS,AAAc,AAAQ;;+BAG1B,fACZ;CAAc,AAAS;CAAhB,KAAO;KACP,AAAI,AAAO,AAAM,AAAS;EAAK;;EAC5B;;;+BAIE,fACZ;CAAO,GACL;CAAgB;;EAEhB;;;gCAIU,hBACZ;CAAO,AAAe,AAAS;;iCAGnB,jBACZ;CAAO,AAAwB,AAAC,AAAS;;iCAG7B,jBACZ;CAAO,GAAQ,HAAQ,KAAS;;+BAGpB,fACZ;CAAO,MAAC,JAAK,FAAS,AAAgB,AAAK,EAAS;;oCAGxC,pBACZ;CAAQ;;;;gCC/BI,NACZ;CAAO,KAAO;KACP;EACH,IAAO;KACA;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;;;KAED;EACH,IAAO;KACA;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;;;KAED;EACH,IAAO;KACA;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;;;KAED;EACH,IAAO;KACA;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;;;KAED;EACH,IAAO;KACA;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;;;KAED;EACH,IAAO;KACA;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;;;KAED;EACH,IAAO;KACA;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;KACG;GACH;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"
}