{
"version":3,
"file":"test.js",
"sourceRoot":"file://",
"sources":["/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/js/_std/EReg.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/js/_std/HxOverrides.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/Lambda.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/List.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/js/_std/Reflect.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/js/_std/Std.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/StringBuf.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/StringTools.hx","/Users/francoponticelli/projects/cards/test/TestAll.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/js/_std/Type.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/haxe/CallStack.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/haxe/Log.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/haxe/Timer.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/js/_std/haxe/ds/IntMap.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/js/_std/haxe/ds/ObjectMap.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/js/_std/haxe/ds/StringMap.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/haxe/io/Eof.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/js/Boot.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Arrays.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Functions.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Ints.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Iterables.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Iterators.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Objects.hx","/Users/francoponticelli/projects/thx.core/src/thx/core/Types.hx","/Users/francoponticelli/projects/cards/src/thx/ref/BaseRef.hx","/Users/francoponticelli/projects/cards/src/thx/ref/ArrayRef.hx","/Users/francoponticelli/projects/cards/src/thx/ref/ObjectRef.hx","/Users/francoponticelli/projects/cards/src/thx/ref/Ref.hx","/Users/francoponticelli/projects/cards/src/thx/ref/UnknownRef.hx","/Users/francoponticelli/projects/cards/src/thx/ref/ValueRef.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/Assert.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/Dispatcher.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/Runner.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/TestFixture.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/TestHandler.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/TestResult.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/ui/Report.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/ui/common/ClassResult.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/ui/common/FixtureResult.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/ui/common/PackageResult.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/ui/common/ReportTools.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/ui/common/ResultAggregator.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/ui/common/ResultStats.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/ui/text/HtmlReport.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/ui/text/PlainTextReport.hx","/usr/lib/haxe/lib/utest/1,1,3/utest/ui/text/PrintReport.hx","/usr/local/Cellar/haxe/3.1.3/lib/haxe/std/Math.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\n\tvar r : Dynamic;\n\n\tpublic function new( r : String, opt : String ) : Void {\n\t\topt = opt.split(\"u\").join(\"\"); // 'u' (utf8) depends on page encoding\n\t\tthis.r = untyped __new__(\"RegExp\",r,opt);\n\t}\n\n\tpublic function match( s : String ) : Bool {\n\t\tif( r.global ) r.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched( n : Int ) : String {\n\t\treturn if( r.m != null && n >= 0 && n < r.m.length ) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn r.s.substr(0,r.m.index);\n\t}\n\n\tpublic function matchedRight() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\tvar sz = r.m.index+r.m[0].length;\n\t\treturn r.s.substr(sz,r.s.length-sz);\n\t}\n\n\tpublic function matchedPos() : { pos : Int, len : Int } {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn { pos : r.m.index, len : r.m[0].length };\n\t}\n\n\tpublic function matchSub( s : String, pos : Int, len : Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match( len < 0 ? s.substr(pos) : s.substr(pos,len) );\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split( s : String ) : Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn untyped s.replace(r,d).split(d);\n\t}\n\n\tpublic function replace( s : String, by : String ) : String {\n\t\treturn untyped s.replace(r,by);\n\t}\n\n\tpublic function map( s : String, f : EReg -> String ) : String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\t#if mt\n\t\tvar x = (cast s).cca(index);\n\t\t#else\n\t\tvar x = (cast s).charCodeAt(index);\n\t\t#end\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn untyped undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif( pos != null && pos != 0 && len != null && len < 0 ) return \"\";\n\t\tif( len == null ) len = s.length;\n\t\tif( pos < 0 ){\n\t\t\tpos = s.length + pos;\n\t\t\tif( pos < 0 ) pos = 0;\n\t\t}else if( len < 0 ){\n\t\t\tlen = s.length + len - pos;\n\t\t}\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if !js_es5\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\n#if mt\n\t\tif( String.prototype.cca == null ) String.prototype.cca = String.prototype.charCodeAt;\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tThe `Lambda` class is a collection of methods to support functional\n\tprogramming. It is ideally used with 'using Lambda' and then acts as an\n\textension to Iterable types.\n\n\tOn static platforms, working with the Iterable structure might be slower\n\tthan performing the operations directly on known types, such as Array and\n\tList.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\nclass Lambda {\n\n\t/**\n\t\tCreates an Array from Iterable `it`.\n\n\t\tIf `it` is an Array, this function returns a copy of it.\n\t**/\n\tpublic static function array<A>( it : Iterable<A> ) : Array<A> {\n\t\tvar a = new Array<A>();\n\t\tfor(i in it)\n\t\t\ta.push(i);\n\t\treturn a;\n\t}\n\n\t/**\n\t\tCreates a List form Iterable `it`.\n\n\t\tIf `it` is a List, this function returns a copy of it.\n\t**/\n\tpublic static function list<A>( it : Iterable<A> ) : List<A> {\n\t\tvar l = new List<A>();\n\t\tfor(i in it)\n\t\t\tl.add(i);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tCreates a new List by applying function `f` to all elements of `it`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function map<A,B>( it : Iterable<A>, f : A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tfor( x in it )\n\t\t\tl.add(f(x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tSimilar to map, but also passes the index of each element to `f`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function mapi<A,B>( it : Iterable<A>, f : Int -> A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tvar i = 0;\n\t\tfor( x in it )\n\t\t\tl.add(f(i++,x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tTells if `it` contains `elt`.\n\n\t\tThis function returns true as soon as an element is found which is equal\n\t\tto `elt` according to the `==` operator.\n\n\t\tIf no such element is found, the result is false.\n\t**/\n\tpublic static function has<A>( it : Iterable<A>, elt : A ) : Bool {\n\t\tfor( x in it )\n\t\t\tif( x == elt )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `it` contains an element for which `f` is true.\n\n\t\tThis function returns true as soon as an element is found for which a\n\t\tcall to `f` returns true.\n\n\t\tIf no such element is found, the result is false.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function exists<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `f` is true for all elements of `it`.\n\n\t\tThis function returns false as soon as an element is found for which a\n\t\tcall to `f` returns false.\n\n\t\tIf no such element is found, the result is true.\n\n\t\tIn particular, this function always returns true if `it` is empty.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function foreach<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( !f(x) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tCalls `f` on all elements of `it`, in order.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function iter<A>( it : Iterable<A>, f : A -> Void ) {\n\t\tfor( x in it )\n\t\t\tf(x);\n\t}\n\n\t/**\n\t\tReturns a List containing those elements of `it` for which `f` returned\n\t\ttrue.\n\n\t\tIf `it` is empty, the result is the empty List even if `f` is null.\n\n\t\tOtherwise if `f` is null, the result is unspecified.\n\t**/\n\tpublic static function filter<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tvar l = new List<A>();\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tFunctional fold on Iterable `it`, using function `f` with start argument\n\t\t`first`.\n\n\t\tIf `it` has no elements, the result is `first`.\n\n\t\tOtherwise the first element of `it` is passed to `f` alongside `first`.\n\t\tThe result of that call is then passed to `f` with the next element of\n\t\t`it`, and so on until `it` has no more elements.\n\n\t\tIf `it` or `f` are null, the result is unspecified.\n\t**/\n\tpublic static function fold<A,B>( it : Iterable<A>, f : A -> B -> B, first : B ) : B {\n\t\tfor( x in it )\n\t\t\tfirst = f(x,first);\n\t\treturn first;\n\t}\n\n\t/**\n\t\tReturns the number of elements in `it` for which `pred` is true, or the\n\t\ttotal number of elements in `it` if `pred` is null.\n\n\t\tThis function traverses all elements.\n\t**/\n\tpublic static function count<A>( it : Iterable<A>, ?pred : A -> Bool ) {\n\t\tvar n = 0;\n\t\tif( pred == null )\n\t\t\tfor( _ in it )\n\t\t\t\tn++;\n\t\telse\n\t\t\tfor( x in it )\n\t\t\t\tif( pred(x) )\n\t\t\t\t\tn++;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tTells if Iterable `it` does not contain any element.\n\t**/\n\tpublic static function empty<T>( it : Iterable<T> ) : Bool {\n\t\treturn !it.iterator().hasNext();\n\t}\n\n\t/**\n\t\tReturns the index of the first element `v` within Iterable `it`.\n\n\t\tThis function uses operator `==` to check for equality.\n\n\t\tIf `v` does not exist in `it`, the result is -1.\n\t**/\n\tpublic static function indexOf<T>( it : Iterable<T>, v : T ) : Int {\n\t\tvar i = 0;\n\t\tfor( v2 in it ) {\n\t\t\tif( v == v2 )\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t\tReturns the first element of `it` for which `f` is true.\n\n\t\tThis function returns as soon as an element is found for which a call to\n\t\t`f` returns true.\n\n\t\tIf no such element is found, the result is null.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function find<T>( it : Iterable<T>, f : T -> Bool ) : Null<T> {\n\t\tfor( v in it ) {\n\t\t\tif(f(v)) return v;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tReturns a new List containing all elements of Iterable `a` followed by\n\t\tall elements of Iterable `b`.\n\n\t\tIf `a` or `b` are null, the result is unspecified.\n\t**/\n\tpublic static function concat<T>( a : Iterable<T>, b : Iterable<T> ) : List<T> {\n\t\tvar l = new List();\n\t\tfor( x in a )\n\t\t\tl.add(x);\n\t\tfor( x in b )\n\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA linked-list of elements. The list is composed of two-elements arrays\n\tthat are chained together. It is optimized so that adding or removing an\n\telement does not imply copying the whole array content every time.\n**/\nclass List<T> {\n\n\tprivate var h : Array<Dynamic>;\n\tprivate var q : Array<Dynamic>;\n\n\t/**\n\t\tThe length of `this` List.\n\t**/\n\tpublic var length(default,null) : Int;\n\n\t/**\n\t\tCreates a new empty list.\n\t**/\n\tpublic function new() {\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tAdds element `item` at the end of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function add( item : T ) {\n\t\tvar x:Array<Dynamic> = #if neko untyped __dollar__array(item,null) #else [item] #end;\n\t\tif( h == null )\n\t\t\th = x;\n\t\telse\n\t\t\tq[1] = x;\n\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tAdds element `item` at the beginning of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function push( item : T ) {\n\t\tvar x : Array<Dynamic> = #if neko\n\t\t\tuntyped __dollar__array(item,h)\n\t\t#else\n\t\t\t[item,h]\n\t\t#end;\n\t\th = x;\n\t\tif( q == null )\n\t\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function first() : Null<T> {\n\t\treturn if( h == null ) null else h[0];\n\t}\n\n\t/**\n\t\tReturns the last element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function last() : Null<T> {\n\t\treturn if( q == null ) null else q[0];\n\t}\n\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThe element is removed from `this` List.\n\t**/\n\tpublic function pop() : Null<T> {\n\t\tif( h == null )\n\t\t\treturn null;\n\t\tvar x = h[0];\n\t\th = h[1];\n\t\tif( h == null )\n\t\t\tq = null;\n\t\tlength--;\n\t\treturn x;\n\t}\n\n\t/**\n\t\tTells if `this` List is empty.\n\t**/\n\tpublic function isEmpty() : Bool {\n\t\treturn (h == null);\n\t}\n\n\t/**\n\t\tEmpties `this` List.\n\n\t\tThis function does not traverse the elements, but simply sets the\n\t\tinternal references to null and `this.length` to 0.\n\t**/\n\tpublic function clear() : Void {\n\t\th = null;\n\t\tq = null;\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tRemoves the first occurence of `v` in `this` List.\n\n\t\tIf `v` is found by checking standard equality, it is removed from `this`\n\t\tList and the function returns true.\n\n\t\tOtherwise, false is returned.\n\t**/\n\tpublic function remove( v : T ) : Bool {\n\t\tvar prev = null;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( l[0] == v ) {\n\t\t\t\tif( prev == null )\n\t\t\t\t\th = l[1];\n\t\t\t\telse\n\t\t\t\t\tprev[1] = l[1];\n\t\t\t\tif( q == l )\n\t\t\t\t\tq = prev;\n\t\t\t\tlength--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprev = l;\n\t\t\tl = l[1];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tReturns an iterator on the elements of the list.\n\t**/\n\tpublic function iterator() : Iterator<T> {\n\t\t#if (java || cs)\n\t\tvar h = h;\n\t\treturn cast {\n\t\t\thasNext : function() {\n\t\t\t\treturn (h != null);\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\t{\n\t\t\t\t\tif( h == null )\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tvar x = h[0];\n\t\t\t\t\th = h[1];\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#else\n\t\treturn cast {\n\t\t\th : h,\n\t\t\thasNext : function() {\n\t\t\t\treturn untyped (__this__.h != null);\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\tuntyped {\n\t\t\t\t\tif( __this__.h == null )\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tvar x = __this__.h[0];\n\t\t\t\t\t__this__.h = __this__.h[1];\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List.\n\n\t\tThe result is enclosed in { } with the individual elements being\n\t\tseparated by a comma.\n\t**/\n\tpublic function toString() {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\ts.add(\"{\");\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(\", \");\n\t\t\ts.add(Std.string(l[0]));\n\t\t\tl = l[1];\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List, with `sep` separating\n\t\teach element.\n\t**/\n\tpublic function join(sep : String) {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(sep);\n\t\t\ts.add(l[0]);\n\t\t\tl = l[1];\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a list filtered with `f`. The returned list will contain all\n\t\telements for which `f(x) == true`.\n\t**/\n\tpublic function filter( f : T -> Bool ) {\n\t\tvar l2 = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tif( f(v) )\n\t\t\t\tl2.add(v);\n\t\t}\n\t\treturn l2;\n\t}\n\n\t/**\n\t\tReturns a new list where all elements have been converted by the\n\t\tfunction `f`.\n\t**/\n\tpublic function map<X>(f : T -> X) : List<X> {\n\t\tvar b = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tb.add(f(v));\n\t\t}\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\n\tpublic inline static function hasField( o : Dynamic, field : String ) : Bool {\n\t\treturn untyped __js__('Object').prototype.hasOwnProperty.call(o, field);\n\t}\n\n\tpublic static function field( o : Dynamic, field : String ) : Dynamic untyped {\n\t\treturn try o[field] catch( e : Dynamic ) null;\n\t}\n\n\tpublic inline static function setField( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\to[field] = value;\n\t}\n\n\tpublic static inline function getProperty( o : Dynamic, field : String ) : Dynamic untyped {\n\t\tvar tmp;\n\t\treturn if( o == null ) __define_feature__(\"Reflect.getProperty\",null) else if( o.__properties__ && (tmp=o.__properties__[\"get_\"+field]) ) o[tmp]() else o[field];\n\t}\n\n\tpublic static inline function setProperty( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\tvar tmp;\n\t\tif( o.__properties__ && (tmp=o.__properties__[\"set_\"+field]) ) o[tmp](value) else o[field] = __define_feature__(\"Reflect.setProperty\",value);\n\t}\n\n\tpublic inline static function callMethod( o : Dynamic, func : Dynamic, args : Array<Dynamic> ) : Dynamic untyped {\n\t\treturn func.apply(o,args);\n\t}\n\n\tpublic static function fields( o : Dynamic ) : Array<String> {\n\t\tvar a = [];\n\t\tif (o != null) untyped {\n\t\t\tvar hasOwnProperty = __js__('Object').prototype.hasOwnProperty;\n\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\tif( f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f) ) a.push(f);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static function isFunction( f : Dynamic ) : Bool untyped {\n\t\treturn __js__(\"typeof(f)\") == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>( a : T, b : T ) : Int {\n\t\treturn ( a == b ) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods( f1 : Dynamic, f2 : Dynamic ) : Bool {\n\t\tif( f1 == f2 )\n\t\t\treturn true;\n\t\tif( !isFunction(f1) || !isFunction(f2) )\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\tpublic static function isObject( v : Dynamic ) : Bool untyped {\n\t\tif( v == null )\n\t\t\treturn false;\n\t\tvar t = __js__(\"typeof(v)\");\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null)) || (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue( v : Dynamic ) : Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField( o : Dynamic, field : String ) : Bool untyped {\n\t\tif( !hasField(o,field) ) return false;\n\t\t__js__(\"delete\")(o[field]);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>( o : T ) : T {\n\t\tvar o2 : Dynamic = {};\n\t\tfor( f in Reflect.fields(o) )\n\t\t\tReflect.setField(o2,f,Reflect.field(o,f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function( f : Array<Dynamic> -> Void ) : Dynamic {})\n\tpublic static function makeVarArgs( f : Array<Dynamic> -> Dynamic ) : Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn cast(x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tIts cross-platform implementation uses String concatenation internally, but\n\tStringBuf may be optimized for different targets.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues. However, the internal buffer cannot be modified.\n**/\nclass StringBuf {\n\n\tvar b:String = \"\";\n\n\t/**\n\t\tThe length of `this` StringBuf in characters.\n\t**/\n\tpublic var length(get,never) : Int;\n\n\t/**\n\t\tCreates a new StringBuf instance.\n\n\t\tThis may involve initialization of the internal buffer.\n\t**/\n\tpublic function new() {}\n\n\tinline function get_length() : Int {\n\t\treturn b.length;\n\t}\n\n\t/**\n\t\tAppends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.\n\t**/\n\tpublic inline function add<T>( x : T ) : Void {\n\t\tb += x;\n\t}\n\n\t/**\n\t\tAppends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.\n\t**/\n\tpublic inline function addChar( c : Int ) : Void {\n\t\tb += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tAppends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.\n\t**/\n\tpublic inline function addSub( s : String, pos : Int, ?len : Int) : Void {\n\t\tb += (len == null ? s.substr(pos) : s.substr(pos, len));\n\t}\n\n\t/**\n\t\tReturns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation.\n\t**/\n\tpublic inline function toString() : String {\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t'using StringTools' and then acts as an extension to the String class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\n#if cs\n@:keep\n#end\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlEncode( s : String ) : String untyped {\n\t\t#if flash9\n\t\t\treturn __global__[\"encodeURIComponent\"](s);\n\t\t#elseif flash\n\t\t\treturn _global[\"escape\"](s);\n\t\t#elseif neko\n\t\t\treturn new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\t\treturn encodeURIComponent(s);\n\t\t#elseif cpp\n\t\t\treturn s.__URLEncode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLEncoder.encode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn cs.system.Uri.EscapeUriString(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlDecode( s : String ) : String untyped {\n\t\t#if flash9\n\t\t\treturn __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif flash\n\t\t\treturn _global[\"unescape\"](s);\n\t\t#elseif neko\n\t\t\treturn new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\t\treturn decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\t\treturn s.__URLDecode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLDecoder.decode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn cs.system.Uri.UnescapeDataString(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape( s : String, ?quotes : Bool ) : String {\n\t\ts = s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t\treturn quotes ? s.split('\"').join(\"&quot;\").split(\"'\").join(\"&#039;\") : s;\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: htmlUnescape(htmlEscape(s)) == s\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape( s : String ) : String {\n\t\treturn s.split(\"&gt;\").join(\">\").split(\"&lt;\").join(\"<\").split(\"&quot;\").join('\"').split(\"&#039;\").join(\"'\").split(\"&amp;\").join(\"&\");\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is null, the result is unspecified.\n\n\t\tIf `start` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function startsWith( s : String, start : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#else\n\t\treturn( s.length >= start.length && s.substr(0, start.length) == start );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is null, the result is unspecified.\n\n\t\tIf `end` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function endsWith( s : String, end : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn( slen >= elen && s.substr(slen - elen, elen) == end );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String \"\", or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace( s : String, pos : Int ) : Bool {\n\t\tvar c = s.charCodeAt( pos );\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function ltrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,r) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 )\n\t\t\treturn s.substr(r, l-r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function rtrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,l-r-1) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 ){\n\t\t\treturn s.substr(0, l-r);\n\t\t}else{\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for ltrim(rtrim(s)).\n\t**/\n\tpublic #if (cs || java) inline #end static function trim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn untyped s.trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = c + s;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = s + c;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReplace all occurences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String \"\", `by` is inserted after each character\n\t\tof `s`. If `by` is also the empty String \"\", `s` remains unchanged.\n\n\t\tThis is a convenience function for `s.split(sub).join(by)`.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace( s : String, sub : String, by : String ) : String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits length equals `digits`.\n\t**/\n\tpublic static function hex( n : Int, ?digits : Int ) {\n\t\t#if flash9\n\t\t\tvar n : UInt = n;\n\t\t\tvar s : String = untyped n.toString(16);\n\t\t\ts = s.toUpperCase();\n\t\t#else\n\t\t\tvar s = \"\";\n\t\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\t\tdo {\n\t\t\t\ts = hexChars.charAt(n&15) + s;\n\t\t\t\tn >>>= 4;\n\t\t\t} while( n > 0 );\n\t\t#end\n\t\tif( digits != null )\n\t\t\twhile( s.length < digits )\n\t\t\t\ts = \"0\"+s;\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`.\n\n\t\tThis method is faster than String.charCodeAt() on most platforms.\n\t\tHowever, unlike String.charCodeAt(), the result is unspecified if\n\t\t`index` is negative or exceeds `s.length`.\n\n\t\tThis operation is not guaranteed to work if `s` contains the \\0\n\t\tcharacter.\n\t**/\n\tpublic static inline function fastCodeAt( s : String, index : Int ) : Int untyped {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn s.cca(index);\n\t\t#elseif flash9\n\t\treturn s.cca(index);\n\t\t#elseif flash\n\t\treturn s[\"cca\"](index);\n\t\t#elseif java\n\t\treturn ( index < s.length ) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn ( cast(index, UInt) < s.length ) ? cast(untyped s[index], Int) : -1;\n\t\t#elseif js\n\t\t\t#if mt\n\t\treturn (untyped s).cca(index);\n\t\t\t#else\n\t\treturn (untyped s).charCodeAt(index);\n\t\t\t#end\n\t\t#else\n\t\treturn s.cca(index);\n\t\t#end\n\t}\n\n\t/*\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t*/\n\t@:noUsing public static inline function isEof( c : Int ) : Bool {\n\t\t#if (flash9 || cpp)\n\t\treturn c == 0;\n\t\t#elseif flash8\n\t\treturn c <= 0; // fast NaN\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif neko\n\t\treturn c == null;\n\t\t#elseif cs\n\t\treturn c == -1;\n\t\t#elseif java\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16 return untyped str._charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\",\"url_encode\",1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\",\"url_decode\",1);\n\t#end\n\n}\n","import thx.ref.ArrayRef;\nimport thx.ref.ObjectRef;\nimport thx.ref.Ref;\nimport thx.ref.UnknownRef;\nimport thx.ref.ValueRef;\nimport utest.Runner;\nimport utest.ui.Report;\nimport utest.Assert;\n\nclass TestAll {\n  static function main() {\n    var runner = new Runner();\n\n    runner.addCase(new TestAll());\n\n    Report.create(runner);\n\n    runner.run();\n  }\n\n  public function new() {}\n\n  public function testValueRef() {\n    var ref = new ValueRef();\n    Assert.isFalse(ref.hasValue());\n    ref.set('some');\n    Assert.isTrue(ref.hasValue());\n    Assert.equals(ref, ref.resolve(\"\"));\n    Assert.raises(function() {\n      ref.resolve(\"path\");\n    });\n    ref.remove();\n    Assert.isFalse(ref.hasValue());\n  }\n\n  static var obj = { a : [{ b : [[1],[2]]}] };\n  public function testRefFromValue() {\n    var ref = Ref.fromValue(obj);\n    Assert.same(obj, ref.get());\n  }\n\n  public function testResolvePathEmpty() {\n    var ref = Ref.resolvePath(\"\");\n    Assert.is(ref, ValueRef);\n  }\n\n  public function testResolvePathEmptyNonTerminal() {\n    var ref = Ref.resolvePath(\"\", null, false);\n    Assert.is(ref, UnknownRef);\n  }\n\n  public function testResolvePathField() {\n    var ref = Ref.resolvePath(\"name\");\n    Assert.is(ref, ValueRef);\n    Assert.is(ref.getRoot(), ObjectRef);\n  }\n\n  public function testResolvePathNestedField() {\n    var ref = Ref.resolvePath(\"person.name\");\n    Assert.is(ref, ValueRef);\n    Assert.is(ref.parent, ObjectRef);\n    Assert.is(ref.getRoot(), ObjectRef);\n    Assert.notEquals(ref.parent, ref.getRoot());\n  }\n\n  public function testResolvePathItem() {\n    var ref = Ref.resolvePath(\"[0]\");\n    Assert.is(ref, ValueRef);\n    Assert.is(ref.getRoot(), ArrayRef);\n  }\n\n  public function testResolvePathNestedItem() {\n    var ref = Ref.resolvePath(\"[0][0]\");\n    Assert.is(ref, ValueRef);\n    Assert.is(ref.parent, ArrayRef);\n    Assert.is(ref.getRoot(), ArrayRef);\n    Assert.notEquals(ref.parent, ref.getRoot());\n  }\n\n  public function testResolvePathItemNestedField() {\n    var ref = Ref.resolvePath(\"[0].name\");\n    Assert.is(ref, ValueRef);\n    Assert.is(ref.parent, ObjectRef);\n    Assert.is(ref.getRoot(), ArrayRef);\n  }\n\n  static var path0 = 'a[0].b[0][0]';\n  static var path1 = 'a[0].b[1][0]';\n  public function testResolvePath() {\n    var ref0 = Ref.resolvePath(path0),\n      root = ref0.getRoot(),\n      ref1 = root.resolve(path1);\n    ref0.set(1);\n    ref1.set(2);\n    Assert.same(obj, root.get());\n  }\n\n  public function testArrayRef() {\n    var ref = new ArrayRef();\n    Assert.same([], ref.get());\n    Assert.isFalse(ref.hasValue());\n    var value = ref.resolve(\"[0]\");\n    Assert.same([], ref.get());\n    value.set(\"A\");\n    Assert.isTrue(ref.hasValue());\n    Assert.same([\"A\"], ref.get());\n    Assert.raises(function() {\n      ref.resolve(\"path\");\n    });\n  }\n\n  public function testObjectRef() {\n    var ref = new ObjectRef();\n    Assert.same({}, ref.get());\n    Assert.isFalse(ref.hasValue());\n    var value = ref.resolve(\"name\");\n    Assert.same({}, ref.get());\n    value.set(\"Franco\");\n    Assert.isTrue(ref.hasValue());\n    Assert.same({name:\"Franco\"}, ref.get());\n    Assert.raises(function() {\n      ref.resolve(\"[0]\");\n    });\n  }\n\n  public function testObjectRefWithArray() {\n    var ref = Ref.fromValue({ arr : [0,1,2] });\n    Assert.same([0,1,2], ref.resolve('arr').get());\n    ref.resolve('arr').remove();\n    Assert.isFalse(ref.hasValue());\n  }\n\n  public function testNestedRemove() {\n    var ref = Ref.fromValue({ arr : [0] });\n    Assert.isTrue(ref.hasValue());\n    ref.resolve('arr[0]').remove();\n    Assert.isFalse(ref.hasValue());\n  }\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass( c : Class<Dynamic> );\n\tTEnum( e : Enum<Dynamic> );\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\n\tpublic static function getClass<T>( o : T ) : Class<T> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum( o : EnumValue ) : Enum<Dynamic> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn o.__enum__;\n\t}\n\n\tpublic static function getSuperClass( c : Class<Dynamic> ) : Class<Dynamic> untyped {\n\t\treturn c.__super__;\n\t}\n\n\n\tpublic static function getClassName( c : Class<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped c.__name__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function getEnumName( e : Enum<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped e.__ename__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function resolveClass( name : String ) : Class<Dynamic> untyped {\n\t\tvar cl : Class<Dynamic> = $hxClasses[name];\n\t\t// ensure that this is a class\n\t\tif( cl == null || !js.Boot.isClass(cl) )\n\t\t\treturn null;\n\t\treturn cl;\n\t}\n\n\tpublic static function resolveEnum( name : String ) : Enum<Dynamic> untyped {\n\t\tvar e : Dynamic = $hxClasses[name];\n\t\t// ensure that this is an enum\n\t\tif( e == null || !js.Boot.isEnum(e) )\n\t\t\treturn null;\n\t\treturn e;\n\t}\n\n\tpublic static function createInstance<T>( cl : Class<T>, args : Array<Dynamic> ) : T untyped {\n\t\tswitch( args.length ) {\n\t\tcase 0:\n\t\t\treturn __new__(cl);\n\t\tcase 1:\n\t\t\treturn __new__(cl,args[0]);\n\t\tcase 2:\n\t\t\treturn __new__(cl,args[0],args[1]);\n\t\tcase 3:\n\t\t\treturn __new__(cl,args[0],args[1],args[2]);\n\t\tcase 4:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3]);\n\t\tcase 5:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4]);\n\t\tcase 6:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5]);\n\t\tcase 7:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);\n\t\tcase 8:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);\n\t\tdefault:\n\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static function createEmptyInstance<T>( cl : Class<T> ) : T untyped {\n\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\treturn __js__(\"new empty()\");\n\t}\n\n\tpublic static function createEnum<T>( e : Enum<T>, constr : String, ?params : Array<Dynamic> ) : T {\n\t\tvar f = Reflect.field(e,constr);\n\t\tif( f == null ) throw \"No such constructor \"+constr;\n\t\tif( Reflect.isFunction(f) ) {\n\t\t\tif( params == null ) throw \"Constructor \"+constr+\" need parameters\";\n\t\t\treturn Reflect.callMethod(e,f,params);\n\t\t}\n\t\tif( params != null && params.length != 0 )\n\t\t\tthrow \"Constructor \"+constr+\" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>( e : Enum<T>, index : Int, ?params : Array<Dynamic> ) : T {\n\t\tvar c : String = (untyped e.__constructs__)[index];\n\t\tif( c == null ) throw index+\" is not a valid enum constructor index\";\n\t\treturn createEnum(e,c,params);\n\t}\n\n\tpublic static function getInstanceFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\n\tpublic static function getEnumConstructs( e : Enum<Dynamic> ) : Array<String> {\n\t\tvar a : Array<String> = untyped e.__constructs__;\n\t\treturn a.copy();\n\t}\n\n\tpublic static function typeof( v : Dynamic ) : ValueType untyped {\n\t\tswitch( __js__(\"typeof\")(v) ) {\n\t\tcase \"boolean\": return TBool;\n\t\tcase \"string\": return TClass(String);\n\t\tcase \"number\":\n\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\tif( Math.ceil(v) == v%2147483648.0 )\n\t\t\t\treturn TInt;\n\t\t\treturn TFloat;\n\t\tcase \"object\":\n\t\t\tif( v == null )\n\t\t\t\treturn TNull;\n\t\t\tvar e = v.__enum__;\n\t\t\tif( e != null )\n\t\t\t\treturn TEnum(e);\n\t\t\tvar c = js.Boot.getClass(v);\n\t\t\tif( c != null )\n\t\t\t\treturn TClass(c);\n\t\t\treturn TObject;\n\t\tcase \"function\":\n\t\t\tif( js.Boot.isClass(v) || js.Boot.isEnum(v) )\n\t\t\t\treturn TObject;\n\t\t\treturn TFunction;\n\t\tcase \"undefined\":\n\t\t\treturn TNull;\n\t\tdefault:\n\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T>( a : T, b : T ) : Bool untyped {\n\t\tif( a == b )\n\t\t\treturn true;\n\t\ttry {\n\t\t\tif( a[0] != b[0] )\n\t\t\t\treturn false;\n\t\t\tfor( i in 2...a.length )\n\t\t\t\tif( !enumEq(a[i],b[i]) )\n\t\t\t\t\treturn false;\n\t\t\tvar e = a.__enum__;\n\t\t\tif( e != b.__enum__ || e == null )\n\t\t\t\treturn false;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic inline static function enumConstructor( e : EnumValue ) : String {\n\t\treturn untyped e[0];\n\t}\n\n\tpublic inline static function enumParameters( e : EnumValue ) : Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\n\tpublic inline static function enumIndex( e : EnumValue ) : Int {\n\t\treturn untyped e[1];\n\t}\n\n\tpublic static function allEnums<T>( e : Enum<T> ) : Array<T> {\n\t\treturn untyped e.__empty_constructs__;\n\t}\n\n}\n\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule( m : String );\n\tFilePos( s : Null<StackItem>, file : String, line : Int );\n\tMethod( classname : String, method : String );\n\tLocalFunction( v : Int );\n}\n\n/**\n\tGet informations about the call stack.\n**/\nclass CallStack {\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\tvar a = makeStack(untyped __dollar__callstack());\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif flash9\n\t\t\tvar a = makeStack( new flash.errors.Error().getStackTrace() );\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\treturn makeStack(\"$s\");\n\t\t#elseif php\n\t\t\treturn makeStack(\"%s\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_call_stack(true);\n\t\t\treturn makeStack(s);\n\t\t#elseif js\n\t\t\t// https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\t\tvar oldValue = (untyped Error).prepareStackTrace;\n\t\t\t(untyped Error).prepareStackTrace = function (error, callsites :Array<Dynamic>) {\n\t\t\t\tvar stack = [];\n\t\t\t\tfor (site in callsites) {\n\t\t\t\t\tvar method = null;\n\t\t\t\t\tvar fullName :String = site.getFunctionName();\n\t\t\t\t\tif (fullName != null) {\n\t\t\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tvar className = fullName.substr(0, idx);\n\t\t\t\t\t\t\tvar methodName = fullName.substr(idx+1);\n\t\t\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(FilePos(method, site.getFileName(), site.getLineNumber()));\n\t\t\t\t}\n\t\t\t\treturn stack;\n\t\t\t}\n\t\t\tvar a = makeStack(untyped __new__(\"Error\").stack);\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\t(untyped Error).prepareStackTrace = oldValue;\n\t\t\treturn a;\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.lang.Thread.currentThread().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(1, true));\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t**/\n\t#if cpp @:noStack #end /* Do not mess up the exception stack */\n\tpublic static function exceptionStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\treturn makeStack(untyped __dollar__excstack());\n\t\t#elseif as3\n\t\t\treturn new Array();\n\t\t#elseif flash9\n\t\t\tvar err : flash.errors.Error = untyped flash.Boot.lastError;\n\t\t\tif( err == null ) return new Array();\n\t\t\tvar a = makeStack( err.getStackTrace() );\n\t\t\tvar c = callStack();\n\t\t\tvar i = c.length - 1;\n\t\t\twhile( i > 0 ) {\n\t\t\t\tif( Std.string(a[a.length-1]) == Std.string(c[i]) )\n\t\t\t\t\ta.pop();\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\treturn makeStack(\"$e\");\n\t\t#elseif php\n\t\t\treturn makeStack(\"%e\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_exception_stack();\n\t\t\treturn makeStack(s);\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.internal.Exceptions.currentException().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// stack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(cs.internal.Exceptions.exception, true));\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tpublic static function toString( stack : Array<StackItem> ) {\n\t\tvar b = new StringBuf();\n\t\tfor( s in stack ) {\n\t\t\tb.add(\"\\nCalled from \");\n\t\t\titemToString(b,s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tprivate static function itemToString( b : StringBuf, s ) {\n\t\tswitch( s ) {\n\t\tcase CFunction:\n\t\t\tb.add(\"a C function\");\n\t\tcase Module(m):\n\t\t\tb.add(\"module \");\n\t\t\tb.add(m);\n\t\tcase FilePos(s,file,line):\n\t\t\tif( s != null ) {\n\t\t\t\titemToString(b,s);\n\t\t\t\tb.add(\" (\");\n\t\t\t}\n\t\t\tb.add(file);\n\t\t\tb.add(\" line \");\n\t\t\tb.add(line);\n\t\t\tif( s != null ) b.add(\")\");\n\t\tcase Method(cname,meth):\n\t\t\tb.add(cname);\n\t\t\tb.add(\".\");\n\t\t\tb.add(meth);\n\t\tcase LocalFunction(n):\n\t\t\tb.add(\"local function #\");\n\t\t\tb.add(n);\n\t\t}\n\t}\n\n\t#if cpp @:noStack #end /* Do not mess up the exception stack */\n\tprivate static function makeStack(s #if cs : cs.system.diagnostics.StackTrace #end) {\n\t\t#if neko\n\t\t\tvar a = new Array();\n\t\t\tvar l = untyped __dollar__asize(s);\n\t\t\tvar i = 0;\n\t\t\twhile( i < l ) {\n\t\t\t\tvar x = s[i++];\n\t\t\t\tif( x == null )\n\t\t\t\t\ta.unshift(CFunction);\n\t\t\t\telse if( untyped __dollar__typeof(x) == __dollar__tstring )\n\t\t\t\t\ta.unshift(Module(new String(x)));\n\t\t\t\telse\n\t\t\t\t\ta.unshift(FilePos(null,new String(untyped x[0]),untyped x[1]));\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash9\n\t\t\tvar a = new Array();\n\t\t\tvar r = ~/at ([^\\/]+?)\\$?(\\/[^\\(]+)?\\(\\)(\\[(.*?):([0-9]+)\\])?/;\n\t\t\tvar rlambda = ~/^MethodInfo-([0-9]+)$/g;\n\t\t\twhile( r.match(s) ) {\n\t\t\t\tvar cl = r.matched(1).split(\"::\").join(\".\");\n\t\t\t\tvar meth = r.matched(2);\n\t\t\t\tvar item;\n\t\t\t\tif( meth == null ) {\n\t\t\t\t\tif( rlambda.match(cl) )\n\t\t\t\t\t\titem = LocalFunction(Std.parseInt(rlambda.matched(1)));\n\t\t\t\t\telse\n\t\t\t\t\t\titem = Method(cl,\"new\");\n\t\t\t\t} else\n\t\t\t\t\titem = Method(cl,meth.substr(1));\n\t\t\t\tif( r.matched(3) != null )\n\t\t\t\t\titem = FilePos( item, r.matched(4), Std.parseInt(r.matched(5)) );\n\t\t\t\ta.push(item);\n\t\t\t\ts = r.matchedRight();\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\tvar a : Array<String> = untyped __eval__(s);\n\t\t\tvar m = new Array();\n\t\t\tfor( i in 0...a.length - if(s == \"$s\") 2 else 0 ) {\n\t\t\t\tvar d = a[i].split(\"::\");\n\t\t\t\tm.unshift(Method(d[0],d[1]));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif php\n\t\t\tif (!untyped __call__(\"isset\", __var__(\"GLOBALS\", s)))\n\t\t\t\treturn [];\n\t\t\tvar a : Array<String> = untyped __var__(\"GLOBALS\", s);\n\t\t\tvar m = [];\n\t\t\tfor( i in 0...a.length - ((s == \"%s\") ? 2 : 0)) {\n\t\t\t\tvar d = a[i].split(\"::\");\n\t\t\t\tm.unshift(Method(d[0],d[1]));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif cpp\n\t\t\tvar stack : Array<String> = s;\n\t\t\tvar m = new Array<StackItem>();\n\t\t\tfor(func in stack) {\n\t\t\t\tvar words = func.split(\"::\");\n\t\t\t\tif (words.length==0)\n\t\t\t\t\tm.unshift(CFunction)\n\t\t\t\telse if (words.length==2)\n\t\t\t\t\tm.unshift(Method(words[0],words[1]));\n\t\t\t\telse if (words.length==4)\n\t\t\t\t\tm.unshift(FilePos( Method(words[0],words[1]),words[2],Std.parseInt(words[3])));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif js\n\t\t\tif ((untyped __js__(\"typeof\"))(s) == \"string\") {\n\t\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\t\tvar stack : Array<String> = s.split(\"\\n\");\n\t\t\t\tvar m = [];\n\t\t\t\tfor( line in stack ) {\n\t\t\t\t\tm.push(Module(line)); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t\treturn m;\n\t\t\t} else {\n\t\t\t\treturn cast s;\n\t\t\t}\n\t\t#elseif cs\n\t\t\tvar stack = [];\n\t\t\tfor (i in 0...s.FrameCount)\n\t\t\t{\n\t\t\t\tvar frame = s.GetFrame(i);\n\t\t\t\tvar m = frame.GetMethod();\n\n\t\t\t\tvar method = StackItem.Method(m.ReflectedType.ToString(), m.Name);\n\n\t\t\t\tvar fileName = frame.GetFileName();\n\t\t\t\tvar lineNumber = frame.GetFileLineNumber();\n\n\t\t\t\tif (fileName != null || lineNumber >= 0)\n\t\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t\telse\n\t\t\t\t\tstack.push(method);\n\t\t\t}\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tLog primarily provides the trace() method, which is invoked upon a call to\n\ttrace() in haxe code.\n**/\nclass Log {\n\n\t/**\n\t\tOutputs `v` in a platform-dependent way.\n\n\t\tThe second parameter `infos` is injected by the compiler and contains\n\t\tinformation about the position where the trace() call was made.\n\n\t\tThis method can be rebound to a custom function:\n\t\t\tvar oldTrace = haxe.Log.trace; // store old function\n\t\t\thaxe.Log.trace = function(v,infos) { // handle trace }\n\t\t\t...\n\t\t\thaxe.Log.trace = oldTrace;\n\n\t\tIf it is bound to null, subsequent calls to trace() will cause an\n\t\texception.\n\t**/\n\tpublic static dynamic function trace( v : Dynamic, ?infos : PosInfos ) : Void {\n\t\t#if flash\n\t\t\t#if (fdb || native_trace)\n\t\t\t\tvar pstr = infos == null ? \"(null)\" : infos.fileName + \":\" + infos.lineNumber;\n\t\t\t\tvar str = flash.Boot.__string_rec(v, \"\");\n\t\t\t\tif( infos != null && infos.customParams != null ) for( v in infos.customParams ) str += \",\" + flash.Boot.__string_rec(v, \"\");\n\t\t\t\tuntyped #if flash9 __global__[\"trace\"] #else __trace__ #end(pstr+\": \"+str);\n\t\t\t#else\n\t\t\t\tuntyped flash.Boot.__trace(v,infos);\n\t\t\t#end\n\t\t#elseif neko\n\t\t\tuntyped {\n\t\t\t\t$print(infos.fileName + \":\" + infos.lineNumber + \": \", v);\n\t\t\t\tif( infos.customParams != null ) for( v in infos.customParams ) $print(\",\", v);\n\t\t\t\t$print(\"\\n\");\n\t\t\t}\n\t\t#elseif js\n\t\t\tuntyped js.Boot.__trace(v,infos);\n\t\t#elseif php\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __call__('_hx_trace', v + extra, infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __call__('_hx_trace', v, infos);\n\t\t#elseif cpp\n\t\t\tif (infos!=null && infos.customParams!=null) {\n\t\t\t\tvar extra:String = \"\";\n\t\t\t\tfor( v in infos.customParams )\n\t\t\t\t\textra += \",\" + v;\n\t\t\t\tuntyped __trace(v + extra,infos);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuntyped __trace(v,infos);\n\t\t#elseif (cs || java)\n\t\t\tvar str:String = null;\n\t\t\tif (infos != null) {\n\t\t\t\tstr = infos.fileName + \":\" + infos.lineNumber + \": \" + v;\n\t\t\t\tif (infos.customParams != null)\n\t\t\t\t{\n\t\t\t\t\tstr += \",\" + infos.customParams.join(\",\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = v;\n\t\t\t}\n\t\t\t#if cs\n\t\t\tcs.system.Console.WriteLine(str);\n\t\t\t#elseif java\n\t\t\tuntyped __java__(\"java.lang.System.out.println(str)\");\n\t\t\t#end\n\t\t#end\n\t}\n\n\t#if (flash || js)\n\t/**\n\t\tClears the trace output.\n\t**/\n\tpublic static dynamic function clear() : Void {\n\t\t#if flash\n\t\tuntyped flash.Boot.__clear_trace();\n\t\t#elseif js\n\t\tuntyped js.Boot.__clear_trace();\n\t\t#end\n\t}\n\t#end\n\n\t#if flash\n\t/**\n\t\tSets the color of the trace output to `rgb`.\n\t**/\n\tpublic static dynamic function setColor( rgb : Int ) {\n\t\tuntyped flash.Boot.__set_trace_color(rgb);\n\t}\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tThe Timer class allows you to create asynchronous timers on platforms that\n\tsupport events.\n\n\tThe intended usage is to create an instance of the Timer class with a given\n\tinterval, set its run() method to a custom function to be invoked and\n\teventually call stop() to stop the Timer.\n\n\tNote that a running Timer may or may not prevent the program to exit\n\tautomatically when main() returns.\n\n\tIt is also possible to extend this class and override its run() method in\n\tthe child class.\n**/\nclass Timer {\n\t#if (flash || js || java)\n\n\t#if (flash || js)\n\t\tprivate var id : Null<Int>;\n\t#elseif java\n\t\tprivate var timer : java.util.Timer;\n\t\tprivate var task : java.util.TimerTask;\n\t#end\n\n\t/**\n\t\tCreates a new timer that will run every `time_ms` milliseconds.\n\n\t\tAfter creating the Timer instance, it calls `this].run` repeatedly,\n\t\twith delays of `time_ms` milliseconds, until `this.stop` is called.\n\n\t\tThe first invocation occurs after `time_ms` milliseconds, not\n\t\timmediately.\n\n\t\tThe accuracy of this may be platform-dependent.\n\t**/\n\tpublic function new( time_ms : Int ){\n\t\t#if flash9\n\t\t\tvar me = this;\n\t\t\tid = untyped __global__[\"flash.utils.setInterval\"](function() { me.run(); },time_ms);\n\t\t#elseif flash\n\t\t\tvar me = this;\n\t\t\tid = untyped _global[\"setInterval\"](function() { me.run(); },time_ms);\n\t\t#elseif js\n\t\t\tvar me = this;\n\t\t\tid = untyped setInterval(function() me.run(),time_ms);\n\t\t#elseif java\n\t\t\ttimer = new java.util.Timer();\n\t\t\ttimer.scheduleAtFixedRate(task = new TimerTask(this), haxe.Int64.ofInt(time_ms), haxe.Int64.ofInt(time_ms));\n\t\t#end\n\t}\n\n\t/**\n\t\tStops `this` Timer.\n\n\t\tAfter calling this method, no additional invocations of `this.run`\n\t\twill occur.\n\n\t\tIt is not possible to restart `this` Timer once stopped.\n\t**/\n\tpublic function stop() {\n\t\t#if (flash || js)\n\t\t\tif( id == null )\n\t\t\t\treturn;\n\t\t\t#if flash9\n\t\t\t\tuntyped __global__[\"flash.utils.clearInterval\"](id);\n\t\t\t#elseif flash\n\t\t\t\tuntyped _global[\"clearInterval\"](id);\n\t\t\t#elseif js\n\t\t\t\tuntyped clearInterval(id);\n\t\t\t#end\n\t\t\tid = null;\n\t\t#elseif java\n\t\t\ttimer.cancel();\n\t\t\ttimer = null;\n\t\t\ttask = null;\n\t\t#end\n\t}\n\n\t/**\n\t\tThis method is invoked repeatedly on `this` Timer.\n\n\t\tIt can be overridden in a subclass, or rebound directly to a custom\n\t\tfunction:\n\t\t\tvar timer = new haxe.Timer(1000); // 1000ms delay\n\t\t\ttimer.run = function() { ... }\n\n\t\tOnce bound, it can still be rebound to different functions until `this`\n\t\tTimer is stopped through a call to `this.stop`.\n\t**/\n\tpublic dynamic function run() {\n\n\t}\n\n\t/**\n\t\tInvokes `f` after `time_ms` milliseconds.\n\n\t\tThis is a convenience function for creating a new Timer instance with\n\t\t`time_ms` as argument, binding its run() method to `f` and then stopping\n\t\t`this` Timer upon the first invocation.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function delay( f : Void -> Void, time_ms : Int ) {\n\t\tvar t = new haxe.Timer(time_ms);\n\t\tt.run = function() {\n\t\t\tt.stop();\n\t\t\tf();\n\t\t};\n\t\treturn t;\n\t}\n\n\t#end\n\n\t/**\n\t\tMeasures the time it takes to execute `f`, in seconds with fractions.\n\n\t\tThis is a convenience function for calculating the difference between\n\t\tTimer.stamp() before and after the invocation of `f`.\n\n\t\tThe difference is passed as argument to Log.trace(), with \"s\" appended\n\t\tto denote the unit. The optional `pos` argument is passed through.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function measure<T>( f : Void -> T, ?pos : PosInfos ) : T {\n\t\tvar t0 = stamp();\n\t\tvar r = f();\n\t\tLog.trace((stamp() - t0) + \"s\", pos);\n\t\treturn r;\n\t}\n\n\t/**\n\t\tReturns a timestamp, in seconds with fractions.\n\n\t\tThe value itself might differ depending on platforms, only differences\n\t\tbetween two values make sense.\n\t**/\n\tpublic static function stamp() : Float {\n\t\t#if flash\n\t\t\treturn flash.Lib.getTimer() / 1000;\n\t\t#elseif (neko || php)\n\t\t\treturn Sys.time();\n\t\t#elseif js\n\t\t\treturn Date.now().getTime() / 1000;\n\t\t#elseif cpp\n\t\t\treturn untyped __global__.__time_stamp();\n\t\t#elseif sys\n\t\t\treturn Sys.time();\n\t\t#else\n\t\t\treturn 0;\n\t\t#end\n\t}\n\n}\n\n#if java\n@:nativeGen\nprivate class TimerTask extends java.util.TimerTask {\n\tvar timer:Timer;\n\tpublic function new(timer:Timer):Void {\n\t\tsuper();\n\t\tthis.timer = timer;\n\t}\n\n\t@:overload public function run():Void {\n\t\ttimer.run();\n\t}\n}\n#end","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\n@:coreApi class IntMap<T> implements Map.IMap<Int,T> {\n\n\tprivate var h : Dynamic;\n\n\tpublic function new() : Void {\n\t\th = {};\n\t}\n\n\tpublic function set( key : Int, value : T ) : Void {\n\t\tuntyped h[key] = value;\n\t}\n\n\tpublic function get( key : Int ) : Null<T> {\n\t\treturn untyped h[key];\n\t}\n\n\tpublic function exists( key : Int ) : Bool {\n\t\treturn untyped h.hasOwnProperty(key);\n\t}\n\n\tpublic function remove( key : Int ) : Bool {\n\t\tif( untyped !h.hasOwnProperty(key) ) return false;\n\t\tuntyped  __js__(\"delete\")(h[key]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<Int> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(key|0);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<T> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[i]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(i);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of h software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and h permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n@:coreApi\nclass ObjectMap<K:{ }, V> implements Map.IMap<K,V> {\n\n\tstatic var count = 0;\n\n\tstatic inline function assignId(obj: { } ):Int {\n\t\treturn untyped obj.__id__ = ++count;\n\t}\n\n\tstatic inline function getId(obj: { } ):Int {\n\t\treturn untyped obj.__id__;\n\t}\n\n\tvar h : { };\n\n\tpublic function new() : Void {\n\t\th = { };\n\t\tuntyped h.__keys__ = { };\n\t}\n\n\tpublic function set(key:K, value:V):Void untyped {\n\t\tvar id : Int = untyped key.__id__ || assignId(key);\n\t\th[id] = value;\n\t\th.__keys__[id] = key;\n\t}\n\n\tpublic inline function get(key:K):Null<V> {\n\t\treturn untyped h[getId(key)];\n\t}\n\n\tpublic inline function exists(key:K):Bool {\n\t\treturn untyped h.__keys__[getId(key)] != null;\n\t}\n\n\tpublic function remove( key : K ) : Bool {\n\t\tvar id = getId(key);\n\t\tif ( untyped h.__keys__[id] == null ) return false;\n\t\tuntyped  __js__(\"delete\")(h[id]);\n\t\tuntyped  __js__(\"delete\")(h.__keys__[id]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<K> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h.__keys__ ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(h.__keys__[key]);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<V> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[getId(i)]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(Std.string(i));\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\n@:coreApi class StringMap<T> implements Map.IMap<String,T> {\n\n\tprivate var h : Dynamic;\n\n\tpublic function new() : Void {\n\t\th = {};\n\t}\n\n\tpublic function set( key : String, value : T ) : Void {\n\t\tuntyped h[\"$\"+key] = value;\n\t}\n\n\tpublic function get( key : String ) : Null<T> {\n\t\treturn untyped h[\"$\"+key];\n\t}\n\n\tpublic function exists( key : String ) : Bool {\n\t\treturn untyped h.hasOwnProperty(\"$\"+key);\n\t}\n\n\tpublic function remove( key : String ) : Bool {\n\t\tkey = \"$\"+key;\n\t\tif( untyped !h.hasOwnProperty(key) ) return false;\n\t\tuntyped __js__(\"delete\")(h[key]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<String> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(key.substr(1));\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<T> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[\"$\"+i]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(i);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n/**\n\tThis exception is raised when reading while data is no longer available in the [Input].\n**/\nclass Eof {\n\tpublic function new() {\n\t}\n\t@:keep function toString() {\n\t\treturn \"Eof\";\n\t}\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic inline function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse\n\t\t\treturn untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t}\n\n\t@:ifFeature(\"may_print_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n}\n","/**\n * ...\n * @author Franco Ponticelli\n */\n\npackage thx.core;\n\nimport thx.core.Functions.Function in F;\n\n#if macro\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.ExprTools;\n#end\n\nclass Arrays {\n\tpublic static function same<T>(a : Array<T>, b : Array<T>, ?eq : T -> T -> Bool) {\n\t\tif(a == null || b == null || a.length != b.length) return false;\n\t\tif(null == eq) eq = F.equality;\n\t\tfor(i in 0...a.length)\n\t\t\tif(!eq(a[i], b[i]))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic static function cross<T>(a : Array<T>, b : Array<T>) {\n\t\tvar r = [];\n\t\tfor (va in a)\n\t\t\tfor (vb in b)\n\t\t\t\tr.push([va, vb]);\n\t\treturn r;\n\t}\n\n\tpublic static function crossMulti<T>(a : Array<Array<T>>) {\n\t\tvar acopy  = a.copy(),\n\t\t\tresult = acopy.shift().map(function(v) return [v]);\n\t\twhile (acopy.length > 0) {\n\t\t\tvar arr = acopy.shift(),\n\t\t\t\ttresult = result;\n\t\t\tresult = [];\n\t\t\tfor (v in arr) {\n\t\t\t\tfor (ar in tresult) {\n\t\t\t\t\tvar t = ar.copy();\n\t\t\t\t\tt.push(v);\n\t\t\t\t\tresult.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static function pushIf<T>(arr : Array<T>, cond : Bool, value : T) {\n\t\tif (cond)\n\t\t\tarr.push(value);\n\t\treturn arr;\n\t}\n\n\tpublic static function eachPair<TIn, TOut>(arr : Array<TIn>, handler : TIn -> TIn -> Bool)\n\t\tfor(i in 0...arr.length)\n\t\t\tfor(j in i...arr.length)\n\t\t\t\tif(!handler(arr[i], arr[j]))\n\t\t\t\t\treturn;\n\n\t#if js inline #end\n\tpublic static function mapi<TIn, TOut>(arr : Array<TIn>, handler : TIn -> Int -> TOut) : Array<TOut> {\n\t\t#if js\n\t\t\treturn (cast arr : { map : (TIn -> Int -> TOut) -> Array<TOut> }).map(handler);\n\t\t#else\n\t\t\tvar r = [];\n\t\t\tfor(i in 0...arr.length)\n\t\t\t\tr.push(handler(arr[i], i));\n\t\t\treturn r;\n\t\t#end\n\t}\n\n\tinline public static function flatMap<TIn, TOut>(arr : Array<TIn>, callback : TIn -> Array<TOut>) : Array<TOut>\n\t\treturn flatten(arr.map(callback));\n\n\t#if js inline #end\n\tpublic static function flatten<T>(arr : Array<Array<T>>) : Array<T>\n\t\t#if js\n\t\t\treturn untyped __js__('Array.prototype.concat.apply')([], arr);\n\t\t#else\n\t\t\treturn reduce(arr, function(acc : Array<T>, item) return acc.concat(item), []);\n\t\t#end\n\n\tinline public static function reduce<TItem, TAcc>(arr : Array<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc\n\t\t#if js\n\t\t\treturn untyped arr.reduce(callback, initial);\n\t\t#else\n\t\t\treturn Iterables.reduce(arr, callback, initial);\n\t\t#end\n\n\tinline public static function reducei<TItem, TAcc>(arr : Array<TItem>, callback : TAcc -> TItem -> Int -> TAcc, initial : TAcc) : TAcc\n\t\t#if js\n\t\t\treturn untyped arr.reduce(callback, initial);\n\t\t#else\n\t\t\treturn Iterables.reducei(arr, callback, initial);\n\t\t#end\n\n\tpublic static function order<T>(arr : Array<T>, sort : T -> T -> Int) {\n\t\tvar n = arr.copy();\n\t\tn.sort(sort);\n\t\treturn n;\n\t}\n\n\tinline public static function isEmpty<T>(arr : Array<T>) : Bool\n\t\treturn arr.length == 0;\n\n\tpublic static function contains<T>(arr : Array<T>, element : T, ?eq : T -> T -> Bool) : Bool {\n\t\tif(null == eq) {\n\t\t\treturn arr.indexOf(element) >= 0;\n\t\t} else {\n\t\t\tfor(i in 0...arr.length)\n\t\t\t\tif(eq(arr[i], element))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static function shuffle<T>(a : Array<T>) : Array<T> {\n\t\tvar t = Ints.range(a.length),\n\t\t\tarr = [];\n\t\twhile (t.length > 0) {\n\t\t\tvar pos = Std.random(t.length),\n\t\t\t\tindex = t[pos];\n\t\t\tt.splice(pos, 1);\n\t\t\tarr.push(a[index]);\n\t\t}\n\t\treturn arr;\n\t}\n\n\tpublic static function extract<T>(a : Array<T>, f : T -> Bool) : T {\n\t\tfor(i in 0...a.length) {\n\t\t\tif(f(a[i]))\n\t\t\t\treturn a.splice(i, 1)[0];\n\t\t}\n\t\treturn null;\n\t}\n\n\tmacro public static function mapField<T>(a : ExprOf<Array<T>>, field : Expr) {\n\t\tvar id = 'o.'+ExprTools.toString(field),\n\t\t\t\texpr = Context.parse(id, field.pos);\n\t\treturn macro $e{a}.map(function(o) return ${expr});\n\t}\n\n\tmacro public static function mapFieldi<T>(a : ExprOf<Array<T>>, field : Expr) {\n\t\tvar id = 'o.'+ExprTools.toString(field),\n\t\t\t\texpr = Context.parse(id, field.pos);\n\t\treturn macro thx.core.Arrays.mapi($e{a}, function(o, i) return ${expr});\n\t}\n}","package thx.core;\n\nclass Function0 {\n\tpublic static function noop() : Void {}\n\tpublic inline static function join(fa : Void -> Void, fb : Void -> Void)\n\t\treturn function() {\n\t\t\tfa();\n\t\t\tfb();\n\t\t}\n\n\tpublic inline static function once(f : Void -> Void)\n\t\treturn function() {\n\t\t\tf();\n\t\t\tf = function(){}\n\t\t};\n}\n\nclass Function1 {\n\tpublic static function noop<T>(_ : T) : Void {}\n\tpublic inline static function compose<TIn, TRet1, TRet2>(fa : TRet2 -> TRet1, fb : TIn -> TRet2)\n\t\treturn function(v : TIn) return fa(fb(v));\n\n\tpublic inline static function join<TIn>(fa : TIn -> Void, fb : TIn -> Void)\n\t\treturn function(v : TIn) {\n\t\t\tfa(v);\n\t\t\tfb(v);\n\t\t}\n}\n\nclass Function {\n\tpublic static function equality<T>(a : T, b : T) return a == b;\n}","/**\n * ...\n * @author Franco Ponticelli\n */\n\npackage thx.core;\n\nclass Ints {\n\tpublic static inline function clamp(v : Int, min : Int, max : Int) : Int\n\t\treturn v < min ? min : (v > max ? max : v);\n\n\tstatic var pattern_parse = ~/^[+-]?(\\d+|0x[0-9A-F]+)$/i;\n\tpublic static function canParse(s : String)\n\t\treturn pattern_parse.match(s);\n\n\tpublic inline static function min(a : Int, b : Int)\n\t\treturn a < b ? a : b;\n\n\tpublic inline static function max(a : Int, b : Int)\n\t\treturn a > b ? a : b;\n\n\t// TODO add proper octal/hex/exp support\n\tpublic static function parse(s : String) {\n\t\tif (s.substr(0, 1) == \"+\")\n\t\t\ts = s.substr(1);\n\t\treturn Std.parseInt(s);\n\t}\n\n\tpublic inline static function compare(a : Int, b : Int)\n\t\treturn a - b;\n\n\tpublic static function range(start : Int, ?stop : Int, step = 1) : Array<Int> {\n\t\tif (null == stop) {\n\t\t\tstop = start;\n\t\t\tstart = 0;\n\t\t}\n\t\tif ((stop - start) / step == Math.POSITIVE_INFINITY) throw \"infinite range\";\n\t\tvar range = [], i = -1, j;\n\t\tif (step < 0)\n\t\t\twhile ((j = start + step * ++i) > stop) range.push(j);\n\t\telse\n\t\t\twhile ((j = start + step * ++i) < stop) range.push(j);\n\t\treturn range;\n\t}\n}","package thx.core;\n\nclass Iterables {\n\tpublic inline static function map<T, S>(it : Iterable<T>, f : T -> S) : Array<S>\n\t\treturn Iterators.map(it.iterator(), f);\n\n\tpublic inline static function eachPair<TIn, TOut>(it : Iterable<TIn>, handler : TIn -> TIn -> Bool)\n\t\treturn Iterators.eachPair(it.iterator(), handler);\n\n\tpublic inline static function toArray<T>(it : Iterable<T>) : Array<T>\n\t\treturn Iterators.toArray(it.iterator());\n\n\tpublic inline static function order<T>(it : Iterable<T>, sort : T -> T -> Int) : Array<T>\n\t\treturn Iterators.order(it.iterator(), sort);\n\n\tpublic inline static function reduce<TItem, TAcc>(it : Iterable<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc\n\t\treturn Iterators.reduce(it.iterator(), callback, initial);\n\n\tpublic inline static function reducei<TItem, TAcc>(it : Iterable<TItem>, callback : TAcc -> TItem -> Int -> TAcc, initial : TAcc) : TAcc\n\t\treturn Iterators.reducei(it.iterator(), callback, initial);\n\n\tpublic inline static function isEmpty<T>(it : Iterable<T>) : Bool\n\t\treturn Iterators.isEmpty(it.iterator());\n\n\tpublic inline static function filter<T>(it : Iterable<T>, predicate : T -> Bool) : Array<T>\n\t\treturn Iterators.filter(it.iterator(), predicate);\n}","package thx.core;\n\nclass Iterators {\n\tpublic static function map<T, S>(it : Iterator<T>, f : T -> S) : Array<S> {\n\t\tvar acc = [];\n\t\tfor(v in it)\n\t\t\tacc.push(f(v));\n\t\treturn acc;\n\t}\n\n\tpublic static function mapi<T, S>(it : Iterator<T>, f : T -> Int -> S) : Array<S> {\n\t\tvar acc = [],\n\t\t\ti = 0;\n\t\tfor(v in it)\n\t\t\tacc.push(f(v, i++));\n\t\treturn acc;\n\t}\n\n\tpublic static function eachPair<TIn, TOut>(it : Iterator<TIn>, handler : TIn -> TIn -> Bool)\n\t\tArrays.eachPair(toArray(it), handler);\n\n\tpublic static function toArray<T>(it : Iterator<T>) : Array<T> {\n\t\tvar items = [];\n\t\tfor(item in it)\n\t\t\titems.push(item);\n\t\treturn items;\n\t}\n\n\tpublic static function order<T>(it : Iterator<T>, sort : T -> T -> Int) {\n\t\tvar n = Iterators.toArray(it);\n\t\tn.sort(sort);\n\t\treturn n;\n\t}\n\n\tpublic static function reduce<TItem, TAcc>(it : Iterator<TItem>, callback : TAcc -> TItem -> TAcc, initial : TAcc) : TAcc {\n\t\tmap(it, function(v) initial = callback(initial, v));\n\t\treturn initial;\n\t}\n\n\tpublic static function reducei<TItem, TAcc>(it : Iterator<TItem>, callback : TAcc -> TItem -> Int -> TAcc, initial : TAcc) : TAcc {\n\t\tmapi(it, function(v, i) initial = callback(initial, v, i));\n\t\treturn initial;\n\t}\n\n\tinline public static function isEmpty<T>(it : Iterator<T>) : Bool\n\t\treturn !it.hasNext();\n\n\tpublic static function filter<TItem>(it : Iterator<TItem>, predicate : TItem -> Bool) : Array<TItem>\n\t\treturn reduce(it, function(acc : Array<TItem>, item) {\n\t\t\t\tif(predicate(item))\n\t\t\t\t\tacc.push(item);\n\t\t\t\treturn acc;\n\t\t\t}, []);\n}","package thx.core;\n\nclass Objects {\n\tinline public static function isEmpty(o : {})\n\t\treturn Reflect.fields(o).length == 0;\n}\n","/**\n * ...\n * @author Franco Ponticelli\n */\n\npackage thx.core;\n\nclass Types {\n\tpublic static inline function isAnonymousObject(v : Dynamic) : Bool\n\t\treturn Reflect.isObject(v) && null == Type.getClass(v);\n\n\tpublic static function sameType<A, B>(a : A, b : B) : Bool\n\t\treturn ValueTypes.toString(Type.typeof(a)) == ValueTypes.toString(Type.typeof(b));\n}\n\nclass ClassTypes {\n\tpublic inline static function toString(cls : Class<Dynamic>)\n\t\treturn Type.getClassName(cls);\n\n\tstatic public #if !php inline #end function as<T1, T2>(value : T1, type : Class<T2>) : Null<T2>\n\t\treturn (Std.is(value, type) ? cast value : null);\n}\n\nclass ValueTypes {\n\tpublic static function typeAsString<T>(value : T)\n\t\treturn toString(Type.typeof(value));\n\n\tpublic static function toString(type : Type.ValueType) {\n\t\treturn switch type {\n\t\t\tcase TInt:      \"Int\";\n\t\t\tcase TFloat:    \"Float\";\n\t\t\tcase TBool:     \"Bool\";\n\t\t\tcase TObject:   \"Dynamic\"; // TODO ?\n\t\t\tcase TFunction: \"Function\";\n\t\t\tcase TClass(c): Type.getClassName(c);\n\t\t\tcase TEnum(e):  Type.getEnumName(e);\n\t\t\tcase _:         null;\n\t\t}\n\t}\n\n\tpublic static function typeInheritance(type : Type.ValueType) {\n\t\treturn switch type {\n\t\t\tcase TInt:      [\"Int\"];\n\t\t\tcase TFloat:    [\"Float\"];\n\t\t\tcase TBool:     [\"Bool\"];\n\t\t\tcase TObject:   [\"Dynamic\"];\n\t\t\tcase TFunction: [\"Function\"];\n\t\t\tcase TClass(c):\n\t\t\t\tvar classes = [];\n\t\t\t\twhile (null != c) {\n\t\t\t\t\tclasses.push(c);\n\t\t\t\t\tc = Type.getSuperClass(c);\n\t\t\t\t}\n\t\t\t\tclasses.map(Type.getClassName);\n\t\t\tcase TEnum(e):  [Type.getEnumName(e)];\n\t\t\tcase _:         null;\n\t\t}\n\t}\n}","package thx.ref;\n\nclass BaseRef {\n  public var parent(default, null) : IParentRef;\n  public function new(?parent : IParentRef) {\n    this.parent = null != parent ? parent : EmptyParent.instance;\n  }\n\n  public function getRoot() : IRef {\n    var ref : IRef = cast this;\n    while(!Std.is(ref.parent, BaseRef.EmptyParent))\n      ref = cast ref.parent;\n    return ref;\n  }\n}\n\nclass EmptyParent implements IParentRef {\n  public static var instance(default, null) : IParentRef = new EmptyParent();\n\n  function new() {}\n\n  public function removeChild(child : IRef) { }\n}","package thx.ref;\n\nusing thx.core.Iterators;\nusing thx.core.Arrays;\nusing thx.core.Ints;\n\nclass ArrayRef extends BaseRef implements IRef implements IParentRef {\n  var items : Map<Int, IRef>;\n  var inverse : Map<IRef, Int>;\n\n  public function new(?parent : IParentRef) {\n    super(parent);\n    items   = new Map();\n    inverse = new Map();\n  }\n\n  public function get() {\n    var res = [];\n    items\n      .keys()\n      .toArray()\n      .order(Ints.compare)\n      .map(function(i) return items.get(i))\n      .map(function(ref) {\n        if(ref.hasValue())\n          res.push(ref.get());\n      });\n    return res;\n  }\n\n  public function set(value : Dynamic) {\n    if(!Std.is(value, Array)) throw 'value \"$value\" is not an array';\n\n    (value : Array<Dynamic>).mapi(function(v, i) {\n      var ref = items.get(i);\n      if(null == ref) {\n        items.set(i, ref = Ref.fromValue(v, this));\n        inverse.set(ref, i);\n      } else {\n        ref.set(v);\n      }\n    });\n  }\n\n  public function remove() {\n    for(ref in items) {\n      ref.remove();\n    }\n    parent.removeChild(this);\n  }\n\n  public function removeChild(child : IRef) : Void {\n    var i = inverse.get(child);\n    if(null == i) throw '\"$child\" is not child of \"$this\"';\n    items.remove(i);\n    inverse.remove(child);\n  }\n\n  public function hasValue() {\n    for(ref in items)\n      if(ref.hasValue())\n        return true;\n    return false;\n  }\n\n  public function resolve(path : String, terminal : Bool = true) : IRef {\n    if(path == \"\") return this;\n    if(!Ref.reIndex.match(path))\n      throw 'unable to resolve \"$path\" for ArrayRef';\n    var index = Std.parseInt(Ref.reIndex.matched(1)),\n      rest  = Ref.reIndex.matchedRight(),\n      ref   = items.get(index);\n    if(null == ref) {\n      items.set(index, ref = Ref.fromPath(rest, this, terminal));\n      inverse.set(ref, index);\n    }\n    return ref.resolve(rest, terminal);\n  }\n}","package thx.ref;\n\nusing thx.core.Iterators;\nusing thx.core.Iterables;\nimport thx.core.Types;\n\nclass ObjectRef extends BaseRef implements IRef implements IParentRef {\n  var fields : Map<String, IRef>;\n  var inverse : Map<IRef, String>;\n\n  public function new(?parent : IParentRef) {\n    super(parent);\n    fields = new Map();\n    inverse = new Map();\n  }\n\n  public function get() : Dynamic {\n    var o = {};\n    fields.keys().map(function(key) {\n      var ref = fields.get(key);\n      if(!ref.hasValue()) return;\n      Reflect.setField(o, key, ref.get());\n    });\n    return o;\n  }\n\n  public function set(obj : Dynamic) {\n    if(!Types.isAnonymousObject(obj)) throw 'object \"$obj\" is not an anonymous object';\n    Reflect.fields(obj).map(function(field) {\n      var ref   = fields.get(field),\n        value = Reflect.field(obj, field);\n      if(null == ref) {\n        ref = Ref.fromValue(value, this);\n        fields.set(field, ref);\n        inverse.set(ref, field);\n      } else {\n        ref.set(value);\n      }\n    });\n  }\n\n  public function hasValue() {\n    for(ref in fields)\n      if(ref.hasValue())\n        return true;\n    return false;\n  }\n\n  public function remove() {\n    fields.map(function(ref) ref.remove());\n    parent.removeChild(this);\n  }\n\n  public function removeChild(child : IRef) {\n    var key = inverse.get(child);\n    if(null == key) throw '\"$child\" is not child of \"$this\"';\n    inverse.remove(child);\n    fields.remove(key);\n  }\n\n  public function resolve(path : String, terminal : Bool = true) : IRef {\n    if(path == \"\") return this;\n    if(!Ref.reField.match(path))\n      throw 'unable to resolve \"$path\" for ObjectRef';\n    var field = Ref.reField.matched(1),\n      rest  = Ref.reField.matchedRight(),\n      ref   = fields.get(field);\n    if(null == ref) {\n      fields.set(field, ref = Ref.fromPath(rest, this, terminal));\n      inverse.set(ref, field);\n    }\n    return ref.resolve(rest, terminal);\n  }\n}","package thx.ref;\n\nusing thx.core.Types;\n\nclass Ref {\n  public static function fromValue(value : Dynamic, ?parent : IParentRef) : IRef {\n    if(null == parent)\n      parent = BaseRef.EmptyParent.instance;\n    var ref : IRef = if(Std.is(value, Array)) {\n        new ArrayRef(parent);\n      } else if(Types.isAnonymousObject(value)) {\n        new ObjectRef(parent);\n      } else {\n        new ValueRef(parent);\n      }\n    ref.set(value);\n    return ref;\n  }\n\n  public static var reField = ~/^\\.?([^.\\[]+)/;\n  public static var reIndex = ~/^\\[(\\d+)\\]/;\n  public static function fromPath(path : String, ?parent : IParentRef, terminal : Bool = true) : IRef {\n    if(null == parent)\n      parent = BaseRef.EmptyParent.instance;\n    if(path == \"\") {\n      return terminal ? new ValueRef(parent) : new UnknownRef(parent);\n    } else if(reField.match(path)) {\n      return new ObjectRef(parent);\n    } else if(reIndex.match(path)) {\n      return new ArrayRef(parent);\n    } else {\n      return throw 'invalid path \"$path\"';\n    }\n  }\n\n  public static function resolvePath(path : String, ?parent : IParentRef, terminal : Bool = true) : IRef {\n    var ref = fromPath(path, parent, terminal);\n    return ref.resolve(path);\n  }\n}","package thx.ref;\n\nusing thx.core.Objects;\nusing thx.core.Arrays;\n\nclass UnknownRef extends BaseRef implements IRef implements IParentRef {\n  public var ref(default, null) : Null<IRef>;\n  var hasRef : Bool = false;\n\n  public function get()\n    return hasRef ? ref.get() : null;\n\n  public function set(value : Dynamic) {\n    if(hasRef)\n      ref.set(value);\n    else {\n      hasRef = true;\n      ref = Ref.fromValue(value, this);\n    }\n  }\n\n  public function remove() : Void {\n    if(hasRef)\n      ref.remove();\n    parent.removeChild(this);\n  }\n\n  public function removeChild(child : IRef) : Void {\n    if(hasRef) {\n      ref = null;\n      hasRef = false;\n    }\n  }\n\n  public function hasValue() : Bool\n    return hasRef && ref.hasValue();\n\n  public function resolve(path : String, terminal : Bool = true) : IRef {\n    if(hasRef)\n      return ref.resolve(path, terminal);\n    if(path == \"\")\n      return this;\n    hasRef = true;\n    ref = Ref.fromPath(path, this, terminal);\n    return ref.resolve(path, terminal);\n  }\n}","package thx.ref;\n\nusing thx.core.Objects;\nusing thx.core.Arrays;\n\nclass ValueRef extends BaseRef implements IRef {\n  var _hasValue : Bool = false;\n  var value : Dynamic;\n\n  public function get()\n    return value;\n\n  public function set(value : Dynamic) {\n    this.value = value;\n    _hasValue = true;\n  }\n\n  public function remove() : Void {\n    value = null;\n    _hasValue = false;\n    parent.removeChild(this);\n  }\n\n  public function hasValue() : Bool\n    return _hasValue;\n\n  public function resolve(path : String, terminal : Bool = true) : IRef {\n    if(path != \"\") throw 'unable to resolve path \"$path\" on ValueRef';\n    return this;\n  }\n}","package utest;\r\n\r\nimport haxe.io.Bytes;\r\nimport utest.Assertation;\r\nimport haxe.PosInfos;\r\n\r\n/**\r\n* This class contains only static members used to perform assertations inside a test method.\r\n* It's use is straight forward:\r\n* <pre>\r\n* public function testObvious() {\r\n*   Assert.equals(1, 0); // fails\r\n*   Assert.isFalse(1 == 1, \"guess what?\"); // fails and returns the passed message\r\n*   Assert.isTrue(true); // successfull\r\n* }\r\n* </pre>\r\n*/\r\nclass Assert {\r\n\t/**\r\n\t* A stack of results for the current testing workflow. It is used internally\r\n\t* by other classes of the utest library.\r\n\t*/\r\n\tpublic static var results : List<Assertation>;\r\n\t/**\r\n\t* Asserts successfully when the condition is true.\r\n\t* @param cond: The condition to test\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function isTrue(cond : Bool, ?msg : String, ?pos : PosInfos) {\r\n\t\tif (results == null) throw \"Assert.results is not currently bound to any assert context\";\r\n\t\tif (null == msg)\r\n\t\t\tmsg = \"expected true\";\r\n\t\tif(cond)\r\n\t\t\tresults.add(Success(pos));\r\n\t\telse\r\n\t\t\tresults.add(Failure(msg, pos));\r\n\t}\r\n\t/**\r\n\t* Asserts successfully when the condition is false.\r\n\t* @param cond: The condition to test\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function isFalse(value : Bool, ?msg : String, ?pos : PosInfos) {\r\n\t\tif (null == msg)\r\n\t\t\tmsg = \"expected false\";\r\n\t\tisTrue(value == false, msg, pos);\r\n\t}\r\n\t/**\r\n\t* Asserts successfully when the value is null.\r\n\t* @param value: The value to test\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function isNull(value : Dynamic, ?msg : String, ?pos : PosInfos) {\r\n\t\tif (msg == null)\r\n\t\t\tmsg = \"expected null but was \" + q(value);\r\n\t\tisTrue(value == null, msg, pos);\r\n\t}\r\n\t/**\r\n\t* Asserts successfully when the value is not null.\r\n\t* @param value: The value to test\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function notNull(value : Dynamic, ?msg : String, ?pos : PosInfos) {\r\n\t\tif (null == msg)\r\n\t\t\tmsg = \"expected not null\";\r\n\t\tisTrue(value != null, msg, pos);\r\n\t}\r\n\t/**\r\n\t* Asserts successfully when the 'value' parameter is of the of the passed type 'type'.\r\n\t* @param value: The value to test\r\n\t* @param type: The type to test against\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function is(value : Dynamic, type : Dynamic, ?msg : String , ?pos : PosInfos) {\r\n\t\tif (msg == null) msg = \"expected type \" + typeToString(type) + \" but was \" + typeToString(value);\r\n\t\tisTrue(Std.is(value, type), msg, pos);\r\n\t}\r\n\r\n\t/**\r\n\t* Asserts successfully when the value parameter is not the same as the expected one.\r\n\t* <pre>\r\n\t* Assert.notEquals(10, age);\r\n\t* </pre>\r\n\t* @param expected: The expected value to check against\r\n\t* @param value: The value to test\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function notEquals(expected : Dynamic, value : Dynamic, ?msg : String , ?pos : PosInfos) {\r\n\t\tif(msg == null) msg = \"expected \" + q(expected) + \" and testa value \" + q(value) + \" should be different\";\r\n\t\tisFalse(expected == value, msg, pos);\r\n\t}\r\n\r\n\t/**\r\n\t* Asserts successfully when the value parameter is equal to the expected one.\r\n\t* <pre>\r\n\t* Assert.equals(10, age);\r\n\t* </pre>\r\n\t* @param expected: The expected value to check against\r\n\t* @param value: The value to test\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function equals(expected : Dynamic, value : Dynamic, ?msg : String , ?pos : PosInfos) {\r\n\t\tif(msg == null) msg = \"expected \" + q(expected) + \" but was \" + q(value);\r\n\t\tisTrue(expected == value, msg, pos);\r\n\t}\r\n\r\n\t/**\r\n\t* Asserts successfully when the value parameter does match against the passed EReg instance.\r\n\t* <pre>\r\n\t* Assert.match(~/x/i, \"haXe\");\r\n\t* </pre>\r\n\t* @param pattern: The pattern to match against\r\n\t* @param value: The value to test\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function match(pattern : EReg, value : Dynamic, ?msg : String , ?pos : PosInfos) {\r\n\t\tif(msg == null) msg = \"the value \" + q(value) + \"does not match the provided pattern\";\r\n\t\tisTrue(pattern.match(value), msg, pos);\r\n\t}\r\n\r\n\t/**\r\n\t* Same as Assert.equals but considering an approximation error.\r\n\t* <pre>\r\n\t* Assert.floatEquals(Math.PI, value);\r\n\t* </pre>\r\n\t* @param expected: The expected value to check against\r\n\t* @param value: The value to test\r\n\t* @param approx: The approximation tollerance. Default is 1e-5\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t* @todo test the approximation argument\r\n\t*/\r\n\tpublic static function floatEquals(expected : Float, value : Float, ?approx : Float, ?msg : String , ?pos : PosInfos) : Void {\r\n\t\tif (msg == null) msg = \"expected \" + q(expected) + \" but was \" + q(value);\r\n\t\treturn isTrue(_floatEquals(expected, value, approx), msg, pos);\r\n\t}\r\n\r\n\tstatic function _floatEquals(expected : Float, value : Float, ?approx : Float)\r\n\t{\r\n\t\tif (Math.isNaN(expected))\r\n\t\t\treturn Math.isNaN(value);\r\n\t\telse if (Math.isNaN(value))\r\n\t\t\treturn false;\r\n\t\telse if (!Math.isFinite(expected) && !Math.isFinite(value))\r\n\t\t\treturn (expected > 0) == (value > 0);\r\n\t\tif (null == approx)\r\n\t\t\tapprox = 1e-5;\r\n\t\treturn Math.abs(value-expected) < approx;\r\n\t}\r\n\r\n\tstatic function getTypeName(v : Dynamic) {\r\n\t\tswitch(Type.typeof(v))\r\n\t\t{\r\n\t\t\tcase TNull    : return \"[null]\";\r\n\t\t\tcase TInt     : return \"Int\";\r\n\t\t\tcase TFloat   : return \"Float\";\r\n\t\t\tcase TBool    : return \"Bool\";\r\n\t\t\tcase TFunction: return \"function\";\r\n\t\t\tcase TClass(c): return Type.getClassName(c);\r\n\t\t\tcase TEnum(e) : return Type.getEnumName(e);\r\n\t\t\tcase TObject  : return \"Object\";\r\n\t\t\tcase TUnknown : return \"Unknown\";\r\n\t\t}\r\n\t}\r\n\r\n\tstatic function isIterable(v : Dynamic, isAnonym : Bool) {\r\n\t\tvar fields = isAnonym ? Reflect.fields(v) : Type.getInstanceFields(Type.getClass(v));\r\n\t\tif(!Lambda.has(fields, \"iterator\")) return false;\r\n\t\treturn Reflect.isFunction(Reflect.field(v, \"iterator\"));\r\n\t}\r\n\r\n\tstatic function isIterator(v : Dynamic, isAnonym : Bool) {\r\n\t\tvar fields = isAnonym ? Reflect.fields(v) : Type.getInstanceFields(Type.getClass(v));\r\n\t\tif(!Lambda.has(fields, \"next\") || !Lambda.has(fields, \"hasNext\")) return false;\r\n\t\treturn Reflect.isFunction(Reflect.field(v, \"next\")) && Reflect.isFunction(Reflect.field(v, \"hasNext\"));\r\n\t}\r\n\r\n\tstatic function sameAs(expected : Dynamic, value : Dynamic, status : LikeStatus) {\r\n\t\tvar texpected = getTypeName(expected);\r\n\t\tvar tvalue = getTypeName(value);\r\n\r\n\t\tif(texpected != tvalue) {\r\n\t\t\tstatus.error = \"expected type \" + texpected + \" but it is \" + tvalue + (status.path == '' ? '' : ' for field ' + status.path);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tswitch(Type.typeof(expected))\r\n\t\t{\r\n\t\t\tcase TFloat:\r\n\t\t\t\tif (!_floatEquals(expected, value))\r\n\t\t\t\t{\r\n\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\tcase TNull, TInt, TBool:\r\n\t\t\t\tif(expected != value) {\r\n\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\tcase TFunction:\r\n\t\t\t\tif (!Reflect.compareMethods(expected, value))\r\n\t\t\t\t{\r\n\t\t\t\t\tstatus.error = \"expected same function reference\" + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\tcase TClass(c):\r\n\t\t\t\tvar cexpected = Type.getClassName(c);\r\n\t\t\t\tvar cvalue = Type.getClassName(Type.getClass(value));\r\n\t\t\t\tif (cexpected != cvalue)\r\n\t\t\t\t{\r\n\t\t\t\t\tstatus.error = \"expected instance of \" + q(cexpected) + \" but it is \" + q(cvalue) + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// string\r\n\t\t\t\tif (Std.is(expected, String) && expected != value)\r\n\t\t\t\t{\r\n\t\t\t\t\tstatus.error = \"expected '\" + expected + \"' but it is '\" + value + \"'\";\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// arrays\r\n\t\t\t\tif(Std.is(expected, Array)) {\r\n\t\t\t\t\tif(status.recursive || status.path == '') {\r\n\t\t\t\t\t\tif(expected.length != value.length) {\r\n\t\t\t\t\t\t\tstatus.error = \"expected \"+expected.length+\" elements but they were \"+value.length + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar path = status.path;\r\n\t\t\t\t\t\tfor(i in 0...expected.length) {\r\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'array['+i+']' : path + '['+i+']';\r\n\t\t\t\t\t\t\tif (!sameAs(expected[i], value[i], status))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// date\r\n\t\t\t\tif(Std.is(expected, Date)) {\r\n\t\t\t\t\tif(expected.getTime() != value.getTime()) {\r\n\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// bytes\r\n\t\t\t\tif(Std.is(expected, Bytes)) {\r\n\t\t\t\t\tif(status.recursive || status.path == '') {\r\n\t\t\t\t\t\tvar ebytes : Bytes = expected;\r\n\t\t\t\t\t\tvar vbytes : Bytes = value;\r\n\t\t\t\t\t\tif (ebytes.length != vbytes.length) return false;\r\n\t\t\t\t\t\tfor (i in 0...ebytes.length)\r\n\t\t\t\t\t\t\tif (ebytes.get(i) != vbytes.get(i))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tstatus.error = \"expected byte \" + ebytes.get(i) + \" but wss \" + ebytes.get(i) + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// hash, inthash\r\n\t\t\t\tif(Std.is(expected, haxe.ds.StringMap) || Std.is(expected, haxe.ds.IntMap)) {\r\n\t\t\t\t\tif(status.recursive || status.path == '') {\r\n\t\t\t\t\t\tvar keys  = Lambda.array({ iterator : function() return expected.keys() });\r\n\t\t\t\t\t\tvar vkeys = Lambda.array({ iterator : function() return value.keys() });\r\n\t\t\t\t\t\tif(keys.length != vkeys.length) {\r\n\t\t\t\t\t\t\tstatus.error = \"expected \"+keys.length+\" keys but they were \"+vkeys.length + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar path = status.path;\r\n\t\t\t\t\t\tfor(key in keys) {\r\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'hash['+key+']' : path + '['+key+']';\r\n\t\t\t\t\t\t\tif (!sameAs(expected.get(key), value.get(key), status))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// iterator\r\n\t\t\t\tif(isIterator(expected, false)) {\r\n\t\t\t\t\tif(status.recursive || status.path == '') {\r\n\t\t\t\t\t\tvar evalues = Lambda.array({ iterator : function() return expected });\r\n\t\t\t\t\t\tvar vvalues = Lambda.array({ iterator : function() return value });\r\n\t\t\t\t\t\tif(evalues.length != vvalues.length) {\r\n\t\t\t\t\t\t\tstatus.error = \"expected \"+evalues.length+\" values in Iterator but they were \"+vvalues.length + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar path = status.path;\r\n\t\t\t\t\t\tfor(i in 0...evalues.length) {\r\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'iterator['+i+']' : path + '['+i+']';\r\n\t\t\t\t\t\t\tif (!sameAs(evalues[i], vvalues[i], status))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// iterable\r\n\t\t\t\tif(isIterable(expected, false)) {\r\n\t\t\t\t\tif(status.recursive || status.path == '') {\r\n\t\t\t\t\t\tvar evalues = Lambda.array(expected);\r\n\t\t\t\t\t\tvar vvalues = Lambda.array(value);\r\n\t\t\t\t\t\tif(evalues.length != vvalues.length) {\r\n\t\t\t\t\t\t\tstatus.error = \"expected \"+evalues.length+\" values in Iterable but they were \"+vvalues.length + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar path = status.path;\r\n\t\t\t\t\t\tfor(i in 0...evalues.length) {\r\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'iterable['+i+']' : path + '['+i+']';\r\n\t\t\t\t\t\t\tif(!sameAs(evalues[i], vvalues[i], status))\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// custom class\r\n\t\t\t\tif(status.recursive || status.path == '') {\r\n\t\t\t\t\tvar fields = Type.getInstanceFields(Type.getClass(expected));\r\n\t\t\t\t\tvar path = status.path;\r\n\t\t\t\t\tfor(field in fields) {\r\n\t\t\t\t\t\tstatus.path = path == '' ? field : path+'.'+field;\r\n\t\t\t\t\t\tvar e = Reflect.field(expected, field);\r\n\t\t\t\t\t\tif(Reflect.isFunction(e)) continue;\r\n\t\t\t\t\t\tvar v = Reflect.field(value, field);\r\n\t\t\t\t\t\tif(!sameAs(e, v, status))\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\tcase TEnum(e) :\r\n\t\t\t\tvar eexpected = Type.getEnumName(e);\r\n\t\t\t\tvar evalue = Type.getEnumName(Type.getEnum(value));\r\n\t\t\t\tif (eexpected != evalue)\r\n\t\t\t\t{\r\n\t\t\t\t\tstatus.error = \"expected enumeration of \" + q(eexpected) + \" but it is \" + q(evalue) + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif (status.recursive || status.path == '')\r\n\t\t\t\t{\r\n\t\t\t\t\tif (Type.enumIndex(expected) != Type.enumIndex(value))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstatus.error = 'expected ' + q(Type.enumConstructor(expected)) + ' but is ' + q(Type.enumConstructor(value)) + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar eparams = Type.enumParameters(expected);\r\n\t\t\t\t\tvar vparams = Type.enumParameters(value);\r\n\t\t\t\t\tvar path = status.path;\r\n\t\t\t\t\tfor (i in 0...eparams.length)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstatus.path = path == '' ? 'enum[' + i + ']' : path + '[' + i + ']';\r\n\t\t\t\t\t\tif (!sameAs(eparams[i], vparams[i], status))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field ' + status.path);\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\tcase TObject  :\r\n\t\t\t\t// anonymous object\r\n\t\t\t\tif(status.recursive || status.path == '') {\r\n\t\t\t\t\tvar tfields = Reflect.fields(value);\r\n\t\t\t\t\tvar fields = Reflect.fields(expected);\r\n\t\t\t\t\tvar path = status.path;\r\n\t\t\t\t\tfor(field in fields) {\r\n\t\t\t\t\t\ttfields.remove(field);\r\n\t\t\t\t\t\tstatus.path = path == '' ? field : path+'.'+field;\r\n\t\t\t\t\t\tif(!Reflect.hasField(value, field)) {\r\n\t\t\t\t\t\t\tstatus.error = \"expected field \" + status.path + \" does not exist in \" + q(value);\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar e = Reflect.field(expected, field);\r\n\t\t\t\t\t\tif(Reflect.isFunction(e))\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tvar v = Reflect.field(value, field);\r\n\t\t\t\t\t\tif(!sameAs(e, v, status))\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(tfields.length > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstatus.error = \"the tested object has extra field(s) (\" + tfields.join(\", \") + \") not included in the expected ones\";\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// iterator\r\n\t\t\t\tif(isIterator(expected, true)) {\r\n\t\t\t\t\tif(!(isIterator(value, true))) {\r\n\t\t\t\t\t\tstatus.error = \"expected Iterable but it is not \" + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(status.recursive || status.path == '') {\r\n\t\t\t\t\t\tvar evalues = Lambda.array({ iterator : function() return expected });\r\n\t\t\t\t\t\tvar vvalues = Lambda.array({ iterator : function() return value });\r\n\t\t\t\t\t\tif(evalues.length != vvalues.length) {\r\n\t\t\t\t\t\t\tstatus.error = \"expected \"+evalues.length+\" values in Iterator but they were \"+vvalues.length + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar path = status.path;\r\n\t\t\t\t\t\tfor(i in 0...evalues.length) {\r\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'iterator['+i+']' : path + '['+i+']';\r\n\t\t\t\t\t\t\tif (!sameAs(evalues[i], vvalues[i], status))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tstatus.error = \"expected \" + q(expected) + \" but it is \" + q(value) + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// iterable\r\n\t\t\t\tif(isIterable(expected, true)) {\r\n\t\t\t\t\tif(!(isIterable(value, true))) {\r\n\t\t\t\t\t\tstatus.error = \"expected Iterator but it is not \" + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(status.recursive || status.path == '') {\r\n\t\t\t\t\t\tvar evalues = Lambda.array(expected);\r\n\t\t\t\t\t\tvar vvalues = Lambda.array(value);\r\n\t\t\t\t\t\tif(evalues.length != vvalues.length) {\r\n\t\t\t\t\t\t\tstatus.error = \"expected \"+evalues.length+\" values in Iterable but they were \"+vvalues.length + (status.path == '' ? '' : ' for field '+status.path);\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar path = status.path;\r\n\t\t\t\t\t\tfor(i in 0...evalues.length) {\r\n\t\t\t\t\t\t\tstatus.path = path == '' ? 'iterable['+i+']' : path + '['+i+']';\r\n\t\t\t\t\t\t\tif(!sameAs(evalues[i], vvalues[i], status))\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\tcase TUnknown :\r\n\t\t\t\treturn throw \"Unable to compare two unknown types\";\r\n\t\t}\r\n\t\treturn throw \"Unable to compare values: \" + q(expected) + \" and \" + q(value);\r\n\t}\r\n\r\n\tstatic function q(v : Dynamic)\r\n\t{\r\n\t\tif (Std.is(v, String))\r\n\t\t\treturn '\"' + StringTools.replace(v, '\"', '\\\\\"') + '\"';\r\n\t\telse\r\n\t\t\treturn Std.string(v);\r\n\t}\r\n\r\n\t/**\r\n\t* Check that value is an object with the same fields and values found in expected.\r\n\t* The default behavior is to check nested objects in fields recursively.\r\n\t* <pre>\r\n\t* Assert.same({ name : \"utest\"}, ob);\r\n\t* </pre>\r\n\t* @param expected: The expected value to check against\r\n\t* @param value: The value to test\r\n\t* @param recursive: States whether or not the test will apply also to sub-objects.\r\n\t* Defaults to true\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function same(expected : Dynamic, value : Dynamic, ?recursive : Bool, ?msg : String, ?pos : PosInfos) {\r\n\t\tvar status = { recursive : null == recursive ? true : recursive, path : '', error : null };\r\n\t\tif(sameAs(expected, value, status)) {\r\n\t\t\tAssert.isTrue(true, msg, pos);\r\n\t\t} else {\r\n\t\t\tAssert.fail(msg == null ? status.error : msg, pos);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* It is used to test an application that under certain circumstances must\r\n\t* react throwing an error. This assert guarantees that the error is of the\r\n\t* correct type (or Dynamic if non is specified).\r\n\t* <pre>\r\n\t* Assert.raises(function() { throw \"Error!\"; }, String);\r\n\t* </pre>\r\n\t* @param method: A method that generates the exception.\r\n\t* @param type: The type of the expected error. Defaults to Dynamic (catch all).\r\n\t* @param msgNotThrown: An optional error message used when the function fails to raise the expected\r\n\t*  \t\t exception. If not passed a default one will be used\r\n\t* @param msgWrongType: An optional error message used when the function raises the exception but it is\r\n\t*  \t\t of a different type than the one expected. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t* @todo test the optional type parameter\r\n\t*/\r\n\tpublic static function raises(method:Void -> Void, ?type:Class<Dynamic>, ?msgNotThrown : String , ?msgWrongType : String, ?pos : PosInfos) {\r\n\t\tif(type == null)\r\n\t\t\ttype = String;\r\n\t\ttry {\r\n\t\t\tmethod();\r\n\t\t\tvar name = Type.getClassName(type);\r\n\t\t\tif (name == null) name = \"\"+type;\r\n\t\t\tif (null == msgNotThrown)\r\n\t\t\t\tmsgNotThrown = \"exception of type \" + name + \" not raised\";\r\n\t\t\tfail(msgNotThrown, pos);\r\n\t\t} catch (ex : Dynamic) {\r\n\t\t\tvar name = Type.getClassName(type);\r\n\t\t\tif (name == null) name = \"\"+type;\r\n\t\t\tif (null == msgWrongType)\r\n\t\t\t\tmsgWrongType = \"expected throw of type \" + name + \" but was \"  + ex;\r\n\t\t\tisTrue(Std.is(ex, type), msgWrongType, pos);\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t* Checks that the test value matches at least one of the possibilities.\r\n\t* @param possibility: An array of mossible matches\r\n\t* @param value: The value to test\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function allows<T>(possibilities : Array<T>, value : T, ?msg : String , ?pos : PosInfos) {\r\n\t\tif(Lambda.has(possibilities, value)) {\r\n\t\t\tisTrue(true, msg, pos);\r\n\t\t} else {\r\n\t\t\tfail(msg == null ? \"value \" + q(value) + \" not found in the expected possibilities \" + possibilities : msg, pos);\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t* Checks that the test array contains the match parameter.\r\n\t* @param match: The element that must be included in the tested array\r\n\t* @param values: The values to test\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function contains<T>(match : T, values : Array<T>, ?msg : String , ?pos : PosInfos) {\r\n\t\tif(Lambda.has(values, match)) {\r\n\t\t\tisTrue(true, msg, pos);\r\n\t\t} else {\r\n\t\t\tfail(msg == null ? \"values \" + q(values) + \" do not contain \"+match: msg, pos);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Checks that the test array does not contain the match parameter.\r\n\t* @param match: The element that must NOT be included in the tested array\r\n\t* @param values: The values to test\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function notContains<T>(match : T, values : Array<T>, ?msg : String , ?pos : PosInfos) {\r\n\t\tif(!Lambda.has(values, match)) {\r\n\t\t\tisTrue(true, msg, pos);\r\n\t\t} else {\r\n\t\t\tfail(msg == null ? \"values \" + q(values) + \" do contain \"+match: msg, pos);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks that the expected values is contained in value.\r\n\t * @param match: the string value that must be contained in value\r\n\t * @param value: the value to test\r\n\t * @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t */\r\n\tpublic static function stringContains(match : String, value : String, ?msg : String , ?pos : PosInfos) {\r\n\t\tif (value != null && value.indexOf(match) >= 0) {\r\n\t\t\tisTrue(true, msg, pos);\r\n\t\t} else {\r\n\t\t\tfail(msg == null ? \"value \" + q(value) + \" does not contain \" + q(match) : msg, pos);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static function stringSequence(sequence : Array<String>, value : String, ?msg : String , ?pos : PosInfos) {\r\n\t\tif (null == value)\r\n\t\t{\r\n\t\t\tfail(msg == null ? \"null argument value\" : msg, pos);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar p = 0;\r\n\t\tfor (s in sequence)\r\n\t\t{\r\n\t\t\tvar p2 = value.indexOf(s, p);\r\n\t\t\tif (p2 < 0)\r\n\t\t\t{\r\n\t\t\t\tif (msg == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tmsg = \"expected '\" + s + \"' after \";\r\n\t\t\t\t\tif (p > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar cut = value.substr(0, p);\r\n\t\t\t\t\t\tif (cut.length > 30)\r\n\t\t\t\t\t\t\tcut = '...' + cut.substr( -27);\r\n\t\t\t\t\t\tmsg += \" '\" + cut + \"'\" ;\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tmsg += \" begin\";\r\n\t\t\t\t}\r\n\t\t\t\tfail(msg, pos);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tp = p2 + s.length;\r\n\t\t}\r\n\t\tisTrue(true, msg, pos);\r\n\t}\r\n\r\n\t/**\r\n\t* Forces a failure.\r\n\t* @param msg: An optional error message. If not passed a default one will be used\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function fail(msg = \"failure expected\", ?pos : PosInfos) {\r\n\t\tisTrue(false, msg, pos);\r\n\t}\r\n\t/**\r\n\t* Creates a warning message.\r\n\t* @param msg: A mandatory message that justifies the warning.\r\n\t* @param pos: Code position where the Assert call has been executed. Don't fill it\r\n\t* unless you know what you are doing.\r\n\t*/\r\n\tpublic static function warn(msg) {\r\n\t\tresults.add(Warning(msg));\r\n\t}\r\n\r\n\t/**\r\n\t* Creates an asynchronous context for test execution. Assertions should be included\r\n\t* in the passed function.\r\n\t* <pre>\r\n\t* public function assertAsync() {\r\n\t*   var async = Assert.createAsync(function() Assert.isTrue(true));\r\n\t*   haxe.Timer.delay(async, 50);\r\n\t* }\r\n\t* @param f: A function that contains other Assert tests\r\n\t* @param timeout: Optional timeout value in milliseconds.\r\n\t*/\r\n\tpublic static dynamic function createAsync(?f : Void -> Void, ?timeout : Int) {\r\n\t\treturn function(){};\r\n\t}\r\n\t/**\r\n\t* Creates an asynchronous context for test execution of an event like method.\r\n\t* Assertions should be included in the passed function.\r\n\t* It works the same way as Assert.assertAsync() but accepts a function with one\r\n\t* argument (usually some event data) instead of a function with no arguments\r\n\t* @param f: A function that contains other Assert tests\r\n\t* @param timeout: Optional timeout value in milliseconds.\r\n\t*/\r\n\tpublic static dynamic function createEvent<EventArg>(f : EventArg -> Void, ?timeout : Int) {\r\n\t\treturn function(e){};\r\n\t}\r\n\r\n\tstatic function typeToString(t : Dynamic)\r\n\t{\r\n\t\ttry {\r\n\t\t\tvar _t = Type.getClass(t);\r\n\t\t\tif (_t != null)\r\n\t\t\t\tt = _t;\r\n\t\t} catch(e : Dynamic) { }\r\n\t\ttry return Type.getClassName(t) catch (e : Dynamic) { }\r\n\t\ttry {\r\n\t\t\tvar _t = Type.getEnum(t);\r\n\t\t\tif (_t != null)\r\n\t\t\t\tt = _t;\r\n\t\t} catch(e : Dynamic) { }\r\n\t\ttry return Type.getEnumName(t) catch(e : Dynamic) {}\r\n\t\ttry return Std.string(Type.typeof(t)) catch (e : Dynamic) { }\r\n\t\ttry return Std.string(t) catch (e : Dynamic) { }\r\n\t\treturn '<unable to retrieve type name>';\r\n\t}\r\n}\r\n\r\nprivate typedef LikeStatus = {\r\n\trecursive : Bool,\r\n\tpath : String,\r\n\terror : String\r\n};","package utest;\r\n\r\nprivate enum EventException {\r\n\tStopPropagation;\r\n}\r\n\r\n/**\r\n* @todo add documentation\r\n*/\r\nclass Dispatcher<T> {\r\n\r\n\tprivate var handlers : Array<T -> Void>;\r\n\r\n\tpublic function new() {\r\n\t\thandlers = new Array();\r\n\t}\r\n\r\n\tpublic function add(h : T -> Void) : T -> Void {\r\n\t\thandlers.push(h);\r\n\t\treturn h;\r\n\t}\r\n\r\n\tpublic function remove(h : T -> Void) : T -> Void {\r\n\t\tfor(i in 0...handlers.length)\r\n\t\t\tif(Reflect.compareMethods(handlers[i], h))\r\n\t\t\t\treturn handlers.splice(i, 1)[0];\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic function clear() {\r\n\t\thandlers = new Array();\r\n\t}\r\n\r\n\tpublic function dispatch(e) {\r\n\t\ttry {\r\n\t\t\t// prevents problems with self removing events\r\n\t\t\tvar list = handlers.copy();\r\n\t\t\tfor( l in list )\r\n\t\t\t\tl(e);\r\n\t\t\treturn true;\r\n\t\t} catch( exc : EventException ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic function has() {\r\n\t\treturn handlers.length > 0;\r\n\t}\r\n\r\n\tpublic static function stop() {\r\n\t\tthrow StopPropagation;\r\n\t}\r\n}\r\n\r\nclass Notifier {\r\n\r\n\tprivate var handlers : Array<Void -> Void>;\r\n\r\n\tpublic function new() {\r\n\t\thandlers = new Array();\r\n\t}\r\n\r\n\tpublic function add(h : Void -> Void) : Void -> Void {\r\n\t\thandlers.push(h);\r\n\t\treturn h;\r\n\t}\r\n\r\n\tpublic function remove(h : Void -> Void) : Void -> Void {\r\n\t\tfor(i in 0...handlers.length)\r\n\t\t\tif(Reflect.compareMethods(handlers[i], h))\r\n\t\t\t\treturn handlers.splice(i, 1)[0];\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic function clear() {\r\n\t\thandlers = new Array();\r\n\t}\r\n\r\n\tpublic function dispatch() {\r\n\t\ttry {\r\n\t\t\t// prevents problems with self removing events\r\n\t\t\tvar list = handlers.copy();\r\n\t\t\tfor( l in list )\r\n\t\t\t\tl();\r\n\t\t\treturn true;\r\n\t\t} catch( exc : EventException ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic function has() {\r\n\t\treturn handlers.length > 0;\r\n\t}\r\n\r\n\tpublic static function stop() {\r\n\t\tthrow StopPropagation;\r\n\t}\r\n}","package utest;\r\n\r\nimport utest.Dispatcher;\r\n\r\n/**\r\n* The Runner class performs a set of tests. The tests can be added using addCase or addFixtures.\r\n* Once all the tests are register they are axecuted on the run() call.\r\n* Note that Runner does not provide any visual output. To visualize the test results use one of\r\n* the classes in the utest.ui package.\r\n* @todo complete documentation\r\n* @todo AVOID CHAINING METHODS (long chains do not work properly on IE)\r\n*/\r\nclass Runner {\r\n\tvar fixtures(default, null) : Array<TestFixture<Dynamic>>;\r\n\r\n\t/**\r\n\t* Event object that monitors the progress of the runner.\r\n\t*/\r\n\tpublic var onProgress(default, null) : Dispatcher<{ result : TestResult, done : Int, totals : Int }>;\r\n\t/**\r\n\t* Event object that monitors when the runner starts.\r\n\t*/\r\n\tpublic var onStart(default, null)    : Dispatcher<Runner>;\r\n\t/**\r\n\t* Event object that monitors when the runner ends. This event takes into account async calls\r\n\t* performed during the tests.\r\n\t*/\r\n\tpublic var onComplete(default, null) : Dispatcher<Runner>;\r\n\t/**\r\n\t* The number of fixtures registered.\r\n\t*/\r\n\tpublic var length(default, null)      : Int;\r\n\t/**\r\n\t* Instantiates a Runner onject.\r\n\t*/\r\n\tpublic function new() {\r\n\t\tfixtures   = new Array();\r\n\t\tonProgress = new Dispatcher();\r\n\t\tonStart    = new Dispatcher();\r\n\t\tonComplete = new Dispatcher();\r\n\t\tlength = 0;\r\n\t}\r\n\r\n\t/**\r\n\t* Adds a new test case.\r\n\t* @param\ttest: must be a not null object\r\n\t* @param\tsetup: string name of the setup function (defaults to \"setup\")\r\n\t* @param\tteardown: string name of the teardown function (defaults to \"teardown\")\r\n\t* @param\tprefix: prefix for methods that are tests (defaults to \"test\")\r\n\t* @param\tpattern: a regular expression that discriminates the names of test\r\n\t* \t\t\tfunctions; when set,  the prefix parameter is meaningless\r\n\t*/\r\n\tpublic function addCase(test : Dynamic, setup = \"setup\", teardown = \"teardown\", prefix = \"test\", ?pattern : EReg) {\r\n\t\tif(!Reflect.isObject(test)) throw \"can't add a null object as a test case\";\r\n\t\tif(!isMethod(test, setup))\r\n\t\t\tsetup = null;\r\n\t\tif(!isMethod(test, teardown))\r\n\t\t\tteardown = null;\r\n\t\tvar fields = Type.getInstanceFields(Type.getClass(test));\r\n\t\tif(pattern == null) {\r\n\t\t\tfor(field in fields) {\r\n\t\t\t\tif(!StringTools.startsWith(field, prefix)) continue;\r\n\t\t\t\tif(!isMethod(test, field)) continue;\r\n\t\t\t\taddFixture(new TestFixture(test, field, setup, teardown));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor(field in fields) {\r\n\t\t\t\tif(!pattern.match(field)) continue;\r\n\t\t\t\tif(!isMethod(test, field)) continue;\r\n\t\t\t\taddFixture(new TestFixture(test, field, setup, teardown));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic function addFixture(fixture : TestFixture<Dynamic>) {\r\n\t\tfixtures.push(fixture);\r\n\t\tlength++;\r\n\t}\r\n\r\n\tpublic function getFixture(index : Int) {\r\n\t\treturn fixtures[index];\r\n\t}\r\n\r\n\tfunction isMethod(test : Dynamic, name : String) {\r\n\t\ttry {\r\n\t\t\treturn Reflect.isFunction(Reflect.field(test, name));\r\n\t\t} catch(e : Dynamic) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n#if (php || neko)\r\n\tpublic function run() {\r\n\t\tonStart.dispatch(this);\r\n\t\tfor (i in 0...fixtures.length)\r\n\t\t{\r\n\t\t\tvar h = runFixture(fixtures[i]);\r\n\t\t\tonProgress.dispatch({ result : TestResult.ofHandler(h), done : i+1, totals : length });\r\n\t\t}\r\n\t\tonComplete.dispatch(this);\r\n\t}\r\n\r\n\tfunction runFixture(fixture : TestFixture<Dynamic>) {\r\n\t\tvar handler = new TestHandler(fixture);\r\n\t\thandler.execute();\r\n\t\treturn handler;\r\n\t}\r\n#else\r\n\tvar pos : Int;\r\n\tpublic function run() {\r\n\t\tpos = 0;\r\n\t\tonStart.dispatch(this);\r\n\t\trunNext();\r\n\t}\r\n\r\n\tfunction runNext() {\r\n\t\tif(fixtures.length > pos)\r\n\t\t\trunFixture(fixtures[pos++]);\r\n\t\telse\r\n\t\t\tonComplete.dispatch(this);\r\n\t}\r\n\r\n\tfunction runFixture(fixture : TestFixture<Dynamic>) {\r\n\t\tvar handler = new TestHandler(fixture);\r\n\t\thandler.onComplete.add(testComplete);\r\n\t\thandler.execute();\r\n\t}\r\n\r\n\tfunction testComplete(h : TestHandler<Dynamic>) {\r\n\t\tonProgress.dispatch({ result : TestResult.ofHandler(h), done : pos, totals : length });\r\n\t\trunNext();\r\n\t}\r\n#end\r\n}","package utest;\r\n\r\n/**\r\n* @todo add documentation\r\n*/\r\nclass TestFixture<T> {\r\n\tpublic var target(default, null)   : T;\r\n\tpublic var method(default, null)   : String;\r\n\tpublic var setup(default, null)    : String;\r\n\tpublic var teardown(default, null) : String;\r\n\tpublic function new(target : T, method : String, ?setup : String, ?teardown : String) {\r\n\t\tthis.target   = target;\r\n\t\tthis.method   = method;\r\n\t\tthis.setup    = setup;\r\n\t\tthis.teardown = teardown;\r\n\t}\r\n\r\n\tfunction checkMethod(name : String, arg : String) {\r\n\t\tvar field = Reflect.field(target, name);\r\n\t\tif(field == null)              throw arg + \" function \" + name + \" is not a field of target\";\r\n\t\tif(!Reflect.isFunction(field)) throw arg + \" function \" + name + \" is not a function\";\r\n\t}\r\n}","package utest;\r\n\r\nimport utest.Assertation;\r\n\r\n/**\r\n* @todo add documentation\r\n*/\r\nclass TestHandler<T> {\r\n\tprivate static inline var POLLING_TIME = 10;\r\n\tpublic var results(default, null) : List<Assertation>;\r\n\tpublic var fixture(default, null) : TestFixture<T>;\r\n\tvar asyncStack : List<Dynamic>;\r\n\r\n\tpublic var onTested(default, null) : Dispatcher<TestHandler<T>>;\r\n\tpublic var onTimeout(default, null) : Dispatcher<TestHandler<T>>;\r\n\tpublic var onComplete(default, null) : Dispatcher<TestHandler<T>>;\r\n\r\n\tpublic function new(fixture : TestFixture<T>) {\r\n\t\tif(fixture == null) throw \"fixture argument is null\";\r\n\t\tthis.fixture  = fixture;\r\n\t\tresults       = new List();\r\n\t\tasyncStack    = new List();\r\n\t\tonTested   = new Dispatcher();\r\n\t\tonTimeout  = new Dispatcher();\r\n\t\tonComplete = new Dispatcher();\r\n\t}\r\n\r\n\tpublic function execute() {\r\n\t\ttry {\r\n\t\t\texecuteMethod(fixture.setup);\r\n\t\t\ttry {\r\n\t\t\t\texecuteMethod(fixture.method);\r\n\t\t\t} catch (e : Dynamic) {\r\n\t\t\t\tresults.add(Error(e, exceptionStack()));\r\n\t\t\t}\r\n\t\t} catch(e : Dynamic) {\r\n\t\t\tresults.add(SetupError(e, exceptionStack()));\r\n\t\t}\r\n\t\tcheckTested();\r\n\t}\r\n\r\n\tstatic function exceptionStack(pops = 2)\r\n\t{\r\n\t\tvar stack = haxe.CallStack.exceptionStack();\r\n\t\twhile (pops-- > 0)\r\n\t\t{\r\n\t\t\tstack.pop();\r\n\t\t}\r\n\t\treturn stack;\r\n\t}\r\n\r\n\tfunction checkTested() {\r\n#if (flash || js)\r\n\t\tif(expireson == null || asyncStack.length == 0) {\r\n\t\t\ttested();\r\n\t\t} else if(haxe.Timer.stamp() > expireson) {\r\n\t\t\ttimeout();\r\n\t\t} else {\r\n\t\t\thaxe.Timer.delay(checkTested, POLLING_TIME);\r\n\t\t}\r\n#else\r\n\t\tif(asyncStack.length == 0)\r\n\t\t\ttested();\r\n\t\telse\r\n\t\t\ttimeout();\r\n#end\r\n\t}\r\n\r\n\tpublic var expireson(default, null) : Null<Float>;\r\n\tpublic function setTimeout(timeout : Int) {\r\n\t\tvar newexpire = haxe.Timer.stamp() + timeout/1000;\r\n\t\texpireson = (expireson == null) ? newexpire : (newexpire > expireson ? newexpire : expireson);\r\n\t}\r\n\r\n\tfunction bindHandler() {\r\n\t\tAssert.results     = this.results;\r\n\t\tAssert.createAsync = this.addAsync;\r\n\t\tAssert.createEvent = this.addEvent;\r\n\t}\r\n\r\n\tfunction unbindHandler() {\r\n\t\tAssert.results     = null;\r\n\t\tAssert.createAsync = function(?f, ?t){ return function(){}};\r\n\t\tAssert.createEvent = function(f, ?t){ return function(e){}};\r\n\t}\r\n\r\n\t/**\r\n\t* Adds a function that is called asynchronously.\r\n\t*\r\n\t* Example:\r\n\t* <pre>\r\n\t* var fixture = new TestFixture(new TestClass(), \"test\");\r\n\t* var handler = new TestHandler(fixture);\r\n\t* var flag = false;\r\n\t* var async = handler.addAsync(function() {\r\n\t*   flag = true;\r\n\t* }, 50);\r\n\t* handler.onTimeout.add(function(h) {\r\n\t*   trace(\"TIMEOUT\");\r\n\t* });\r\n\t* handler.onTested.add(function(h) {\r\n\t*   trace(flag ? \"OK\" : \"FAILED\");\r\n\t* });\r\n\t* haxe.Timer.delay(function() async(), 10);\r\n\t* handler.execute();\r\n\t* </pre>\r\n\t* @param\tf, the function that is called asynchrnously\r\n\t* @param\ttimeout, the maximum time to wait for f() (default is 250)\r\n\t* @return\treturns a function closure that must be executed asynchrnously\r\n\t*/\r\n\tpublic function addAsync(?f : Void->Void, timeout = 250) {\r\n\t\tif (null == f)\r\n\t\t\tf = function() { }\r\n\t\tasyncStack.add(f);\r\n\t\tvar handler = this;\r\n\t\tsetTimeout(timeout);\r\n\t\treturn function() {\r\n\t\t\tif(!handler.asyncStack.remove(f)) {\r\n\t\t\t\thandler.results.add(AsyncError(\"async function already executed\", []));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\thandler.bindHandler();\r\n\t\t\t\tf();\r\n\t\t\t} catch(e : Dynamic) {\r\n\t\t\t\thandler.results.add(AsyncError(e, exceptionStack(0))); // TODO check the correct number of functions is popped from the stack\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tpublic function addEvent<EventArg>(f : EventArg->Void, timeout = 250) {\r\n\t\tasyncStack.add(f);\r\n\t\tvar handler = this;\r\n\t\tsetTimeout(timeout);\r\n\t\treturn function(e : EventArg) {\r\n\t\t\tif(!handler.asyncStack.remove(f)) {\r\n\t\t\t\thandler.results.add(AsyncError(\"event already executed\", []));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\thandler.bindHandler();\r\n\t\t\t\tf(e);\r\n\t\t\t} catch(e : Dynamic) {\r\n\t\t\t\thandler.results.add(AsyncError(e, exceptionStack(0))); // TODO check the correct number of functions is popped from the stack\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tfunction executeMethod(name : String) {\r\n\t\tif(name == null) return;\r\n\t\tbindHandler();\r\n\t\tReflect.callMethod(fixture.target, Reflect.field(fixture.target, name), []);\r\n\t}\r\n\r\n\tfunction tested() {\r\n\t\tif(results.length == 0)\r\n\t\t\tresults.add(Warning(\"no assertions\"));\r\n\t\tonTested.dispatch(this);\r\n\t\tcompleted();\r\n\t}\r\n\r\n\tfunction timeout() {\r\n\t\tresults.add(TimeoutError(asyncStack.length, []));\r\n\t\tonTimeout.dispatch(this);\r\n\t\tcompleted();\r\n\t}\r\n\r\n\tfunction completed() {\r\n\t\ttry {\r\n\t\t\texecuteMethod(fixture.teardown);\r\n\t\t} catch(e : Dynamic) {\r\n\t\t\tresults.add(TeardownError(e, exceptionStack(2))); // TODO check the correct number of functions is popped from the stack\r\n\t\t}\r\n\t\tunbindHandler();\r\n\t\tonComplete.dispatch(this);\r\n\t}\r\n}","package utest;\r\n\r\nimport utest.Assertation;\r\n\r\n/**\r\n* @todo add documentation\r\n*/\r\nclass TestResult {\r\n\tpublic var pack          : String;\r\n\tpublic var cls           : String;\r\n\tpublic var method        : String;\r\n\tpublic var setup         : String;\r\n\tpublic var teardown      : String;\r\n\tpublic var assertations  : List<Assertation>;\r\n\r\n\tpublic function new(){}\r\n\r\n\tpublic static function ofHandler(handler : TestHandler<Dynamic>) {\r\n\t\tvar r = new TestResult();\r\n\t\tvar path = Type.getClassName(Type.getClass(handler.fixture.target)).split('.');\r\n\t\tr.cls           = path.pop();\r\n\t\tr.pack          = path.join('.');\r\n\t\tr.method        = handler.fixture.method;\r\n\t\tr.setup         = handler.fixture.setup;\r\n\t\tr.teardown      = handler.fixture.teardown;\r\n\t\tr.assertations  = handler.results;\r\n\t\treturn r;\r\n\t}\r\n\r\n        public function allOk():Bool{\r\n\t\tfor (l in assertations){\r\n\t\t\tswitch (l){\r\n\t\t\t\tcase Success(_): break;\r\n\t\t\t\tdefault: return false;\r\n\t\t\t}\r\n\t\t}\r\n                return true;\r\n        }\r\n}\r\n","package utest.ui;\r\n\r\nimport utest.Runner;\r\nimport utest.ui.common.IReport;\r\nimport utest.ui.text.HtmlReport;\r\nimport utest.ui.text.PrintReport;\r\nimport utest.ui.common.HeaderDisplayMode;\r\n\r\n#if php\r\nimport php.Web;\r\n#elseif neko\r\nimport neko.Web;\r\n#end\r\n\r\nclass Report\r\n{\r\n\tpublic static function create(runner : Runner, ?displaySuccessResults : SuccessResultsDisplayMode, ?headerDisplayMode : HeaderDisplayMode) : IReport<Dynamic>\r\n\t{\r\n\t\tvar report : IReport<Dynamic>;\r\n#if (php || neko)\r\n\t\tif (!Web.isModNeko)\r\n\t\t\treport = new PrintReport(runner);\r\n\t\telse\r\n\t\treport = new HtmlReport(runner, true);\r\n#elseif nodejs\r\n\t\treport = new PrintReport(runner);\r\n#elseif js\r\n\t\treport = new HtmlReport(runner, true);\r\n#elseif flash\r\n\t\tif(flash.external.ExternalInterface.available)\r\n\t\t\treport = new HtmlReport(runner, true);\r\n\t\telse\r\n\t\t\treport = new PrintReport(runner);\r\n#else\r\n\t\treport = new PrintReport(runner);\r\n#end\r\n\t\tif (null == displaySuccessResults)\r\n\t\t\treport.displaySuccessResults = ShowSuccessResultsWithNoErrors;\r\n\t\telse\r\n\t\t\treport.displaySuccessResults = displaySuccessResults;\r\n\t\t\t\r\n\t\tif (null == headerDisplayMode)\r\n\t\t\treport.displayHeader = ShowHeaderWithResults;\r\n\t\telse\r\n\t\t\treport.displayHeader = headerDisplayMode;\r\n\t\t\t\r\n\t\treturn report;\r\n\t}\r\n}","package utest.ui.common;\r\n\r\nimport utest.TestResult;\r\n\r\n/**\r\n* @todo add documentation\r\n*/\r\nclass ClassResult {\r\n\tvar fixtures : Map<String, FixtureResult>;\r\n\tpublic var className(default, null) : String;\r\n\tpublic var setupName(default, null) : String;\r\n\tpublic var teardownName(default, null) : String;\r\n\tpublic var hasSetup(default, null) : Bool;\r\n\tpublic var hasTeardown(default, null) : Bool;\r\n\r\n\tpublic var methods(default, null) : Int;\r\n\tpublic var stats(default, null) : ResultStats;\r\n\r\n\tpublic function new(className : String, setupName : String, teardownName : String) {\r\n\t\tfixtures = new Map();\r\n\t\tthis.className = className;\r\n\t\tthis.setupName = setupName;\r\n\t\thasSetup = setupName != null;\r\n\t\tthis.teardownName = teardownName;\r\n\t\thasTeardown = teardownName != null;\r\n\r\n\t\tmethods = 0;\r\n\t\tstats = new ResultStats();\r\n\t}\r\n\r\n\tpublic function add(result : FixtureResult) {\r\n\t\tif(fixtures.exists(result.methodName)) throw \"invalid duplicated fixture result\";\r\n\r\n\t\tstats.wire(result.stats);\r\n\r\n\t\tmethods++;\r\n\t\tfixtures.set(result.methodName, result);\r\n\t}\r\n\r\n\tpublic function get(method : String) {\r\n\t\treturn fixtures.get(method);\r\n\t}\r\n\r\n\tpublic function exists(method : String) {\r\n\t\treturn fixtures.exists(method);\r\n\t}\r\n\r\n\tpublic function methodNames(errorsHavePriority = true) : Array<String> {\r\n\t\tvar names = [];\r\n\t\tfor(name in fixtures.keys())\r\n\t\t\tnames.push(name);\r\n\t\tif(errorsHavePriority) {\r\n\t\t\tvar me = this;\r\n\t\t\tnames.sort(function(a, b) {\r\n\t\t\t\tvar as = me.get(a).stats;\r\n\t\t\t\tvar bs = me.get(b).stats;\r\n\t\t\t\tif(as.hasErrors) {\r\n\t\t\t\t\treturn (!bs.hasErrors) ? -1 : (as.errors == bs.errors ? Reflect.compare(a, b) : Reflect.compare(as.errors, bs.errors));\r\n\t\t\t\t} else if(bs.hasErrors) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else if(as.hasFailures) {\r\n\t\t\t\t\treturn (!bs.hasFailures) ? -1 : (as.failures == bs.failures ? Reflect.compare(a, b) : Reflect.compare(as.failures, bs.failures));\r\n\t\t\t\t} else if(bs.hasFailures) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else if(as.hasWarnings) {\r\n\t\t\t\t\treturn (!bs.hasWarnings) ? -1 : (as.warnings == bs.warnings ? Reflect.compare(a, b) : Reflect.compare(as.warnings, bs.warnings));\r\n\t\t\t\t} else if(bs.hasWarnings) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Reflect.compare(a, b);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tnames.sort(function(a, b) {\r\n\t\t\t\treturn Reflect.compare(a, b);\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn names;\r\n\t}\r\n\r\n\r\n}","package utest.ui.common;\r\n\r\nimport utest.Assertation;\r\n\r\n/**\r\n* @todo add documentation\r\n*/\r\nclass FixtureResult {\r\n\tpublic var methodName(default, null) : String;\r\n\tpublic var hasTestError(default, null) : Bool;\r\n\tpublic var hasSetupError(default, null) : Bool;\r\n\tpublic var hasTeardownError(default, null) : Bool;\r\n\tpublic var hasTimeoutError(default, null) : Bool;\r\n\tpublic var hasAsyncError(default, null) : Bool;\r\n\r\n\tpublic var stats(default, null) : ResultStats;\r\n\r\n\tvar list(default, null) : List<Assertation>;\r\n\tpublic function new(methodName : String) {\r\n\t\tthis.methodName = methodName;\r\n\t\tthis.list = new List();\r\n\t\thasTestError = false;\r\n\t\thasSetupError = false;\r\n\t\thasTeardownError = false;\r\n\t\thasTimeoutError = false;\r\n\t\thasAsyncError = false;\r\n\r\n\t\tstats = new ResultStats();\r\n\t}\r\n\r\n\tpublic function iterator() {\r\n\t\treturn list.iterator();\r\n\t}\r\n\r\n\tpublic function add(assertation : Assertation) {\r\n\t\tlist.add(assertation);\r\n\t\tswitch(assertation) {\r\n\t\t\tcase Success(_):\r\n\t\t\t\tstats.addSuccesses(1);\r\n\t\t\tcase Failure(_, _):\r\n\t\t\t\tstats.addFailures(1);\r\n\t\t\tcase Error(_, _):\r\n\t\t\t\tstats.addErrors(1);\r\n\t\t\tcase SetupError(_, _):\r\n\t\t\t\tstats.addErrors(1);\r\n\t\t\t\thasSetupError = true;\r\n\t\t\tcase TeardownError(_, _):\r\n\t\t\t\tstats.addErrors(1);\r\n\t\t\t\thasTeardownError = true;\r\n\t\t\tcase TimeoutError(_, _):\r\n\t\t\t\tstats.addErrors(1);\r\n\t\t\t\thasTimeoutError = true;\r\n\t\t\tcase AsyncError(_, _):\r\n\t\t\t\tstats.addErrors(1);\r\n\t\t\t\thasAsyncError = true;\r\n\t\t\tcase Warning(_):\r\n\t\t\t\tstats.addWarnings(1);\r\n\t\t}\r\n\t}\r\n}","package utest.ui.common;\r\n\r\nimport utest.TestResult;\r\nimport utest.Assertation;\r\n\r\n/**\r\n* @todo add documentation\r\n* @todo add tests for this class\r\n*/\r\nclass PackageResult {\r\n\tpublic var packageName(default, null) : String;\r\n\tvar classes : Map<String, ClassResult>;\r\n\tvar packages : Map<String, PackageResult>;\r\n\r\n\tpublic var stats(default, null) : ResultStats;\r\n\r\n\tpublic function new(packageName : String) {\r\n\t\tthis.packageName = packageName;\r\n\t\tclasses = new Map();\r\n\t\tpackages = new Map();\r\n\t\tstats = new ResultStats();\r\n\t}\r\n\r\n\tpublic function addResult(result : TestResult, flattenPackage : Bool) {\r\n\t\tvar pack = getOrCreatePackage(result.pack, flattenPackage, this);\r\n\t\tvar cls = getOrCreateClass(pack, result.cls, result.setup, result.teardown);\r\n\t\tvar fix = createFixture(result.method, result.assertations);\r\n\t\tcls.add(fix);\r\n\t}\r\n\r\n\tpublic function addClass(result : ClassResult) {\r\n\t\tclasses.set(result.className, result);\r\n\t\tstats.wire(result.stats);\r\n\t}\r\n\r\n\tpublic function addPackage(result : PackageResult) {\r\n\t\tpackages.set(result.packageName, result);\r\n\t\tstats.wire(result.stats);\r\n\t}\r\n\r\n\tpublic function existsPackage(name : String) {\r\n\t\treturn packages.exists(name);\r\n\t}\r\n\r\n\tpublic function existsClass(name : String) {\r\n\t\treturn classes.exists(name);\r\n\t}\r\n\r\n\tpublic function getPackage(name : String) {\r\n\t\tif (packageName == null && name == \"\") return this;\r\n\t\treturn packages.get(name);\r\n\t}\r\n\r\n\tpublic function getClass(name : String) {\r\n\t\treturn classes.get(name);\r\n\t}\r\n\r\n\tpublic function classNames(errorsHavePriority = true) : Array<String> {\r\n\t\tvar names = [];\r\n\t\tfor(name in classes.keys())\r\n\t\t\tnames.push(name);\r\n\t\tif(errorsHavePriority) {\r\n\t\t\tvar me = this;\r\n\t\t\tnames.sort(function(a, b) {\r\n\t\t\t\tvar as = me.getClass(a).stats;\r\n\t\t\t\tvar bs = me.getClass(b).stats;\r\n\t\t\t\tif(as.hasErrors) {\r\n\t\t\t\t\treturn (!bs.hasErrors) ? -1 : (as.errors == bs.errors ? Reflect.compare(a, b) : Reflect.compare(as.errors, bs.errors));\r\n\t\t\t\t} else if(bs.hasErrors) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else if(as.hasFailures) {\r\n\t\t\t\t\treturn (!bs.hasFailures) ? -1 : (as.failures == bs.failures ? Reflect.compare(a, b) : Reflect.compare(as.failures, bs.failures));\r\n\t\t\t\t} else if(bs.hasFailures) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else if(as.hasWarnings) {\r\n\t\t\t\t\treturn (!bs.hasWarnings) ? -1 : (as.warnings == bs.warnings ? Reflect.compare(a, b) : Reflect.compare(as.warnings, bs.warnings));\r\n\t\t\t\t} else if(bs.hasWarnings) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Reflect.compare(a, b);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tnames.sort(function(a, b) {\r\n\t\t\t\treturn Reflect.compare(a, b);\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn names;\r\n\t}\r\n\r\n\tpublic function packageNames(errorsHavePriority = true) : Array<String> {\r\n\t\tvar names = [];\r\n\t\tif (packageName == null) names.push(\"\");\r\n\t\tfor(name in packages.keys())\r\n\t\t\tnames.push(name);\r\n\t\tif(errorsHavePriority) {\r\n\t\t\tvar me = this;\r\n\t\t\tnames.sort(function(a, b) {\r\n\t\t\t\tvar as = me.getPackage(a).stats;\r\n\t\t\t\tvar bs = me.getPackage(b).stats;\r\n\t\t\t\tif(as.hasErrors) {\r\n\t\t\t\t\treturn (!bs.hasErrors) ? -1 : (as.errors == bs.errors ? Reflect.compare(a, b) : Reflect.compare(as.errors, bs.errors));\r\n\t\t\t\t} else if(bs.hasErrors) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else if(as.hasFailures) {\r\n\t\t\t\t\treturn (!bs.hasFailures) ? -1 : (as.failures == bs.failures ? Reflect.compare(a, b) : Reflect.compare(as.failures, bs.failures));\r\n\t\t\t\t} else if(bs.hasFailures) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else if(as.hasWarnings) {\r\n\t\t\t\t\treturn (!bs.hasWarnings) ? -1 : (as.warnings == bs.warnings ? Reflect.compare(a, b) : Reflect.compare(as.warnings, bs.warnings));\r\n\t\t\t\t} else if(bs.hasWarnings) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Reflect.compare(a, b);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tnames.sort(function(a, b) {\r\n\t\t\t\treturn Reflect.compare(a, b);\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn names;\r\n\t}\r\n\t\r\n\tfunction createFixture(method : String, assertations : Iterable<Assertation>) {\r\n\t\tvar f = new FixtureResult(method);\r\n\t\tfor(assertation in assertations)\r\n\t\t\tf.add(assertation);\r\n\t\treturn f;\r\n\t}\r\n\r\n\tfunction getOrCreateClass(pack : PackageResult, cls : String, setup : String, teardown : String) {\r\n\t\tif(pack.existsClass(cls)) return pack.getClass(cls);\r\n\t\tvar c = new ClassResult(cls, setup, teardown);\r\n\t\tpack.addClass(c);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction getOrCreatePackage(pack : String, flat : Bool, ref : PackageResult) {\r\n\t\tif(pack == null || pack == '') return ref;\r\n\t\tif(flat) {\r\n\t\t\tif(ref.existsPackage(pack))\r\n\t\t\t\treturn ref.getPackage(pack);\r\n\t\t\tvar p = new PackageResult(pack);\r\n\t\t\tref.addPackage(p);\r\n\t\t\treturn p;\r\n\t\t} else {\r\n\t\t\tvar parts = pack.split('.');\r\n\t\t\tfor(part in parts) {\r\n\t\t\t\tref = getOrCreatePackage(part, true, ref);\r\n\t\t\t}\r\n\t\t\treturn ref;\r\n\t\t}\r\n\t}\r\n}","package utest.ui.common;\r\n\r\nimport utest.ui.common.HeaderDisplayMode;\r\n\r\nclass ReportTools\r\n{\r\n\tpublic static function hasHeader(report : IReport<Dynamic>, stats : ResultStats)\r\n\t{\r\n\t\tswitch(report.displayHeader)\r\n\t\t{\r\n\t\t\tcase NeverShowHeader:\r\n\t\t\t\treturn false;\r\n\t\t\tcase ShowHeaderWithResults:\r\n\t\t\t\tif (!stats.isOk)\r\n\t\t\t\t\treturn true;\r\n\t\t\t\tswitch(report.displaySuccessResults)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase NeverShowSuccessResults:\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\tcase AlwaysShowSuccessResults, ShowSuccessResultsWithNoErrors:\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\tcase AlwaysShowHeader:\r\n\t\t\t\treturn true;\r\n\t\t};\r\n\t}\r\n\t\r\n\tpublic static function skipResult(report : IReport<Dynamic>, stats : ResultStats, isOk)\r\n\t{\r\n\t\tif (!stats.isOk) return false;\r\n\t\treturn switch(report.displaySuccessResults)\r\n\t\t{\r\n\t\t\tcase NeverShowSuccessResults: true;\r\n\t\t\tcase AlwaysShowSuccessResults: false;\r\n\t\t\tcase ShowSuccessResultsWithNoErrors: !isOk;\r\n\t\t};\r\n\t}\r\n\t\r\n\tpublic static function hasOutput(report : IReport<Dynamic>, stats : ResultStats)\r\n\t{\r\n\t\tif (!stats.isOk) return true;\r\n\t\treturn hasHeader(report, stats);\r\n\t}\r\n}","package utest.ui.common;\r\n\r\nimport utest.Dispatcher;\r\nimport utest.Runner;\r\nimport utest.TestResult;\r\n\r\n/**\r\n* @todo add documentation\r\n* @todo add tests for this class\r\n*/\r\nclass ResultAggregator {\r\n\tvar runner : Runner;\r\n\tvar flattenPackage : Bool;\r\n\tpublic var root(default, null) : PackageResult;\r\n\r\n\tpublic var onStart(default, null) : Notifier;\r\n\tpublic var onComplete(default, null) : Dispatcher<PackageResult>;\r\n\tpublic var onProgress(default, null) : Dispatcher<{ done : Int, totals : Int }>;\r\n\r\n\tpublic function new(runner : Runner, flattenPackage = false) {\r\n\t\tif(runner == null) throw \"runner argument is null\";\r\n\t\tthis.flattenPackage = flattenPackage;\r\n\t\tthis.runner = runner;\r\n\t\trunner.onStart.add(start);\r\n\t\trunner.onProgress.add(progress);\r\n\t\trunner.onComplete.add(complete);\r\n\r\n\t\tonStart = new Notifier();\r\n\t\tonComplete = new Dispatcher();\r\n\t\tonProgress = new Dispatcher();\r\n\t}\r\n\r\n\tfunction start(runner : Runner) {\r\n\t\troot = new PackageResult(null);\r\n\t\tonStart.dispatch();\r\n\t}\r\n\r\n\tfunction getOrCreatePackage(pack : String, flat : Bool, ?ref : PackageResult) {\r\n\t\tif(ref == null) ref = root;\r\n\t\tif(pack == null || pack == '') return ref;\r\n\t\tif(flat) {\r\n\t\t\tif(ref.existsPackage(pack))\r\n\t\t\t\treturn ref.getPackage(pack);\r\n\t\t\tvar p = new PackageResult(pack);\r\n\t\t\tref.addPackage(p);\r\n\t\t\treturn p;\r\n\t\t} else {\r\n\t\t\tvar parts = pack.split('.');\r\n\t\t\tfor(part in parts) {\r\n\t\t\t\tref = getOrCreatePackage(part, true, ref);\r\n\t\t\t}\r\n\t\t\treturn ref;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getOrCreateClass(pack : PackageResult, cls : String, setup : String, teardown : String) {\r\n\t\tif(pack.existsClass(cls)) return pack.getClass(cls);\r\n\t\tvar c = new ClassResult(cls, setup, teardown);\r\n\t\tpack.addClass(c);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction createFixture(result : TestResult) {\r\n\t\tvar f = new FixtureResult(result.method);\r\n\t\tfor(assertation in result.assertations)\r\n\t\t\tf.add(assertation);\r\n\t\treturn f;\r\n\t}\r\n\r\n\tfunction progress(e) {\r\n\t\troot.addResult(e.result, flattenPackage);\r\n\t\tonProgress.dispatch(e);\r\n\t}\r\n\r\n\tfunction complete(runner : Runner) {\r\n\t\tonComplete.dispatch(root);\r\n\t}\r\n}","package utest.ui.common;\r\n\r\nimport utest.Dispatcher;\r\n\r\n/**\r\n* @todo add documentation\r\n*/\r\nclass ResultStats {\r\n\tpublic var assertations(default, null) : Int;\r\n\tpublic var successes(default, null) : Int;\r\n\tpublic var failures(default, null) : Int;\r\n\tpublic var errors(default, null) : Int;\r\n\tpublic var warnings(default, null) : Int;\r\n\tpublic var onAddSuccesses(default, null) : Dispatcher<Int>;\r\n\tpublic var onAddFailures(default, null)  : Dispatcher<Int>;\r\n\tpublic var onAddErrors(default, null)    : Dispatcher<Int>;\r\n\tpublic var onAddWarnings(default, null)  : Dispatcher<Int>;\r\n\r\n\tpublic var isOk(default, null) : Bool;\r\n\tpublic var hasFailures(default, null) : Bool;\r\n\tpublic var hasErrors(default, null) : Bool;\r\n\tpublic var hasWarnings(default, null) : Bool;\r\n\r\n\tpublic function new() {\r\n\t\tassertations = 0;\r\n\t\tsuccesses = 0;\r\n\t\tfailures = 0;\r\n\t\terrors = 0;\r\n\t\twarnings = 0;\r\n\r\n\t\tisOk = true;\r\n\t\thasFailures = false;\r\n\t\thasErrors = false;\r\n\t\thasWarnings = false;\r\n\r\n\t\tonAddSuccesses = new Dispatcher();\r\n\t\tonAddFailures = new Dispatcher();\r\n\t\tonAddErrors = new Dispatcher();\r\n\t\tonAddWarnings = new Dispatcher();\r\n\t}\r\n\r\n\tpublic function addSuccesses(v : Int) {\r\n\t\tif(v == 0) return;\r\n\t\tassertations += v;\r\n\t\tsuccesses += v;\r\n\t\tonAddSuccesses.dispatch(v);\r\n\t}\r\n\r\n\tpublic function addFailures(v : Int) {\r\n\t\tif(v == 0) return;\r\n\t\tassertations += v;\r\n\t\tfailures += v;\r\n\t\thasFailures = failures > 0;\r\n\t\tisOk = !(hasFailures || hasErrors || hasWarnings);\r\n\t\tonAddFailures.dispatch(v);\r\n\t}\r\n\r\n\tpublic function addErrors(v : Int) {\r\n\t\tif(v == 0) return;\r\n\t\tassertations += v;\r\n\t\terrors += v;\r\n\t\thasErrors = errors > 0;\r\n\t\tisOk = !(hasFailures || hasErrors || hasWarnings);\r\n\t\tonAddErrors.dispatch(v);\r\n\t}\r\n\r\n\tpublic function addWarnings(v : Int) {\r\n\t\tif(v == 0) return;\r\n\t\tassertations += v;\r\n\t\twarnings += v;\r\n\t\thasWarnings = warnings > 0;\r\n\t\tisOk = !(hasFailures || hasErrors || hasWarnings);\r\n\t\tonAddWarnings.dispatch(v);\r\n\t}\r\n\r\n\tpublic function sum(other : ResultStats) {\r\n\t\taddSuccesses(other.successes);\r\n\t\taddFailures(other.failures);\r\n\t\taddErrors(other.errors);\r\n\t\taddWarnings(other.warnings);\r\n\t}\r\n\r\n\tpublic function subtract(other : ResultStats) {\r\n\t\taddSuccesses(-other.successes);\r\n\t\taddFailures(-other.failures);\r\n\t\taddErrors(-other.errors);\r\n\t\taddWarnings(-other.warnings);\r\n\t}\r\n\r\n\tpublic function wire(dependant : ResultStats) {\r\n\t\tdependant.onAddSuccesses.add(addSuccesses);\r\n\t\tdependant.onAddFailures.add(addFailures);\r\n\t\tdependant.onAddErrors.add(addErrors);\r\n\t\tdependant.onAddWarnings.add(addWarnings);\r\n\t\tsum(dependant);\r\n\t}\r\n\r\n\tpublic function unwire(dependant : ResultStats) {\r\n\t\tdependant.onAddSuccesses.remove(addSuccesses);\r\n\t\tdependant.onAddFailures.remove(addFailures);\r\n\t\tdependant.onAddErrors.remove(addErrors);\r\n\t\tdependant.onAddWarnings.remove(addWarnings);\r\n\t\tsubtract(dependant);\r\n\t}\r\n\r\n}","package utest.ui.text;\n\nimport haxe.PosInfos;\nimport haxe.Timer;\nimport utest.ui.common.ClassResult;\nimport utest.ui.common.FixtureResult;\nimport utest.ui.common.IReport;\nimport utest.ui.common.HeaderDisplayMode;\n\nimport utest.Runner;\nimport utest.TestResult;\nimport utest.ui.common.ResultAggregator;\nimport utest.ui.common.PackageResult;\nimport utest.ui.common.ResultStats;\n\nimport haxe.CallStack;\n\nusing utest.ui.common.ReportTools;\n\n#if php\nimport php.Lib;\n#elseif neko\nimport neko.Lib;\n#elseif cpp\nimport cpp.Lib;\n#elseif js\nimport js.Browser;\n#end\n\n/**\n* @todo add documentation\n*/\nclass HtmlReport implements IReport < HtmlReport > {\n\tstatic var platform = #if neko 'neko' #elseif php 'php'  #elseif cpp 'cpp'  #elseif js 'javascript' #elseif flash 'flash' #else 'unknown' #end;\n\n\tpublic var traceRedirected(default, null) : Bool;\n\tpublic var displaySuccessResults : SuccessResultsDisplayMode;\n\tpublic var displayHeader : HeaderDisplayMode;\n\tpublic var handler : HtmlReport -> Void;\n\n\tvar aggregator : ResultAggregator;\n\tvar oldTrace : Dynamic;\n\tvar _traces : Array<{ msg : String, infos : PosInfos, time : Float, delta : Float, stack : Array<StackItem> }>;\n\n\tpublic function new(runner : Runner, ?outputHandler : HtmlReport -> Void, traceRedirected = true) {\n\t\taggregator = new ResultAggregator(runner, true);\n\t\trunner.onStart.add(start);\n\t\taggregator.onComplete.add(complete);\n\t\tif (null == outputHandler)\n\t\t\tsetHandler(_handler);\n\t\telse\n\t\t\tsetHandler(outputHandler);\n\t\tif (traceRedirected)\n\t\t\tredirectTrace();\n\t\tdisplaySuccessResults = AlwaysShowSuccessResults;\n\t\tdisplayHeader = AlwaysShowHeader;\n\t}\n\n\tpublic function setHandler(handler : HtmlReport -> Void) : Void\n\t{\n\t\tthis.handler = handler;\n\t}\n\n\tpublic function redirectTrace()\n\t{\n\t\tif (traceRedirected)\n\t\t\treturn;\n\t\t_traces = [];\n\t\toldTrace = haxe.Log.trace;\n\t\thaxe.Log.trace = _trace;\n\t}\n\n\tpublic function restoreTrace()\n\t{\n\t\tif (!traceRedirected)\n\t\t\treturn;\n\t\thaxe.Log.trace = oldTrace;\n\t}\n\n\tvar _traceTime : Null<Float>;\n\tfunction _trace(v : Dynamic, ?infos : PosInfos)\n\t{\n\t\tvar time = Timer.stamp();\n\t\tvar delta = _traceTime == null ? 0 : time - _traceTime;\n\t\t_traces.push( {\n\t\t\tmsg : StringTools.htmlEscape(Std.string(v)),\n\t\t\tinfos : infos,\n\t\t\ttime : time - startTime,\n\t\t\tdelta : delta,\n\t\t\tstack : CallStack.callStack()\n\t\t} );\n\t\t_traceTime = Timer.stamp();\n\t}\n\n\tvar startTime : Float;\n\tfunction start(e) {\n\t\tstartTime = Timer.stamp();\n\t}\n\n\tfunction cls(stats : ResultStats)\n\t{\n\t\tif (stats.hasErrors)\n\t\t\treturn 'error';\n\t\telse if (stats.hasFailures)\n\t\t\treturn 'failure';\n\t\telse if (stats.hasWarnings)\n\t\t\treturn 'warn';\n\t\telse\n\t\t\treturn 'ok';\n\t}\n\n\tfunction resultNumbers(buf : StringBuf, stats : ResultStats)\n\t{\n\t\tvar numbers = [];\n\t\tif (stats.assertations == 1)\n\t\t\tnumbers.push('<strong>1</strong> test');\n\t\telse\n\t\t\tnumbers.push('<strong>' + stats.assertations + '</strong> tests');\n\n\t\tif (stats.successes != stats.assertations)\n\t\t{\n\t\t\tif (stats.successes == 1)\n\t\t\t\tnumbers.push('<strong>1</strong> pass');\n\t\t\telse if (stats.successes > 0)\n\t\t\t\tnumbers.push('<strong>' + stats.successes + '</strong> passes');\n\t\t}\n\n\t\tif (stats.errors == 1)\n\t\t\tnumbers.push('<strong>1</strong> error');\n\t\telse if (stats.errors > 0)\n\t\t\tnumbers.push('<strong>' + stats.errors + '</strong> errors');\n\n\t\tif (stats.failures == 1)\n\t\t\tnumbers.push('<strong>1</strong> failure');\n\t\telse if (stats.failures > 0)\n\t\t\tnumbers.push('<strong>' + stats.failures + '</strong> failures');\n\n\t\tif (stats.warnings == 1)\n\t\t\tnumbers.push('<strong>1</strong> warning');\n\t\telse if (stats.warnings > 0)\n\t\t\tnumbers.push('<strong>' + stats.warnings + '</strong> warnings');\n\n\t\tbuf.add(numbers.join(', '));\n\t}\n\n\tfunction blockNumbers(buf : StringBuf, stats : ResultStats)\n\t{\n\t\tbuf.add('<div class=\"' + cls(stats) + 'bg statnumbers\">');\n\t\tresultNumbers(buf, stats);\n\t\tbuf.add('</div>');\n\t}\n\n\tfunction formatStack(stack : Array<StackItem>, addNL = true)\n\t{\n\t\tvar parts = [];\n\t\tvar nl = addNL ? '\\n' : '';\n\t\tvar last = null;\n\t\tvar count = 1;\n\t\tfor (part in CallStack.toString(stack).split('\\n'))\n\t\t{\n\t\t\tif (StringTools.trim(part) == '')\n\t\t\t\tcontinue;\n\t\t\tif ( -1 < part.indexOf('Called from utest.'))\n\t\t\t\tcontinue;\n#if neko\n\t\t\tif ( -1 < part.indexOf('Called from a C function'))\n\t\t\t\tcontinue;\n#end\n\t\t\tif (part == last)\n\t\t\t{\n\t\t\t\tparts[parts.length - 1] = part + \" (#\" + (++count) + \")\";\n\t\t\t} else {\n\t\t\t\tcount = 1;\n\t\t\t\tparts.push(last = part);\n\t\t\t}\n\t\t}\n\n\t\tvar s = '<ul><li>' + parts.join('</li>'+nl+'<li>') + '</li></ul>'+nl;\n\n\t\treturn \"<div>\" + s + \"</div>\"+nl;\n\t}\n\n\tfunction addFixture(buf : StringBuf, result : FixtureResult, name : String, isOk : Bool)\n\t{\n\t\tif (this.skipResult(result.stats, isOk)) return;\n\t\tbuf.add('<li class=\"fixture\"><div class=\"li\">');\n\t\tbuf.add('<span class=\"' + cls(result.stats) + 'bg fixtureresult\">');\n\t\tif(result.stats.isOk) {\n\t\t\tbuf.add(\"OK \");\n\t\t} else if(result.stats.hasErrors) {\n\t\t\tbuf.add(\"ERROR \");\n\t\t} else if(result.stats.hasFailures) {\n\t\t\tbuf.add(\"FAILURE \");\n\t\t} else if(result.stats.hasWarnings) {\n\t\t\tbuf.add(\"WARNING \");\n\t\t}\n\t\tbuf.add('</span>');\n\t\tbuf.add('<div class=\"fixturedetails\">');\n\t\tbuf.add('<strong>' + name + '</strong>');\n\t\tbuf.add(': ');\n\t\tresultNumbers(buf, result.stats);\n\t\tvar messages = [];\n\t\tfor(assertation in result.iterator()) {\n\t\t\tswitch(assertation) {\n\t\t\t\tcase Success(_):\n\t\t\t\tcase Failure(msg, pos):\n\t\t\t\t\tmessages.push(\"<strong>line \" + pos.lineNumber + \"</strong>: <em>\" + StringTools.htmlEscape(msg) + \"</em>\");\n\t\t\t\tcase Error(e, s):\n\t\t\t\t\tmessages.push(\"<strong>error</strong>: <em>\" + getErrorDescription(e) + \"</em>\\n<br/><strong>stack</strong>:\" + getErrorStack(s, e));\n\t\t\t\tcase SetupError(e, s):\n\t\t\t\t\tmessages.push(\"<strong>setup error</strong>: \" + getErrorDescription(e) + \"\\n<br/><strong>stack</strong>:\" + getErrorStack(s, e));\n\t\t\t\tcase TeardownError(e, s):\n\t\t\t\t\tmessages.push(\"<strong>tear-down error</strong>: \" + getErrorDescription(e) + \"\\n<br/><strong>stack</strong>:\" + getErrorStack(s, e));\n\t\t\t\tcase TimeoutError(missedAsyncs, _):\n\t\t\t\t\tmessages.push(\"<strong>missed async call(s)</strong>: \" + missedAsyncs);\n\t\t\t\tcase AsyncError(e, s):\n\t\t\t\t\tmessages.push(\"<strong>async error</strong>: \" + getErrorDescription(e) + \"\\n<br/><strong>stack</strong>:\" + getErrorStack(s, e));\n\t\t\t\tcase Warning(msg):\n\t\t\t\t\tmessages.push(StringTools.htmlEscape(msg));\n\t\t\t}\n\t\t}\n\t\tif (messages.length > 0)\n\t\t{\n\t\t\tbuf.add('<div class=\"testoutput\">');\n\t\t\tbuf.add(messages.join('<br/>'));\n\t\t\tbuf.add('</div>\\n');\n\t\t}\n\t\tbuf.add('</div>\\n');\n\t\tbuf.add('</div></li>\\n');\n\t}\n\n\tfunction getErrorDescription(e : Dynamic)\n\t{\n#if flash9\n\t\tif (Std.is(e, flash.errors.Error))\n\t\t{\n\t\t\tvar err = cast(e, flash.errors.Error);\n\t\t\treturn err.name + \": \" + err.message;\n\t\t} else {\n\t\t\treturn Std.string(e);\n\t\t}\n#else\n\t\treturn Std.string(e);\n#end\n\t}\n\n\tfunction getErrorStack(s : Array<StackItem>, e : Dynamic)\n\t{\n#if flash9\n\t\tif (Std.is(e, flash.errors.Error))\n\t\t{\n\t\t\tvar stack = cast(e, flash.errors.Error).getStackTrace();\n\t\t\tif (null != stack)\n\t\t\t{\n\t\t\t\tvar parts = stack.split(\"\\n\");\n\t\t\t\t// cleanup utest calls\n\t\t\t\tvar result = [];\n\t\t\t\tfor (p in parts)\n\t\t\t\t\tif (p.indexOf(\"at utest::\") < 0)\n\t\t\t\t\t\tresult.push(p);\n\t\t\t\t// pops the last 2 calls\n\t\t\t\tresult.pop();\n\t\t\t\tresult.pop();\n\t\t\t\treturn result.join(\"<br/>\");\n\t\t\t}\n\t\t}\n\t\treturn formatStack(s);\n#else\n\t\treturn formatStack(s);\n#end\n\t}\n\n\tfunction addClass(buf : StringBuf, result : ClassResult, name : String, isOk : Bool)\n\t{\n\t\tif (this.skipResult(result.stats, isOk)) return;\n\t\tbuf.add('<li>');\n\t\tbuf.add('<h2 class=\"classname\">' + name + '</h2>');\n\t\tblockNumbers(buf, result.stats);\n\t\tbuf.add('<ul>\\n');\n\t\tfor (mname in result.methodNames()) {\n\t\t\taddFixture(buf, result.get(mname), mname, isOk);\n\t\t}\n\t\tbuf.add('</ul>\\n');\n\t\tbuf.add('</li>\\n');\n\t}\n\n\tfunction addPackages(buf : StringBuf, result : PackageResult, isOk : Bool)\n\t{\n\t\tif (this.skipResult(result.stats, isOk)) return;\n\t\tbuf.add('<ul id=\"utest-results-packages\">\\n');\n\t\tfor (name in result.packageNames(false))\n\t\t{\n\t\t\taddPackage(buf, result.getPackage(name), name, isOk);\n\t\t}\n\t\tbuf.add('</ul>\\n');\n\t}\n\n\tfunction addPackage(buf : StringBuf, result : PackageResult, name : String, isOk : Bool)\n\t{\n\t\tif (this.skipResult(result.stats, isOk)) return;\n\t\tif (name == '' && result.classNames().length == 0) return;\n\t\tbuf.add('<li>');\n\t\tbuf.add('<h2>' + name + '</h2>');\n\t\tblockNumbers(buf, result.stats);\n\t\tbuf.add('<ul>\\n');\n\t\tfor (cname in result.classNames())\n\t\t\taddClass(buf, result.getClass(cname), cname, isOk);\n\t\tbuf.add('</ul>\\n');\n\t\tbuf.add('</li>\\n');\n\t}\n\n\tpublic function getHeader() : String\n\t{\n\t\tvar buf = new StringBuf();\n\t\tif (!this.hasHeader(result.stats))\n\t\t\treturn \"\";\n\n\t\tvar end = haxe.Timer.stamp();\n\t\tvar time = Std.int((end-startTime)*1000)/1000;\n\t\tvar msg = 'TEST OK';\n\t\tif (result.stats.hasErrors)\n\t\t\tmsg = 'TEST ERRORS';\n\t\telse if (result.stats.hasFailures)\n\t\t\tmsg = 'TEST FAILED';\n\t\telse if (result.stats.hasWarnings)\n\t\t\tmsg = 'WARNING REPORTED';\n\n\t\tbuf.add('<h1 class=\"' + cls(result.stats) + 'bg header\">' + msg + \"</h1>\\n\");\n\t\tbuf.add('<div class=\"headerinfo\">');\n\n\t\tresultNumbers(buf, result.stats);\n\t\tbuf.add(' performed on <strong>' + platform + '</strong>, executed in <strong> ' + time + ' sec. </strong></div >\\n ');\n\t\treturn buf.toString();\n\t}\n\n\tpublic function getTrace() : String\n\t{\n\t\tvar buf = new StringBuf();\n\t\tif (_traces == null || _traces.length == 0)\n\t\t\treturn \"\";\n\t\tbuf.add('<div class=\"trace\"><h2>traces</h2><ol>');\n\t\tfor (t in _traces)\n\t\t{\n\t\t\tbuf.add('<li><div class=\"li\">');\n\t\t\tvar stack = StringTools.replace(formatStack(t.stack, false), \"'\", \"\\\\'\");\n\t\t\tvar method = '<span class=\"tracepackage\">' + t.infos.className + \"</span><br/>\" + t.infos.methodName + \"(\" + t.infos.lineNumber + \")\";\n\t\t\tbuf.add('<span class=\"tracepos\" onmouseover=\"utestTooltip(this.parentNode, \\'' + stack + '\\')\" onmouseout=\"utestRemoveTooltip()\">');\n\t\t\tbuf.add(method);\n\n\t\t\t// time\n\t\t\tbuf.add('</span><span class=\"tracetime\">');\n\t\t\tbuf.add(\"@ \" + formatTime(t.time));\n\t\t\tif(Math.round(t.delta * 1000) > 0)\n\t\t\t\tbuf.add(\", ~\" + formatTime(t.delta));\n\n\t\t\tbuf.add('</span><span class=\"tracemsg\">');\n\t\t\tbuf.add(StringTools.replace(StringTools.trim(t.msg), \"\\n\", \"<br/>\\n\"));\n\n\t\t\tbuf.add('</span><div class=\"clr\"></div></div></li>');\n\t\t}\n\t\tbuf.add('</ol></div>');\n\t\treturn buf.toString();\n\t}\n\n\tpublic function getResults() : String\n\t{\n\t\tvar buf = new StringBuf();\n\t\taddPackages(buf, result, result.stats.isOk);\n\t\treturn buf.toString();\n\t}\n\n\tpublic function getAll() : String\n\t{\n\t\tif (!this.hasOutput(result.stats))\n\t\t\treturn \"\";\n\t\telse\n\t\t\treturn getHeader() + getTrace() + getResults();\n\t}\n\n\tpublic function getHtml(?title : String) : String\n\t{\n\t\tif(null == title)\n\t\t\ttitle = \"utest: \" + platform;\n\t\tvar s = getAll();\n\t\tif ('' == s)\n\t\t\treturn '';\n\t\telse\n\t\t\treturn wrapHtml(title, s);\n\t}\n\n\tvar result : PackageResult;\n\tfunction complete(result : PackageResult) {\n\t\tthis.result = result;\n\t\thandler(this);\n\t\trestoreTrace();\n\t}\n\n\tfunction formatTime(t : Float)\n\t{\n\t\treturn Math.round(t * 1000) + \" ms\";\n\t}\n\n\tfunction cssStyle()\n\t{\n\t\treturn 'body, dd, dt {\n\tfont-family: Verdana, Arial, Sans-serif;\n\tfont-size: 12px;\n}\ndl {\n\twidth: 180px;\n}\ndd, dt {\n\tmargin : 0;\n\tpadding : 2px 5px;\n\tborder-top: 1px solid #f0f0f0;\n\tborder-left: 1px solid #f0f0f0;\n\tborder-right: 1px solid #CCCCCC;\n\tborder-bottom: 1px solid #CCCCCC;\n}\ndd.value {\n\ttext-align: center;\n\tbackground-color: #eeeeee;\n}\ndt {\n\ttext-align: left;\n\tbackground-color: #e6e6e6;\n\tfloat: left;\n\twidth: 100px;\n}\n\nh1, h2, h3, h4, h5, h6 {\n\tmargin: 0;\n\tpadding: 0;\n}\n\nh1 {\n\ttext-align: center;\n\tfont-weight: bold;\n\tpadding: 5px 0 4px 0;\n\tfont-family: Arial, Sans-serif;\n\tfont-size: 18px;\n\tborder-top: 1px solid #f0f0f0;\n\tborder-left: 1px solid #f0f0f0;\n\tborder-right: 1px solid #CCCCCC;\n\tborder-bottom: 1px solid #CCCCCC;\n\tmargin: 0 2px 0px 2px;\n}\n\nh2 {\n\tfont-weight: bold;\n\tpadding: 2px 0 2px 8px;\n\tfont-family: Arial, Sans-serif;\n\tfont-size: 13px;\n\tborder-top: 1px solid #f0f0f0;\n\tborder-left: 1px solid #f0f0f0;\n\tborder-right: 1px solid #CCCCCC;\n\tborder-bottom: 1px solid #CCCCCC;\n\tmargin: 0 0 0px 0;\n\tbackground-color: #FFFFFF;\n\tcolor: #777777;\n}\n\nh2.classname {\n\tcolor: #000000;\n}\n\n.okbg {\n\tbackground-color: #66FF55;\n}\n.errorbg {\n\tbackground-color: #CC1100;\n}\n.failurebg {\n\tbackground-color: #EE3322;\n}\n.warnbg {\n\tbackground-color: #FFCC99;\n}\n.headerinfo {\n\ttext-align: right;\n\tfont-size: 11px;\n\tfont - color: 0xCCCCCC;\n\tmargin: 0 2px 5px 2px;\n\tborder-left: 1px solid #f0f0f0;\n\tborder-right: 1px solid #CCCCCC;\n\tborder-bottom: 1px solid #CCCCCC;\n\tpadding: 2px;\n}\n\nli {\n\tpadding: 4px;\n\tmargin: 2px;\n\tborder-top: 1px solid #f0f0f0;\n\tborder-left: 1px solid #f0f0f0;\n\tborder-right: 1px solid #CCCCCC;\n\tborder-bottom: 1px solid #CCCCCC;\n\tbackground-color: #e6e6e6;\n}\n\nli.fixture {\n\tbackground-color: #f6f6f6;\n\tpadding-bottom: 6px;\n}\n\ndiv.fixturedetails {\n\tpadding-left: 108px;\n}\n\nul {\n\tpadding: 0;\n\tmargin: 6px 0 0 0;\n\tlist-style-type: none;\n}\n\nol {\n\tpadding: 0 0 0 28px;\n\tmargin: 0px 0 0 0;\n}\n\n.statnumbers {\n\tpadding: 2px 8px;\n}\n\n.fixtureresult {\n\twidth: 100px;\n\ttext-align: center;\n\tdisplay: block;\n\tfloat: left;\n\tfont-weight: bold;\n\tpadding: 1px;\n\tmargin: 0 0 0 0;\n}\n\n.testoutput {\n\tborder: 1px dashed #CCCCCC;\n\tmargin: 4px 0 0 0;\n\tpadding: 4px 8px;\n\tbackground-color: #eeeeee;\n}\n\nspan.tracepos, span.traceposempty {\n\tdisplay: block;\n\tfloat: left;\n\tfont-weight: bold;\n\tfont-size: 9px;\n\twidth: 170px;\n\tmargin: 2px 0 0 2px;\n}\n\nspan.tracepos:hover {\n\tcursor : pointer;\n\tbackground-color: #ffff99;\n}\n\nspan.tracemsg {\n\tdisplay: block;\n\tmargin-left: 180px;\n\tbackground-color: #eeeeee;\n\tpadding: 7px;\n}\n\nspan.tracetime {\n\tdisplay: block;\n\tfloat: right;\n\tmargin: 2px;\n\tfont-size: 9px;\n\tcolor: #777777;\n}\n\n\ndiv.trace ol {\n\tpadding: 0 0 0 40px;\n\tcolor: #777777;\n}\n\ndiv.trace li {\n\tpadding: 0;\n}\n\ndiv.trace li div.li {\n\tcolor: #000000;\n}\n\ndiv.trace h2 {\n\tmargin: 0 2px 0px 2px;\n\tpadding-left: 4px;\n}\n\n.tracepackage {\n\tcolor: #777777;\n\tfont-weight: normal;\n}\n\n.clr {\n\tclear: both;\n}\n\n#utesttip {\n\tmargin-top: -3px;\n\tmargin-left: 170px;\n\tfont-size: 9px;\n}\n\n#utesttip li {\n\tmargin: 0;\n\tbackground-color: #ffff99;\n\tpadding: 2px 4px;\n\tborder: 0;\n\tborder-bottom: 1px dashed #ffff33;\n}';\n\t}\n\n\tfunction jsScript()\n\t{\n\t\treturn\n'function utestTooltip(ref, text) {\n\tvar el = document.getElementById(\"utesttip\");\n\tif(!el) {\n\t\tvar el = document.createElement(\"div\")\n\t\tel.id = \"utesttip\";\n\t\tel.style.position = \"absolute\";\n\t\tdocument.body.appendChild(el)\n\t}\n\tvar p = utestFindPos(ref);\n\tel.style.left = (4 + p[0]) + \"px\";\n\tel.style.top = (p[1] - 1) + \"px\";\n\tel.innerHTML =  text;\n}\n\nfunction utestFindPos(el) {\n\tvar left = 0;\n\tvar top = 0;\n\tdo {\n\t\tleft += el.offsetLeft;\n\t\ttop += el.offsetTop;\n\t} while(el = el.offsetParent)\n\treturn [left, top];\n}\n\nfunction utestRemoveTooltip() {\n\tvar el = document.getElementById(\"utesttip\")\n\tif(el)\n\t\tdocument.body.removeChild(el)\n}';\n\t}\n\n\tfunction wrapHtml(title : String, s : String)\n\t{\n\t\treturn\n\t\t\t'<head>\\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" />\\n<title>' + title + '</title>\n\t\t\t<style type=\"text/css\">' + cssStyle() + '</style>\n\t\t\t<script type=\"text/javascript\">\\n' + jsScript() + '\\n</script>\\n</head>\n\t\t\t<body>\\n'+ s + '\\n</body>\\n</html>';\n\t}\n\n\tfunction _handler(report : HtmlReport)\n\t{\n#if nodejs\n\t\t(untyped __js__(process.stdout.write))(report.getHtml());\n#elseif (php || neko || cpp)\n\t\tLib.print(report.getHtml());\n#elseif js\n\t\tvar isDef = function(v) : Bool\n\t\t{\n\t\t\treturn untyped __js__(\"typeof v != 'undefined'\");\n\t\t}\n\n\t\tvar head = Browser.document.getElementsByTagName(\"head\")[0];\n\t\t// add script\n\t\tvar script = Browser.document.createElement('script');\n\t\tuntyped script.type = 'text/javascript';\n\t\tvar sjs = report.jsScript();\n\t\tuntyped if (isDef(script.text))\n\t\t{\n\t\t\tscript.text = sjs;\n\t\t} else {\n\t\t\tscript.innerHTML = sjs;\n\t\t}\n\t\thead.appendChild(script);\n\n\t\t// add style\n\t\tvar style = Browser.document.createElement('style');\n\t\tuntyped style.type = 'text/css';\n\n\t\tvar scss = report.cssStyle();\n\t\tuntyped\n\t\tif (isDef(style.styleSheet))\n\t\t{\n\t\t\tstyle.styleSheet.cssText = scss;\n\t\t} else if (isDef(style.cssText)) {\n\t\t\tstyle.cssText = scss;\n\t\t} else if (isDef(style.innerText)) {\n\t\t\tstyle.innerText = scss;\n\t\t} else {\n\t\t\tstyle.innerHTML = scss;\n\t\t}\n\t\thead.appendChild(style);\n\n\t\t// add content\n\t\tvar el = Browser.document.getElementById(\"utest-results\");\n\t\tif (null == el)\n\t\t{\n\t\t\tel = Browser.document.createElement(\"div\");\n\t\t\tel.id = \"utest-results\";\n\t\t\tBrowser.document.body.appendChild(el);\n\t\t}\n\t\tel.innerHTML = report.getAll();\n#elseif flash\n\t\tvar quote = function(s : String) {\n\t\t\ts = StringTools.replace(s, '\\r', '');\n\t\t\ts = StringTools.replace(s, '\\n', '\\\\n');\n\t\t\ts = StringTools.replace(s, '\"', '\\\\\"');\n\t\t\treturn '\"' + s + '\"';\n\t\t};\n\n\t\tvar fHeader = \"function() {\nvar head = document.getElementsByTagName('head')[0];\n// add script\nvar script = document.createElement('script');\nscript.type = 'text/javascript';\nscript.innerHTML = \" + quote(report.jsScript()) + \";\nhead.appendChild(script);\n// add style\nvar isDef = function(v) { return typeof v != 'undefined'; };\nvar style = document.createElement('style');\nstyle.type = 'text/css';\nvar styleContent = \" + quote(report.cssStyle()) + \";\nif (isDef(style.cssText))\n{\n\tstyle.cssText = styleContent;\n} else if (isDef(style.innerText)) {\n\tstyle.innerText = styleContent;\n} else {\n\tstyle.innerHTML = styleContent;\n}\nhead.appendChild(style);\nif(typeof utest == 'undefined')\n\tutest = { };\nutest.append_result = function(s) {\n\tvar el = document.getElementById('utest-results');\n\tif (null == el) {\n\t\tel = document.createElement('div');\n\t\tel.id = 'utest-results';\n\t\tdocument.body.appendChild(el);\n\t}\n\tel.innerHTML += s;\n};\nutest.append_package = function(s) {\n\tvar el = document.getElementById('utest-results-packages');\n\tel.innerHTML += s;\n};\n}\";\n\t\tvar fResult = \"function() { utest.append_result(\" + quote(report.getAll().substr(0, 7000)) + \"); }\";\n\n\t\tvar ef = function(s : String) { flash.external.ExternalInterface.call('(' + s + ')()'); };\n//\t\tvar ef = function(s : String) { flash.external.ExternalInterface.call('(alert(' + s + '))()'); };\n\t\tvar er = function(s : String) { ef(\"function() { utest.append_result(\" + quote(s) + \"); }\"); };\n\t\tvar ep = function(s : String) { ef(\"function() { utest.append_package(\" + quote(s) + \"); }\"); };\n\n\t\tvar me = this;\n\t\thaxe.Timer.delay(function() {\n\t\t\tef(fHeader);\n\t\t\ter(report.getHeader());\n\t\t\ter(report.getTrace());\n\t\t\tif (me.skipResult(me.result.stats, me.result.stats.isOk)) return;\n\t\t\ter('<ul id=\"utest-results-packages\"></ul>');\n\n\t\t\tfor (name in me.result.packageNames(false))\n\t\t\t{\n\t\t\t\tvar buf = new StringBuf();\n\t\t\t\tme.addPackage(buf, me.result.getPackage(name), name, me.result.stats.isOk);\n\t\t\t\tep(buf.toString());\n\t\t\t}\n//\t\t\ter(report.getResults());\n\n//\t\t\tbuf.add('<ul id=\"utest-results-packages\"></ul>');\n\n/*\t\t\tpublic function getResults() : String {\n\t\t\t\tvar buf = new StringBuf();\n\t\t\t\taddPackage(buf, result, result.stats.isOk);\n\t\t\t\treturn buf.toString();\n\t\t\t}*/\n\t\t} , 100);\n//\t\thaxe.Timer.delay(function() { flash.external.ExternalInterface.call('(' + fResult + ')()'); } , 105);\n#else\n\t\tthrow \"no default handler for this platform\";\n#end\n\t}\n}","package utest.ui.text;\r\n\r\nimport haxe.PosInfos;\r\nimport utest.ui.common.IReport;\r\nimport utest.ui.common.HeaderDisplayMode;\r\n\r\nimport utest.Runner;\r\nimport utest.TestResult;\r\nimport utest.ui.common.ResultAggregator;\r\nusing utest.ui.common.ReportTools;\r\nimport utest.ui.common.PackageResult;\r\nimport haxe.CallStack;\r\n\r\n/**\r\n* @todo add documentation\r\n*/\r\nclass PlainTextReport implements IReport<PlainTextReport> {\r\n\tpublic var displaySuccessResults : SuccessResultsDisplayMode;\r\n\tpublic var displayHeader : HeaderDisplayMode;\r\n\tpublic var handler : PlainTextReport -> Void;\r\n\r\n\tvar aggregator : ResultAggregator;\r\n\tvar newline : String;\r\n\tvar indent : String;\r\n\tpublic function new(runner : Runner, ?outputHandler : PlainTextReport -> Void) {\r\n\t\taggregator = new ResultAggregator(runner, true);\r\n\t\trunner.onStart.add(start);\r\n\t\taggregator.onComplete.add(complete);\r\n\t\tif (null != outputHandler)\r\n\t\t\tsetHandler(outputHandler);\r\n\t\tdisplaySuccessResults = AlwaysShowSuccessResults;\r\n\t\tdisplayHeader = AlwaysShowHeader;\r\n\t}\r\n\r\n\tpublic function setHandler(handler : PlainTextReport -> Void) : Void\r\n\t{\r\n\t\tthis.handler = handler;\r\n\t}\r\n\r\n\tvar startTime : Float;\r\n\tfunction start(e) {\r\n\t\tstartTime = haxe.Timer.stamp();\r\n\t}\r\n\r\n\tfunction indents(c : Int) {\r\n\t\tvar s = '';\r\n\t\tfor(_ in 0...c)\r\n\t\t\ts += indent;\r\n\t\treturn s;\r\n\t}\r\n\r\n\tfunction dumpStack(stack : Array<StackItem>)\r\n\t{\r\n\t\tif (stack.length == 0)\r\n\t\t\treturn \"\";\r\n\t\tvar parts = CallStack.toString(stack).split(\"\\n\"),\r\n\t\t\tr = [];\r\n\t\tfor (part in parts)\r\n\t\t{\r\n\t\t\tif (part.indexOf(\" utest.\") >= 0) continue;\r\n\t\t\tr.push(part);\r\n\t\t}\r\n\t\treturn r.join(newline);\r\n\t}\r\n\r\n\tfunction addHeader(buf : StringBuf, result : PackageResult)\r\n\t{\r\n\t\tif (!this.hasHeader(result.stats))\r\n\t\t\treturn;\r\n\r\n\t\tvar end = haxe.Timer.stamp();\r\n#if php\r\n\t\tvar scripttime = Std.int(Sys.cpuTime()*1000)/1000;\r\n#end\r\n\t\tvar time = Std.int((end-startTime)*1000)/1000;\r\n\r\n\t\tbuf.add(\"results: \" + (result.stats.isOk ? \"ALL TESTS OK\" : \"SOME TESTS FAILURES\")+newline+newline);\r\n\r\n\t\tbuf.add(\"assertations: \"   + result.stats.assertations+newline);\r\n\t\tbuf.add(\"successes: \"      + result.stats.successes+newline);\r\n\t\tbuf.add(\"errors: \"         + result.stats.errors+newline);\r\n\t\tbuf.add(\"failures: \"       + result.stats.failures+newline);\r\n\t\tbuf.add(\"warnings: \"       + result.stats.warnings+newline);\r\n\t\tbuf.add(\"execution time: \" + time+newline);\r\n#if php\r\n\t\tbuf.add(\"script time: \"    + scripttime+newline);\r\n#end\r\n\t\tbuf.add(newline);\r\n\t}\r\n\r\n\tvar result : PackageResult;\r\n\tpublic function getResults() : String\r\n\t{\r\n\t\tvar buf = new StringBuf();\r\n\t\taddHeader(buf, result);\r\n\r\n\t\tfor(pname in result.packageNames()) {\r\n\t\t\tvar pack = result.getPackage(pname);\r\n\t\t\tif (this.skipResult(pack.stats, result.stats.isOk)) continue;\r\n\t\t\tfor(cname in pack.classNames()) {\r\n\t\t\t\tvar cls = pack.getClass(cname);\r\n\t\t\t\tif (this.skipResult(cls.stats, result.stats.isOk)) continue;\r\n\t\t\t\tbuf.add((pname == '' ? '' : pname+\".\")+cname+newline);\r\n\t\t\t\tfor(mname in cls.methodNames()) {\r\n\t\t\t\t\tvar fix = cls.get(mname);\r\n\t\t\t\t\tif (this.skipResult(fix.stats, result.stats.isOk)) continue;\r\n\t\t\t\t\tbuf.add(indents(1)+mname+\": \");\r\n\t\t\t\t\tif(fix.stats.isOk) {\r\n\t\t\t\t\t\tbuf.add(\"OK \");\r\n\t\t\t\t\t} else if(fix.stats.hasErrors) {\r\n\t\t\t\t\t\tbuf.add(\"ERROR \");\r\n\t\t\t\t\t} else if(fix.stats.hasFailures) {\r\n\t\t\t\t\t\tbuf.add(\"FAILURE \");\r\n\t\t\t\t\t} else if(fix.stats.hasWarnings) {\r\n\t\t\t\t\t\tbuf.add(\"WARNING \");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar messages = '';\r\n\t\t\t\t\tfor(assertation in fix.iterator()) {\r\n\t\t\t\t\t\tswitch(assertation) {\r\n\t\t\t\t\t\t\tcase Success(_):\r\n\t\t\t\t\t\t\t\tbuf.add('.');\r\n\t\t\t\t\t\t\tcase Failure(msg, pos):\r\n\t\t\t\t\t\t\t\tbuf.add('F');\r\n\t\t\t\t\t\t\t\tmessages += indents(2)+\"line: \" + pos.lineNumber + \", \" + msg + newline;\r\n\t\t\t\t\t\t\tcase Error(e, s):\r\n\t\t\t\t\t\t\t\tbuf.add('E');\r\n\t\t\t\t\t\t\t\tmessages += indents(2)+ Std.string(e) + dumpStack(s) + newline ;\r\n\t\t\t\t\t\t\tcase SetupError(e, s):\r\n\t\t\t\t\t\t\t\tbuf.add('S');\r\n\t\t\t\t\t\t\t\tmessages += indents(2)+ Std.string(e) + dumpStack(s) + newline;\r\n\t\t\t\t\t\t\tcase TeardownError(e, s):\r\n\t\t\t\t\t\t\t\tbuf.add('T');\r\n\t\t\t\t\t\t\t\tmessages += indents(2)+ Std.string(e) + dumpStack(s) + newline;\r\n\t\t\t\t\t\t\tcase TimeoutError(missedAsyncs, s):\r\n\t\t\t\t\t\t\t\tbuf.add('O');\r\n\t\t\t\t\t\t\t\tmessages += indents(2)+ \"missed async calls: \" + missedAsyncs + dumpStack(s) + newline;\r\n\t\t\t\t\t\t\tcase AsyncError(e, s):\r\n\t\t\t\t\t\t\t\tbuf.add('A');\r\n\t\t\t\t\t\t\t\tmessages += indents(2)+ Std.string(e) + dumpStack(s) + newline;\r\n\t\t\t\t\t\t\tcase Warning(msg):\r\n\t\t\t\t\t\t\t\tbuf.add('W');\r\n\t\t\t\t\t\t\t\tmessages += indents(2)+ msg + newline;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbuf.add(newline);\r\n\t\t\t\t\tbuf.add(messages);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn buf.toString();\r\n\t}\r\n\r\n\tfunction complete(result : PackageResult) {\r\n\t\tthis.result = result;\r\n\t\thandler(this);\r\n\t}\r\n}","package utest.ui.text;\n\nimport haxe.PosInfos;\n\nimport utest.Runner;\nimport utest.TestResult;\nimport utest.ui.common.ResultAggregator;\nimport utest.ui.common.PackageResult;\n\n#if php\nimport php.Lib;\n#elseif neko\nimport neko.Lib;\n#elseif cpp\nimport cpp.Lib;\n#end\n\n/**\n* @todo add documentation\n*/\nclass PrintReport extends PlainTextReport {\n\tvar useTrace : Bool;\n#if (php || neko)\n\tpublic function new(runner : Runner, ?useTrace : Bool) {\n\t\tif(null == useTrace)\n\t\t\tuseTrace = false;\n\t\t\tthis.useTrace = useTrace;\n\t\t\tsuper(runner, _handler);\n#if php\n\t\tif (php.Lib.isCli()) {\n#elseif neko\n\t\tif (!neko.Web.isModNeko) {\n#end\n\t\t\tnewline = \"\\n\";\n\t\t\tindent  = \"  \";\n\t\t} else {\n\t\t\tnewline = \"<br>\";\n\t\t\tindent  = \"&nbsp;&nbsp;\";\n\t\t}\n\t}\n\t\n\tfunction _handler(report : PlainTextReport)\n\t{\n\t\tif (useTrace)\n\t\t\t_trace(report.getResults());\n\t\telse\n\t\t\t_print(report.getResults());\n\t}\n#else\n\tpublic function new(runner : Runner) {\n\t\tsuper(runner, _handler);\n\t\tnewline = \"\\n\";\n\t\tindent  = \"  \";\n\t}\n\t\n\tfunction _handler(report : PlainTextReport)\n\t{\n\t\t_trace(report.getResults());\n\t}\n#end\n\n\tfunction _trace(s : String) {\n\t\ts = StringTools.replace(s, '  ', indent);\n\t\ts = StringTools.replace(s, '\\n', newline);\n\t\ttrace(s);\n\t}\n#if (php || neko || cpp)\n\tfunction _print(s : String) {\n\t\tLib.print(s);\n\t}\n#end\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class defines mathematical functions and constants.\n**/\n#if cpp @:include(\"hxMath\") #end\nextern class Math\n{\n\t/**\n\t\tRepresents the ratio of the circumference of a circle to its diameter, \n\t\tspecified by the constant, π. `PI` is approximately 3.141592653589793.\n\t**/\n\tstatic var PI(default,null) : Float;\n\n\t/**\n\t\tA special Float constant which denotes negative infinity.\n\n\t\tFor example, this is the result of -1.0 / 0.0.\n\n\t\tOperations with NEGATIVE_INFINITY as an operand may result in\n\t\tNEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. \n\n\t\tIf this constant is converted to an Int, e.g. through Std.int(), the\n\t\tresult is unspecified.\n\t**/\n\tstatic var NEGATIVE_INFINITY(default, null) : Float;\n\n\t/**\n\t\tA special Float constant which denotes negative infinity.\n\n\t\tFor example, this is the result of 1.0 / 0.0.\n\n\t\tOperations with POSITIVE_INFINITY as an operand may result in\n\t\tNEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. \n\n\t\tIf this constant is converted to an Int, e.g. through Std.int(), the\n\t\tresult is unspecified.\n\t**/\n\tstatic var POSITIVE_INFINITY(default,null) : Float;\n\n\t/**\n\t\tA special Float constant which denotes an invalid number.\n\n\t\tNaN stands for \"Not a Number\". It occurs when a mathematically incorrect\n\t\toperation is executed, such as taking the square root of a negative\n\t\tnumber: Math.sqrt(-1).\n\n\t\tAll further operations with NaN as an operand will result in NaN.\n\n\t\tIf this constant is converted to an Int, e.g. through Std.int(), the\n\t\tresult is unspecified.\n\n\t\tIn order to test if a value is NaN, you should use Math.isNaN() function.\n\n\t\t@php In PHP versions prior to 5.3.1 VC 9 there may be unexpected\n\t\tresults when performing arithmetic operations with NaN on Windows, \n\t\tsee [https://bugs.php.net/bug.php?id=42143]\n\t**/\n\tstatic var NaN(default, null) : Float;\n\n\t/**\n\t\tReturns the absolute value of `v`.\n\n\t\tIf `v` is positive or 0, the result is unchanged. Otherwise the result \n\t\tis -`v`.\n\t\t\n\t\tIf `v` is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is \n\t\tPOSITIVE_INFINITY.\n\t\t\n\t\tIf `v` is NaN, the result is NaN.\n\t**/\n\tstatic function abs(v:Float):Float;\n\n\t/**\n\t\tReturns the smaller of values `a` and `b`.\n\n\t\tIf `a` or `b` are NaN, the result is NaN.\n\t\tIf `a` or `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.\n\t\tIf `a` and `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t**/\n\tstatic function min(a:Float, b:Float):Float;\n\n\t/**\n\t\tReturns the greater of values `a` and `b`.\n\n\t\tIf `a` or `b` are NaN, the result is NaN.\n\t\tIf `a` or `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t\tIf `a` and `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.\n\t**/\n\tstatic function max(a:Float, b:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric sine of the specified angle `v`, in radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function sin(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric cosine of the specified angle `v`, in radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function cos(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric tangent of the specified angle `v`, in radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function tan(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric arc of the specified angle `v`, in radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function asin(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric arc cosine of the specified angle `v`, \n\t\tin radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function acos(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric arc tangent of the specified angle `v`, \n\t\tin radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function atan(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric arc tangent whose tangent is the quotient of \n\t\ttwo specified numbers, in radians.\n\t\t\n\t\tIf parameter `x` or `y`  is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, \n\t\tthe result is NaN.\n\t**/\n\tstatic function atan2(y:Float, x:Float):Float;\n\n\t/**\n\t\tReturns Euler's number, raised to the power of `v`.\n\t\t\n\t\texp(1.0) is approximately 2.718281828459.\n\t\t\n\t\tIf `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t\tIf `v` is NEGATIVE_INFINITY, the result is 0.0.\n\t\tIf `v` is NaN, the result is NaN.\n\t**/\n\tstatic function exp(v:Float):Float;\n\n\t/**\n\t\tReturns the natural logarithm of `v`.\n\t\t\n\t\tThis is the mathematical inverse operation of exp, \n\t\ti.e. `log(exp(v)) == v` always holds.\n\t\t\n\t\tIf `v` is negative (including NEGATIVE_INFINITY) or NaN, the result \n\t\tis NaN.\n\t\tIf `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t\tIf `v` is 0.0, the result is NEGATIVE_INFINITY.\n\t**/\n\tstatic function log(v:Float):Float;\n\n\t/**\n\t\tReturns a specified base `v` raised to the specified power `exp`.\n\t**/\n\tstatic function pow(v:Float, exp:Float):Float;\n\n\t/**\n\t\tReturns the square root of `v`.\n\t\t\n\t\tIf `v` is negative (including NEGATIVE_INFINITY) or NaN, the result \n\t\tis NaN.\n\t\tIf `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t\tIf `v` is 0.0, the result is 0.0.\n\t**/\n\tstatic function sqrt(v:Float):Float;\n\n\t/**\n\t\tRounds `v` to the nearest integer value.\n\t\t\n\t\tIf `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY \n\t\tor POSITIVE_INFINITY, the result is unspecified.\n\t**/\n\tstatic function round(v:Float):Int;\n\n\t/**\n\t\tReturns the largest integer value that is not greater than `v`.\n\n\t\tIf `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY \n\t\tor POSITIVE_INFINITY, the result is unspecified.\n\t**/\n\tstatic function floor(v:Float):Int;\n\n\t/**\n\t\tReturns the smallest integer value that is not less than `v`.\n\n\t\tIf `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY \n\t\tor POSITIVE_INFINITY, the result is unspecified.\n\t**/\n\tstatic function ceil(v:Float):Int;\n\n\t/**\n\t\tReturns a pseudo-random number which is greater than or equal to 0.0, \n\t\tand less than 1.0.\n\t**/\n\tstatic function random() : Float;\n\n\t#if ((flash9 && !as3) || cpp)\n\t/**\n\t\tReturns the largest integer value that is not greater than `v`, as a Float.\n\n\t\tIf `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, \n\t\tthe result is unspecified.\n\t**/\n\tstatic function ffloor( v : Float ) : Float;\n\n\t/**\n\t\tReturns the smallest integer value that is not less than `v`, as a Float.\n\n\t\tIf `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, \n\t\tthe result is unspecified.\n\t**/\n\tstatic function fceil( v : Float ) : Float;\n\n\t/**\n\t\tRounds `v` to the nearest integer value, as a Float.\n\n\t\tIf `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, \n\t\tthe result is unspecified.\n\t**/\n\tstatic function fround( v : Float ) : Float;\n\n\t#else\n\n\tstatic inline function ffloor( v : Float ) : Float {\n\t\treturn floor(v);\n\t}\n\n\tstatic inline function fceil( v : Float ) : Float {\n\t\treturn ceil(v);\n\t}\n\n\tstatic inline function fround( v : Float ) : Float {\n\t\treturn round(v);\n\t}\n\n\t#end\n\n\n\t/**\n\t\tTells if `f` is a finite number.\n\n\t\tIf `f` is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result \n\t\tis false, otherwise the result is true.\n\t**/\n\tstatic function isFinite( f : Float ) : Bool;\n\n\t/**\n\t\tTells if `f` is not a valid number.\n\n\t\tIf `f` is NaN, the result is true, otherwise the result is false. \n\t\tIn particular, both POSITIVE_INFINITY and NEGATIVE_INFINITY are\n\t\tnot considered NaN.\n\t**/\n\tstatic function isNaN( f : Float ) : Bool;\n\n\tprivate static function __init__() : Void untyped {\n\t#if flash9\n\t\tNaN = __global__[\"Number\"].NaN;\n\t\tNEGATIVE_INFINITY = __global__[\"Number\"].NEGATIVE_INFINITY;\n\t\tPOSITIVE_INFINITY = __global__[\"Number\"].POSITIVE_INFINITY;\n\t#else\n\t\t#if !js // genjs.ml will insert this only if necessary.\n\t\t\tMath.__name__ = [\"Math\"];\n\t\t#end\n\t\tMath.NaN = Number[\"NaN\"];\n\t\tMath.NEGATIVE_INFINITY = Number[\"NEGATIVE_INFINITY\"];\n\t\tMath.POSITIVE_INFINITY = Number[\"POSITIVE_INFINITY\"];\n\t#end\n\t#if js\n\t\t__feature__(\"Type.resolveClass\",$hxClasses['Math'] = Math);\n\t#end\n\t\tMath.isFinite = function(i) {\n\t\t\treturn\n\t\t\t#if flash9\n\t\t\t__global__[\"isFinite\"](i);\n\t\t\t#elseif flash\n\t\t\t_global[\"isFinite\"](i);\n\t\t\t#elseif js\n\t\t\t__js__(\"isFinite\")(i);\n\t\t\t#else\n\t\t\tfalse;\n\t\t\t#end\n\t\t};\n\t\tMath.isNaN = function(i) {\n\t\t\treturn\n\t\t\t#if flash9\n\t\t\t__global__[\"isNaN\"](i);\n\t\t\t#elseif flash\n\t\t\t_global[\"isNaN\"](i);\n\t\t\t#elseif js\n\t\t\t__js__(\"isNaN\")(i);\n\t\t\t#else\n\t\t\tfalse;\n\t\t\t#end\n\t\t};\n\t}\n\n}\n\n\n"],
"names":[],
"mappings":"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"
}